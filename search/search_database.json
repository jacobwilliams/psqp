var tipuesearch = {"pages":[{"title":" psqp ","text":"psqp PSQP - A sequential quadratic programming algorithm\nfor general nonlinear programming problems. This is work in progress to refactor the original PSQP (by Ladislav Luksan) into Modern Fortran. The latest API documentation can be found here . Original Readme Introduction The double-precision FORTRAN 77 basic subroutine PSQP is designed\nto find a close approximation to a local minimum of a nonlinear\nobjective function F(X) with simple bounds on variables and general\nnonlinear constraints. Here X is a vector of N variables and F(X), is\na smooth function. Simple bounds are assumed in the form X ( I ) unbounded if IX ( I ) = 0 , XL ( I ) <= X ( I ) if IX ( I ) = 1 , X ( I ) <= XU ( I ) if IX ( I ) = 2 , XL ( I ) <= X ( I ) <= XU ( I ) if IX ( I ) = 3 , XL ( I ) = X ( I ) = XU ( I ) if IX ( I ) = 5 , where 1 <= I <= N. General nonlinear constraints are assumed in the form C_I(X) unbounded if  IC(I) = 0,\n      CL(I) <= C_I(X)           if  IC(I) = 1,\n               C_I(X) <= CU(I)  if  IC(I) = 2,\n      CL(I) <= C_I(X) <= CU(I)  if  IC(I) = 3,\n      CL(I)  = C_I(X)  = CU(I)  if  IC(I) = 5, where C_I(X), 1 <= I <= NC, are twice continuously differentiable\nfunctions. To simplify user's work, an additional easy to use subroutine\nPSQPN is added. It calls the basic general subroutine PSQP. All\nsubroutines contain a description of formal parameters and extensive\ncomments. Furthermore, test program TSQPN is included, which contains\nseveral test problems. This test programs serve as an example for\nusing the subroutine PSQPN, verify its correctness and demonstrate\nits efficiency. In this short guide, we describe all subroutines which can be\ncalled from the user's program. In the description of formal parameters,\nwe introduce a type of the argument that specifies whether the argument\nmust have a value defined on entry to the subroutine (I), whether it\nis a value which will be returned (O), or both (U), or whether it is\nan auxiliary value (A). Note that the arguments of the type I can be\nchanged on output under some circumstances, especially if improper\ninput values were given. Besides formal parameters, we can use a\nCOMMON /STAT/ block containing statistical information. This block,\nused in each subroutine has the following form: COMMON /STAT/ NRES,NDEC,NREM,NADD,NIT,NFV,NFG,NFH The arguments have the following meaning: Argument Type Significance ---------------------------------------------------------------------- NRES O Positive INTEGER variable that indicates the number of restarts . NDEC O Positive INTEGER variable that indicates the number of matrix decompositions . NRED O Positive INTEGER variable that indicates the number of reductions . NREM O Positive INTEGER variable that indicates the number of constraint deletions during the QP solutions . NADD O Positive INTEGER variable that indicates the number of constraint additions during the QP solutions . NIT O Positive INTEGER variable that indicates the number of iterations . NFV O Positive INTEGER variable that indicates the number of function evaluations . NFG O Positive INTEGER variable that specifies the number of gradient evaluations . NFH O Positive INTEGER variable that specifies the number of Hessian evaluations . Subroutine PSQN The calling sequence is CALL PSQPN(NF,NB,NC,X,IX,XL,XU,CF,IC,CL,CU,IPAR,RPAR,F,GMAX,\n     &           CMAX,IPRNT,ITERM) The arguments have the following meaning. Argument Type Significance ---------------------------------------------------------------------- NF I Positive INTEGER variable that specifies the number of variables of the objective function . NB I Nonnegative INTEGER variable that specifies whether the simple bounds are suppressed ( NB = 0 ) or accepted ( NB > 0 ). NC I Nonnegative INTEGER variable that specifies the number of general nonlinear constraints ; if NC = 0 the general nonlinear constraints are suppressed . X ( NF ) U On input , DOUBLE PRECISION vector with the initial estimate to the solution . On output , the approximation to the minimum . IX ( NF ) I On input ( significant only if NB > 0 ) INTEGER vector containing the simple bounds types : IX ( I )= 0 - the variable X ( I ) is unbounded , IX ( I )= 1 - the lower bound X ( I ) >= XL ( I ), IX ( I )= 2 - the upper bound X ( I ) <= XU ( I ), IX ( I )= 3 - the two side bound XL ( I ) <= X ( I ) <= XU ( I ), IX ( I )= 5 - the variable X ( I ) is fixed ( given by its initial estimate ). XL ( NF ) I DOUBLE PRECISION vector with lower bounds for variables ( significant only if NB > 0 ). XU ( NF ) I DOUBLE PRECISION vector with upper bounds for variables ( significant only if NB > 0 ). CF ( NC ) A DOUBLE PRECISION vector which contains values of constraint functions ( only if NC > 0 ). IC ( NC ) I On input ( significant only if NC > 0 ) INTEGER vector which contains constraint types : IC ( K )= 0 - the constraint CF ( K ) is not used , IC ( K )= 1 - the lower constraint CF ( K ) >= CL ( K ), IC ( K )= 2 - the upper constraint CF ( K ) <= CU ( K ), IC ( K )= 3 - the two side constraint CL ( K ) <= CF ( K ) <= CU ( K ), IC ( K )= 5 - the equality constraint CF ( K ) = CL ( K ). CL ( NC ) I DOUBLE PRECISION vector with lower bounds for constraint functions ( significant only if NC > 0 ). CU ( NC ) I DOUBLE PRECISION vector with upper bounds for constraint functions ( significant only if NC > 0 ). IPAR ( 6 ) A INTEGER parameters : IPAR ( 1 )= MIT , IPAR ( 2 )= MFV , IPAR ( 3 ) - NONE , IPAR ( 4 ) - NONE , IPAR ( 5 )= MET , IPAR ( 5 )= MEC . Parameters MIT , MFV , MET , MEC are described in Section 3 together with other parameters of the subroutine PSQP . RPAR ( 5 ) A DOUBLE PRECISION parameters : RPAR ( 1 )= XMAX , RPAR ( 2 )= TOLX , RPAR ( 3 )= TOLC , RPAR ( 4 )= TOLG , RPAR ( 5 )= RPF . Parameters XMAX , TOLX , TOLC , TOLG , RPF are described in Section 3 together with other parameters of the subroutine PSQP . F O DOUBLE PRECISION value of the objective function at the solution X . GMAX O DOUBLE PRECISION maximum absolute value of a partial derivative of the Lagrangian function . CMAX O maximum constraint violation . IPRNT I INTEGER variable that specifies PRINT : IPRNT = 0 - print is suppressed , IPRNT = 1 - basic print of final results , IPRNT = - 1 - extended print of final results , IPRNT = 2 - basic print of intermediate and final results , IPRNT = - 2 - extended print of intermediate and final results . ITERM O INTEGER variable that indicates the cause of termination : ITERM = 1 - if | X - XO | was less than or equal to TOLX in MTESX subsequent iterations , ITERM = 2 - if | F - FO | was less than or equal to TOLF in MTESF subsequent iterations , ITERM = 3 - if F is less than or equal to TOLB , ITERM = 4 - if GMAX is less than or equal to TOLG , ITERM = 11 - if NIT exceeded MIT , ITERM = 12 - if NFV exceeded MFV , ITERM < 0 - if the method failed . If ITERM = - 6 , then the termination criterion has not been satisfied , but the point obtained is usually acceptable . The subroutine PSQPN requires the user supplied subroutines OBJ,\nDOBJ that define the objective function and its gradient and CON, DCON\nthat define constraint functions and their gradients. These subroutines\nhave the form SUBROUTINE  OBJ(NF,X,F)\n      SUBROUTINE DOBJ(NF,X,G)\n      SUBROUTINE  CON(NF,KC,X,FC)\n      SUBROUTINE DCON(NF,KC,X,GC) The arguments of the user supplied subroutine have the following meaning. Argument Type Significance ---------------------------------------------------------------------- NF I Positive INTEGER variable that specifies the number of variables of the objective function . X ( NF ) I DOUBLE PRECISION an estimate to the solution . F O DOUBLE PRECISION value of the objective function at the point X . G ( NF ) O DOUBLE PRECISION gradient of the objective function at the point X . KC I INTEGER index of the partial function . FC O DOUBLE PRECISION value of the KC - th partial function at the point X . GC ( NF ) O DOUBLE PRECISION gradient of the KC - th partial function at the point X . Subroutine PSQP This general subroutine is called from all the subroutines described\nin Section 2. The calling sequence is CALL PSQP ( NF , NB , NC , X , IX , XL , XU , CF , IC , CL , CU , CG , CFO , CFD , GC , ICA , CR , & CZ , CP , GF , G , H , S , XO , GO , XMAX , TOLX , TOLC , TOLG , RPF , CMAX , GMAX , F , MIT , & MFV , MEC , IPRNT , ITERM ). The arguments NF, NB, NC, X, IX, XL, XU, CF, IC, CL, CU, CMAX, GMAX,\nF, IPRNT, ITERM, have the same meaning as in Section 2. Other arguments\nhave the following meaning: Argument Type Significance ---------------------------------------------------------------------- CG ( NF * NC ) A DOUBLE PRECISION elements of the constraint Jacobian matrix . CFO ( NC + 1 ) A DOUBLE PRECISION vector which contains old values of constraint functions . CFD ( NC ) A DOUBLE PRECISION vector of constraint function increments . GC ( NF ) A DOUBLE PRECISION gradient of the constraint function . ICA ( NC ) A INTEGER vector containing indices of active constraints . CR ( NCR ) A DOUBLE PRECISION matrix containing triangular decomposition of the orthogonal projection kernel ( NCR is equal to NF * ( NF + 1 ) / 2 ). CZ ( NF ) A DOUBLE PRECISION vector of Lagrange multipliers . of linear manifold defined by active constraints . CP ( NF ) A DOUBLE PRECISION auxiliary array . GF ( NF ) A DOUBLE PRECISION gradient of the objective function . G ( NF ) A DOUBLE PRECISION gradient of the Lagrangian function . H ( NH ) A DOUBLE PRECISION variable metric approximation of the Hessian matrix of the Lagrangian function . S ( NF ) A DOUBLE PRECISION direction vector . XO ( NF ) A DOUBLE PRECISION vector which contains increments of variables . GO ( NF ) A DOUBLE PRECISION vector which contains increments of gradients . XMAX I DOUBLE PRECISION maximum stepsize ; the choice XMAX = 0 causes that the default value 1.0 D + 3 will be taken . TOLX I DOUBLE PRECISION tolerance for the change of the coordinate vector X ; the choice TOLX = 0 causes that the default value TOLX = 1.0 D - 16 will be taken . TOLC I DOUBLE PRECISION tolerance for the constraint violation ; the choice TOLC = 0 causes that the default value TOLC = 1.0 D - 6 will be taken . TOLG I DOUBLE PRECISION tolerance for the Lagrangian function gradient ; the choice TOLG = 0 causes that the default value TOLG = 1.0 D - 6 will be taken . RPF I DOUBLE PRECISION value of the penalty coefficient ; the choice RPF = 0 causes that the default value 1.0 D - 4 will be taken . MIT I INTEGER variable that specifies the maximum number of iterations ; the choice MIT = 0 causes that the default value 1000 will be taken . MFV I INTEGER variable that specifies the maximum number of function evaluations ; the choice | MFV |= 0 causes that the default value 2000 will be taken . MET I INTEGER variable that specifies the variable metric update . MET = 1 - the BFGS update is used . MET = 2 - the Hoshino update is used . The choice MET = 0 causes that the default value MET = 1 will be taken . MEC I INTEGER variable that specifies a correction when the negative curvature is detected : MEC = 1 - correction is not used . MEC = 2 - the Powell correction is used . The choice MEC = 0 causes that the default value MEC = 2 will be taken . The default velue RPF=0.0001 is relatively small. Therefore, larger\nvalue (RPF=1 say) can sometimes be more suitable. The subroutine PSQP requires the user supplied subroutines OBJ\nDOBJ, CON, DCON,  which are described in Section 2. Subroutine PLQDB1 Since the dual range space method for solving quadratic programming\nsubproblems arising in sequential quadratic programming algorithms\ncan be used separately in many applications, we describe the subroutine\nPLQDB1 in more details. The calling sequence is CALL PLQDB1 ( NF , NC , X , IX , XL , XU , CF , CFD , IC , ICA , CL , CU , CG , CR , CZ , G , GO , & H , S , MFP , KBF , KBC , IDECF , ETA2 , ETA9 , EPS7 , EPS9 , UMAX , GMAX , N , ITERQ ) The arguments NF, NC, X, IX, XL, XU, CF, IC, CL, CU, have the same\nmeaning as in Section 2 (only with the difference that the\narguments X and CF are of the type (I), i.e. they  must have a value\ndefined on entry to ULQDF1 and they are not changed). The arguments\nCFD, ICA, CG, CR, CZ have the same meaning as in Section 3 (only with\nthe difference that the arguments CFD, ICA, CR, CZ are of the type (O),\ni.e. their values can be used subsequently). Other arguments have the\nfollowing meaning: Argument Type Significance ---------------------------------------------------------------------- G ( NF ) O DOUBLE PRECISION gradient of the Lagrangian function . GO ( NF ) A DOUBLE PRECISION old gradient of the Lagrangian function . H ( NH ) U DOUBLE PRECISION Choleski decomposition of the approximate Hessian ( NH is equal to NF * ( NF + 1 ) / 2 ). S ( NF ) O DOUBLE PRECISION direction vector . MFP I INTEGER variable that specifies the type of the computed point . MFP = 1 - computation is terminated whenever an arbitrary feasible point is found , MFP = 2 - computation is terminated whenever an optimum feasible point is found , MFP = 3 - computation starts from the previously reached point and is terminated whenever an optimum feasible point is found . KBF I INTEGER variable that specifies simple bounds on variables . KBF = 0 - simple bounds are suppressed , KBF = 1 - one sided simple bounds , KBF = 2 - two sided simple bounds . KBC I INTEGER variable that specifies general linear constraints . KBC = 0 - linear constraints are suppressed , KBC = 1 - one sided linear constraints , KBC = 2 - two sided linear constraints . IDECF U INTEGER variable that specifies the type of matrix decomposition . IDECF = 0 - no decomposition , IDECF = 1 - Choleski decomposition , IDECF = 9 - inversion , IDECF = 10 - diagonal matrix . ETA2 I DOUBLE PRECISION tolerance for positive definiteness in the Choleski decomposition . ETA9 I DOUBLE PRECISION maximum floating point number . EPS7 I DOUBLE PRECISION tolerance for linear independence of constraints ( the recommended value is 1.0 D - 10 ). EPS9 I DOUBLE PRECISION tolerance for the definition of active constraints ( the recommended value is 1.0 D - 8 ). UMAX O DOUBLE PRECISION maximum absolute value of the negative Lagrange multiplier . GMAX O DOUBLE PRECISION infinity norm of the gradient of the Lagrangian function . N O INTEGER dimension of a manifold defined by active constraints . ITERQ O INTEGER variable that indicates the type of the computed feasible point . ITERQ = 1 - an arbitrary feasible point was found , ITERQ = 2 - the optimum feasible point was found , ITERQ = - 1 - an arbitrary feasible point does not exist , ITERQ = - 2 - the optimum feasible point does not exist . Verification of the subroutines Subroutine PSQPN can be verified and tested using the program\nTSQPN. This program calls the subroutines TIND07 (initiation),\nTFFU07 (objective function evaluation), TFGU07 (objective gradient\nevaluation), TCFU07 (constraint functions evaluation) and TFGU07\n(constraint gradients evaluation) containing 34 equality constrained\ntest problems with at most 20 variables. The results obtained\nby the program TSQPN on a PC computer with Microsoft Power Station\nFortran compiler have the following form. NIT=   7  NFV=   7  NFG=   7  F=-1.41421      C=0.8E-08  G=0.4E-06  ITERM=  4\nNIT=  12  NFV=  12  NFG=  12  F=-1.00000      C=0.5E-10  G=0.6E-07  ITERM=  4\nNIT=  10  NFV=  11  NFG=  10  F=-30.0000      C=0.3E-10  G=0.8E-08  ITERM=  4\nNIT=   6  NFV=   6  NFG=   6  F= 1.28072      C=0.0E+00  G=0.4E-06  ITERM=  4\nNIT=  36  NFV=  40  NFG=  36  F=0.284597E-01  C=0.0E+00  G=0.1E-06  ITERM=  4\nNIT=  11  NFV=  13  NFG=  11  F= 1.00000      C=0.0E+00  G=0.4E-06  ITERM=  4\nNIT=   6  NFV=   6  NFG=   6  F=-6961.81      C=0.7E-08  G=0.1E-06  ITERM=  4\nNIT=   4  NFV=   4  NFG=   4  F= 40.1987      C=0.0E+00  G=0.2E-06  ITERM=  4\nNIT=   9  NFV=   9  NFG=   9  F= 13.3567      C=0.3E-06  G=0.8E-07  ITERM=  4\nNIT=  16  NFV=  23  NFG=  16  F=-22.6274      C=0.9E-11  G=0.3E-06  ITERM=  4\nNIT=  14  NFV=  14  NFG=  14  F= 1.00000      C=0.0E+00  G=0.8E-06  ITERM=  4\nNIT=  10  NFV=  13  NFG=  10  F= 6.00000      C=0.2E-12  G=0.1E-06  ITERM=  4\nNIT=  54  NFV=  71  NFG=  54  F= 6299.84      C=0.4E-15  G=0.2E-07  ITERM=  4\nNIT=   8  NFV=   8  NFG=   8  F=-.834032      C=0.3E-07  G=0.3E-08  ITERM=  4\nNIT=  30  NFV=  30  NFG=  30  F=-1162.12      C=0.0E+00  G=0.1E-06  ITERM=  4\nNIT=  74  NFV=  76  NFG=  74  F= 4.75530      C=0.0E+00  G=0.4E-06  ITERM=  4\nNIT=  22  NFV=  22  NFG=  22  F= 727.679      C=0.4E-14  G=0.7E-06  ITERM=  4\nNIT=  11  NFV=  14  NFG=  11  F=-44.0000      C=0.9E-12  G=0.8E-07  ITERM=  4\nNIT=  29  NFV=  35  NFG=  29  F=-210.408      C=0.2E-13  G=0.1E-06  ITERM=  4\nNIT=   4  NFV=   4  NFG=   4  F=-30665.0      C=0.3E-08  G=0.1E-06  ITERM=  4\nNIT=  11  NFV=  30  NFG=  11  F=-.528034E+07  C=0.0E+00  G=0.1E-07  ITERM=  4\nNIT=  21  NFV=  21  NFG=  21  F=-1.90516      C=0.1E-08  G=0.2E-10  ITERM=  4\nNIT=  10  NFV=  12  NFG=  10  F= 5.00000      C=0.2E-11  G=0.8E-07  ITERM=  4\nNIT=  45  NFV=  50  NFG=  45  F= 135.076      C=0.3E-14  G=0.3E-07  ITERM=  4\nNIT=  10  NFV=  10  NFG=  10  F= 4.07125      C=0.0E+00  G=0.7E-10  ITERM=  4\nNIT=  16  NFV=  19  NFG=  16  F= 680.630      C=0.1E-11  G=0.5E-06  ITERM=  4\nNIT=  26  NFV=  35  NFG=  26  F= 221.878      C=0.2E-15  G=0.3E-06  ITERM=  4\nNIT=  32  NFV=  33  NFG=  32  F= 3.95116      C=0.9E-11  G=0.6E-06  ITERM=  4\nNIT=  21  NFV=  21  NFG=  21  F= 7049.25      C=0.4E-07  G=0.1E-06  ITERM=  4\nNIT=  16  NFV=  16  NFG=  16  F=-.866025      C=0.2E-08  G=0.2E-09  ITERM=  4\nNIT=  22  NFV=  24  NFG=  22  F= 24.3062      C=0.5E-12  G=0.3E-06  ITERM=  4\nNIT=  22  NFV=  22  NFG=  22  F= 32.3487      C=0.8E-12  G=0.1E-06  ITERM=  4\nNIT=  77  NFV=  77  NFG=  77  F= 174.787      C=0.6E-11  G=0.4E-10  ITERM=  4\nNIT=  32  NFV=  35  NFG=  32  F= 133.728      C=0.9E-13  G=0.8E-06  ITERM=  4\nNITER =  734    NFVAL =  823    NSUCC =   34\nTIME= 0:00:00.03 The rows corresponding to individual test problems contain the number of\niterations NIT, the number of function evaluations NFV, the number of\ngradient evaluations NFG, the final value of the objective function F,\nthe constraint violation C, the norm of the Lagrangian function gradient\nG and the cause of termination ITERM. Developer Info Jacob Williams","tags":"home","url":"index.html"},{"title":"psqp_class – psqp ","text":"type, public :: psqp_class The main PSQP class to use. Components Type Visibility Attributes Name Initial integer, public :: nres = 0 number of restarts. integer, public :: ndec = 0 number of matrix decomposition. integer, public :: nrem = 0 number of constraint deletions. integer, public :: nadd = 0 number of constraint additions. integer, public :: nit = 0 number of iterations. integer, public :: nfv = 0 number of function evaluations. integer, public :: nfg = 0 number of gradient evaluations. integer, public :: nfh = 0 number of hessian evaluations. integer, private :: mtyp = 0 integer, private :: mode = 0 integer, private :: mes1 = 0 integer, private :: mes2 = 0 real(kind=wp), private :: rl = 0.0_wp real(kind=wp), private :: fl = 0.0_wp real(kind=wp), private :: ru = 0.0_wp real(kind=wp), private :: fu = 0.0_wp real(kind=wp), private :: ri = 0.0_wp real(kind=wp), private :: fi = 0.0_wp procedure( obj_func ), private, pointer :: obj => null() objective function procedure( dobj_func ), private, pointer :: dobj => null() gradient of the objective function procedure( con_func ), private, pointer :: con => null() constraint function procedure( dcon_func ), private, pointer :: dcon => null() gradient of the constraint function procedure( report_f ), private, pointer :: report => null() iteration report function Type-Bound Procedures procedure, public :: psqpn private  subroutine psqpn (me, nf, nb, nc, x, bound_type, xl, xu, cf, constraint_type, cl, cu, ipar, rpar, f, gmax, cmax, iprnt, iterm, obj, dobj, con, dcon, report) Date 97/01/22 easy to use subroutine for general nonlinear programming problems. Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer, intent(in) :: nf number of variables integer, intent(in) :: nb choice of simple bounds. Read more… integer, intent(in) :: nc number of general nonlinear constraints. real(kind=wp), intent(inout), dimension(nf) :: x x(nf) vector of variables. integer, intent(in), dimension(nf) :: bound_type ix(nf) vector containing types of bounds. Read more… real(kind=wp), intent(in), dimension(nf) :: xl xl(nf) vector containing lower bounds for variables. real(kind=wp), intent(in), dimension(nf) :: xu xu(nf) vector containing upper bounds for variables. real(kind=wp), intent(out), dimension(nc+1) :: cf cf(nc+1) vector containing values of the constraint functions. integer, intent(in), dimension(nc) :: constraint_type ic(nc) vector containing types of constraints: Read more… real(kind=wp), intent(in), dimension(nc) :: cl cl(nc) vector containing lower bounds for constraint functions. real(kind=wp), intent(in), dimension(nc) :: cu cu(nc) vector containing upper bounds for constraint functions. integer, intent(in), dimension(6) :: ipar integer paremeters: Read more… real(kind=wp), intent(in), dimension(5) :: rpar real parameters: Read more… real(kind=wp), intent(out) :: f value of the objective function. real(kind=wp), intent(out) :: gmax maximum partial derivative of the lagrangian function. real(kind=wp), intent(out) :: cmax maximum constraint violation. integer, intent(in) :: iprnt print specification: Read more… integer, intent(out) :: iterm variable that indicates the cause of termination. Read more… procedure( obj_func ) :: obj computation of the value of the objective function procedure( dobj_func ) :: dobj computation of the gradient of the objective function procedure( con_func ) :: con computation of the value of the constraint function procedure( dcon_func ) :: dcon computation of the gradient of the constraint function procedure( report_f ), optional :: report iteration report function. Note: this is independent of iprnt . \nIf this function is associated, each iteration will be reported procedure, public :: psqp private  subroutine psqp (me, nf, nb, nc, x, ix, xl, xu, cf, ic, cl, cu, cg, cfo, cfd, gc, ica, cr, cz, cp, gf, g, h, s, xo, go, xmax, tolx, tolc, tolg, rpf, cmax, gmax, f, mit, mfv, met, mec, iprnt, iterm) Date 97/01/22 recursive quadratic programming method with the bfgs variable metric\n  update for general nonlinear programming problems. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf number of variables. integer :: nb choice of simple bounds. Read more… integer :: nc number of linear constraints. real(kind=wp) :: x (*) x(nf)  vector of variables. integer, intent(inout) :: ix (*) ix(nf)  vector containing types of bounds. Read more… real(kind=wp) :: xl (*) xl(nf)  vector containing lower bounds for variables. real(kind=wp) :: xu (*) xu(nf)  vector containing upper bounds for variables. real(kind=wp) :: cf (*) cf(nc+1)  vector containing values of the constraint functions. integer, intent(inout) :: ic (*) ic(nc)  vector containing types of constraints. Read more… real(kind=wp) :: cl (*) cl(nc)  vector containing lower bounds for constraint functions. real(kind=wp) :: cu (*) cu(nc)  vector containing upper bounds for constraint functions. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals of the linear constraints. real(kind=wp) :: cfo (*) cfo(nc)  vector containing saved values of the constraint functions. real(kind=wp) :: cfd (*) cfd(nc)  vector containing increments of the constraint functions. real(kind=wp) :: gc (*) gc(nf)  gradient of the selected constraint function. integer :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cr (*) cr(nf*(nf+1)/2)  triangular decomposition of kernel\nof the orthogonal projection. real(kind=wp) :: cz (*) cz(nf)  vector of lagrange multipliers. real(kind=wp) :: cp (*) real(kind=wp) :: gf (*) gf(nf)  gradient of the model function. real(kind=wp) :: g (*) g(nf)  gradient of the objective function. real(kind=wp) :: h (*) h(nf*(nf+1)/2)  triangular decomposition or inversion of\nthe hessian matrix approximation. real(kind=wp) :: s (*) s(nf)  direction vector. real(kind=wp) :: xo (*) xo(nf)  vectors of variables difference. real(kind=wp) :: go (*) go(nf)  gradients difference. real(kind=wp) :: xmax maximum stepsize. real(kind=wp) :: tolx tolerance for change of variables. real(kind=wp) :: tolc tolerance for constraint violations. real(kind=wp) :: tolg tolerance for the gradient of the lagrangian function. real(kind=wp) :: rpf penalty coefficient. real(kind=wp) :: cmax maximum constraint violation. real(kind=wp) :: gmax maximum partial derivative of the lagrangian function. real(kind=wp) :: f value of the objective function. integer :: mit maximum number of iterations. integer :: mfv maximum number of function evaluations. integer :: met variable metric update used. Read more… integer :: mec correction if the negative curvature occurs. Read more… integer :: iprnt print specification. Read more… integer :: iterm variable that indicates the cause of termination. Read more… procedure, private :: compute_obj_and_dobj private  subroutine compute_obj_and_dobj (me, nf, x, gf, g, ff, f, kd, ld, iext) Date 97/12/01 computation of the value and the gradient of the objective function. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer, intent(in) :: nf number of variables. real(kind=wp), intent(in) :: x (nf) x(nf)   vector of variables. real(kind=wp), intent(out) :: gf (nf) gf(nf)  gradient of the model function. real(kind=wp), intent(out) :: g (nf) g(nf)   gradient of the objective function. real(kind=wp), intent(out) :: ff value of the model function. real(kind=wp), intent(out) :: f value of the objective function. integer, intent(in) :: kd degree of required derivatives. integer, intent(inout) :: ld degree of previously computed derivatives. integer, intent(in) :: iext type of extremum. Read more… procedure, private :: dual_range_space_quad_prog private  subroutine dual_range_space_quad_prog (me, nf, nc, x, ix, xl, xu, cf, cfd, ic, ica, cl, cu, cg, cr, cz, g, go, h, s, mfp, kbf, kbc, idecf, eta2, eta9, eps7, eps9, umax, gmax, n, iterq) Date 97/12/01 dual range space quadratic programming method. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf number of variables. integer :: nc number of linear constraints. real(kind=wp) :: x (*) x(nf)   vector of variables. integer :: ix (*) ix(nf)  vector containing types of bounds. real(kind=wp) :: xl (*) xl(nf)  vector containing lower bounds for variables. real(kind=wp) :: xu (*) xu(nf)  vector containing upper bounds for variables. real(kind=wp) :: cf (*) cf(nf)  vector containing values of the constraint functions. real(kind=wp) :: cfd (*) cfd(nc)  vector containing increments of the constraint functions. integer :: ic (*) ic(nc)  vector containing types of constraints. integer :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cl (*) cl(nc)  vector containing lower bounds for constraint functions. real(kind=wp) :: cu (*) cu(nc)  vector containing upper bounds for constraint functions. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals of the linear constraints. real(kind=wp) :: cr (*) cr(nf*(nf+1)/2)  triangular decomposition of kernel of the orthogonal projection. real(kind=wp) :: cz (*) cz(nf)  vector of lagrange multipliers. real(kind=wp) :: g (*) g(nf)  gradient of the lagrangian function. real(kind=wp) :: go (*) go(nf)  saved gradient of the objective function. real(kind=wp) :: h (*) h(nf*(nf+1)/2)  triangular decomposition or inversion\nof the hessian matrix approximation. real(kind=wp) :: s (*) s(nf)  direction vector. integer :: mfp type of feasible point. Read more… integer :: kbf specification of simple bounds. Read more… integer :: kbc specification of linear constraints. Read more… integer :: idecf decomposition indicator. Read more… real(kind=wp) :: eta2 tolerance for positive definiteness of the hessian matrix. real(kind=wp) :: eta9 maximum for real numbers. real(kind=wp) :: eps7 tolerance for linear independence of constraints. real(kind=wp) :: eps9 tolerance for activity of constraints. real(kind=wp) :: umax maximum absolute value of a negative lagrange multiplier. real(kind=wp) :: gmax maximum absolute value of a partial derivative. integer :: n dimension of the manifold defined by active constraints. integer :: iterq type of feasible point. Read more… procedure, private :: ops_after_constr_deletion private  subroutine ops_after_constr_deletion (me, nf, nc, ix, ia, iaa, ar, ic, s, n, iold, krem, ier) Date 91/12/01 operations after constraint deletion. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf declared number of variables. integer :: nc number of constraints. integer :: ix (*) ix(nf)  vector containing types of bounds. integer :: ia (*) ia(na)  vector containing types of deviations. integer :: iaa (*) iaa(nf+1)  vector containing indices of active\nfunctions. real(kind=wp) :: ar (*) ar((nf+1)*(nf+2)/2)  triangular decomposition\nof kernel of the orthogonal projection. integer :: ic (*) ic(nc)  vector containing types of constraints. real(kind=wp) :: s (*) s(nf+1)  auxiliary vector. integer :: n actual number of variables. integer :: iold index of the old active constraint. integer :: krem auxiliary variable. integer :: ier error indicator. procedure, private :: compute_con_and_dcon private  subroutine compute_con_and_dcon (me, nf, nc, x, fc, cf, cl, cu, ic, gc, cg, cmax, kd, ld) Date 97/12/01 computation of the value and the gradient of the constraint function. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf number of variables. integer :: nc number of constraints. real(kind=wp) :: x (nf) x(nf) vector of variables. real(kind=wp) :: fc value of the selected constraint function. real(kind=wp) :: cf (*) cf(nc) vector containing values of constraint functions. real(kind=wp) :: cl (*) cl(nc) vector containing lower bounds for constraint functions. real(kind=wp) :: cu (*) cu(nc) vector containing upper bounds for constraint functions. integer :: ic (*) ic(nc) vector containing types of constraints. real(kind=wp) :: gc (nf) gc(nf) gradient of the selected constraint function. real(kind=wp) :: cg (*) cg(nf*nc) matrix whose columns are gradients of constraint functions. real(kind=wp) :: cmax maximum constraint violation. integer :: kd degree of required derivatives. integer :: ld degree of previously computed derivatives. procedure, private :: extended_line_search private  subroutine extended_line_search (me, r, ro, rp, f, fo, fp, po, pp, fmin, fmax, rmin, rmax, tols, kd, ld, nit, kit, nred, mred, maxst, iest, inits, iters, kters, mes, isys) Date 97/12/01 extended line search without directional derivatives. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me real(kind=wp) :: r value of the stepsize parameter. real(kind=wp) :: ro initial value of the stepsize parameter. real(kind=wp) :: rp previous value of the stepsize parameter. real(kind=wp) :: f value of the objective function. real(kind=wp) :: fo initial value of the objective function. real(kind=wp) :: fp previous value of the objective function. real(kind=wp) :: po initial value of the directional derivative. real(kind=wp) :: pp previous value of the directional derivative. real(kind=wp) :: fmin lower bound for value of the objective function. real(kind=wp) :: fmax upper bound for value of the objective function. real(kind=wp) :: rmin minimum value of the stepsize parameter real(kind=wp) :: rmax maximum value of the stepsize parameter real(kind=wp) :: tols termination tolerance for line search\n(in test on the change of the function value). integer :: kd degree of required dervatives. integer :: ld degree of previously computed derivatives. integer :: nit actual number of iterations. integer :: kit number of the iteration after last restart. integer :: nred actual number of extrapolations or interpolations. integer :: mred maximum number of extrapolations or interpolations. integer :: maxst maximum stepsize indicator. maxst=0 or maxst=1\nif maximum stepsize was not or was reached. integer :: iest lower bound specification. iest=0 or iest=1\nif lower bound is not or is given. integer :: inits choice of the initial stepsize. Read more… integer :: iters termination indicator. Read more… integer :: kters termination selection. Read more… integer :: mes method selection. Read more… integer :: isys control parameter. Source Code type , public :: psqp_class !! The main PSQP class to use. private ! these were formerly in the `stat` common block: integer , public :: nres = 0 !! number of restarts. integer , public :: ndec = 0 !! number of matrix decomposition. integer , public :: nrem = 0 !! number of constraint deletions. integer , public :: nadd = 0 !! number of constraint additions. integer , public :: nit = 0 !! number of iterations. integer , public :: nfv = 0 !! number of function evaluations. integer , public :: nfg = 0 !! number of gradient evaluations. integer , public :: nfh = 0 !! number of hessian evaluations. ! formerly saved variables in extended_line_search: integer :: mtyp = 0 integer :: mode = 0 integer :: mes1 = 0 integer :: mes2 = 0 real ( wp ) :: rl = 0.0_wp real ( wp ) :: fl = 0.0_wp real ( wp ) :: ru = 0.0_wp real ( wp ) :: fu = 0.0_wp real ( wp ) :: ri = 0.0_wp real ( wp ) :: fi = 0.0_wp procedure ( obj_func ), pointer :: obj => null () !! objective function procedure ( dobj_func ), pointer :: dobj => null () !! gradient of the objective function procedure ( con_func ), pointer :: con => null () !! constraint function procedure ( dcon_func ), pointer :: dcon => null () !! gradient of the constraint function procedure ( report_f ), pointer :: report => null () !! iteration report function contains private procedure , public :: psqpn procedure , public :: psqp procedure :: compute_obj_and_dobj procedure :: dual_range_space_quad_prog procedure :: ops_after_constr_deletion procedure :: compute_con_and_dcon procedure :: extended_line_search end type psqp_class","tags":"","url":"type/psqp_class.html"},{"title":"obj_func – psqp","text":"interface private  subroutine obj_func(me, nf, x, ff) Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf the number of variables real(kind=wp) :: x (nf) a vector of variables real(kind=wp) :: ff the value of the objective function Description objective function interface","tags":"","url":"interface/obj_func.html"},{"title":"dobj_func – psqp","text":"interface private  subroutine dobj_func(me, nf, x, gf) Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf the number of variables real(kind=wp) :: x (nf) a vector of variables real(kind=wp) :: gf (nf) the gradient of the objective function Description gradient of the objective function interface","tags":"","url":"interface/dobj_func.html"},{"title":"con_func – psqp","text":"interface private  subroutine con_func(me, nf, kc, x, fc) Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf the number of variables integer :: kc the index of the constraint function real(kind=wp) :: x (nf) a vector of variables real(kind=wp) :: fc the value of the constraint function Description constraint function interface","tags":"","url":"interface/con_func.html"},{"title":"dcon_func – psqp","text":"interface private  subroutine dcon_func(me, nf, kc, x, gc) Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf the number of variables integer :: kc the index of the constraint function real(kind=wp) :: x (nf) a vector of variables and real(kind=wp) :: gc (nf) the gradient of the constraint function Description gradient of the constraint function interface","tags":"","url":"interface/dcon_func.html"},{"title":"report_f – psqp","text":"interface private  subroutine report_f(me, iter, x, j, f) Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer, intent(in) :: iter Iteration number real(kind=wp), intent(in), dimension(:) :: x optimization variables real(kind=wp), intent(in) :: j Objective function value real(kind=wp), intent(in), dimension(:) :: f Constraint functions Description Report function to call once per iteration to report the solution.","tags":"","url":"interface/report_f.html"},{"title":"psqpn – psqp","text":"private  subroutine psqpn(me, nf, nb, nc, x, bound_type, xl, xu, cf, constraint_type, cl, cu, ipar, rpar, f, gmax, cmax, iprnt, iterm, obj, dobj, con, dcon, report) easy to use subroutine for general nonlinear programming problems. Type Bound psqp_class Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer, intent(in) :: nf number of variables integer, intent(in) :: nb choice of simple bounds. nb=0 -- simple bounds suppressed. nb>0 -- simple bounds accepted. integer, intent(in) :: nc number of general nonlinear constraints. real(kind=wp), intent(inout), dimension(nf) :: x x(nf) vector of variables. integer, intent(in), dimension(nf) :: bound_type ix(nf) vector containing types of bounds. ix(i) = 0 -- variable x(i) is unbounded. ix(i) = 1 -- lower bound xl(i) <= x(i). ix(i) = 2 -- upper bound x(i) <= xu(i). ix(i) = 3 -- two side bound xl(i) <= x(i) <= xu(i). ix(i) = 5 -- variable x(i) is fixed. real(kind=wp), intent(in), dimension(nf) :: xl xl(nf) vector containing lower bounds for variables. real(kind=wp), intent(in), dimension(nf) :: xu xu(nf) vector containing upper bounds for variables. real(kind=wp), intent(out), dimension(nc+1) :: cf cf(nc+1) vector containing values of the constraint functions. integer, intent(in), dimension(nc) :: constraint_type ic(nc) vector containing types of constraints: ic(kc) = 0 -- constraint cf(kc) is not used. ic(kc) = 1 -- lower constraint cl(kc) <= cf(kc). ic(kc) = 2 -- upper constraint cf(kc) <= cu(kc). ic(kc) = 3 -- two side constraint cl(kc) <= cf(kc) <= cu(kc). ic(kc) = 5 -- equality constraint cf(kc) == cl(kc). real(kind=wp), intent(in), dimension(nc) :: cl cl(nc) vector containing lower bounds for constraint functions. real(kind=wp), intent(in), dimension(nc) :: cu cu(nc) vector containing upper bounds for constraint functions. integer, intent(in), dimension(6) :: ipar integer paremeters: ipar(1) maximum number of iterations. ipar(2) maximum number of function evaluations. ipar(3) this parameter is not used in the subroutine psqp. ipar(4) this parameter is not used in the subroutine psqp. ipar(5) variable metric update used. ipar(5)=1 - the bfgs update. ipar(5)=2 - the hoshino update. ipar(6) correction of the variable metric update if a negative\n  curvature occurs. ipar(6)=1 - no correction. ipar(6)=2 - powell's correction. real(kind=wp), intent(in), dimension(5) :: rpar real parameters: rpar(1) -- maximum stepsize. rpar(2) -- tolerance for change of variables. rpar(3) -- tolerance for constraint violations. rpar(4) -- tolerance for the gradient of the lagrangian function. rpar(5) -- penalty coefficient. real(kind=wp), intent(out) :: f value of the objective function. real(kind=wp), intent(out) :: gmax maximum partial derivative of the lagrangian function. real(kind=wp), intent(out) :: cmax maximum constraint violation. integer, intent(in) :: iprnt print specification: iprnt=0 -- no print. abs(iprnt)=1 -- print of final results. abs(iprnt)=2 -- print of final results and iterations. iprnt>0 -- basic final results. iprnt<0 -- extended final results. integer, intent(out) :: iterm variable that indicates the cause of termination. iterm=1 -- if abs(x-xo) was less than or equal to tolx in mtesx (usually two) subsequent iterations. iterm=2 -- if abs(f-fo) was less than or equal to tolf in mtesf (usually two) subsequent iterations. iterm=3 -- if f is less than or equal to tolb. iterm=4 -- if gmax is less than or equal to tolg. iterm=11 -- if nit exceeded mit. iterm=12 - if nfv exceeded mfv. iterm=13 -- if nfg exceeded mfg. iterm<0 - if the method failed. iterm=-6 -- then the termination criterion has not been satisfied, but the point obtained if usually acceptable. procedure( obj_func ) :: obj computation of the value of the objective function procedure( dobj_func ) :: dobj computation of the gradient of the objective function procedure( con_func ) :: con computation of the value of the constraint function procedure( dcon_func ) :: dcon computation of the gradient of the constraint function procedure( report_f ), optional :: report iteration report function. Note: this is independent of iprnt . \nIf this function is associated, each iteration will be reported Calls proc~~psqpn~~CallsGraph proc~psqpn psqp_class%psqpn proc~psqp psqp_class%psqp proc~psqpn->proc~psqp proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~psqp->proc~bfgs_variable_metric_update proc~compute_augmented_lagrangian compute_augmented_lagrangian proc~psqp->proc~compute_augmented_lagrangian proc~compute_con_and_dcon psqp_class%compute_con_and_dcon proc~psqp->proc~compute_con_and_dcon proc~compute_new_penalty_parameters compute_new_penalty_parameters proc~psqp->proc~compute_new_penalty_parameters proc~compute_obj_and_dobj psqp_class%compute_obj_and_dobj proc~psqp->proc~compute_obj_and_dobj proc~dual_range_space_qp dual_range_space_qp proc~psqp->proc~dual_range_space_qp proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~psqp->proc~dual_range_space_quad_prog proc~extended_line_search psqp_class%extended_line_search proc~psqp->proc~extended_line_search proc~mxdsmi mxdsmi proc~psqp->proc~mxdsmi proc~mxvcop mxvcop proc~psqp->proc~mxvcop proc~mxvdir mxvdir proc~psqp->proc~mxvdir proc~mxvdot mxvdot proc~psqp->proc~mxvdot proc~mxvina mxvina proc~psqp->proc~mxvina proc~mxvmax mxvmax proc~psqp->proc~mxvmax proc~mxvset mxvset proc~psqp->proc~mxvset proc~test_simple_bound test_simple_bound proc~psqp->proc~test_simple_bound proc~transform_incompatible_qp_subproblem transform_incompatible_qp_subproblem proc~psqp->proc~transform_incompatible_qp_subproblem proc~bfgs_variable_metric_update->proc~mxvcop proc~bfgs_variable_metric_update->proc~mxvdir proc~bfgs_variable_metric_update->proc~mxvdot proc~mxdpgb mxdpgb proc~bfgs_variable_metric_update->proc~mxdpgb proc~mxdpgp mxdpgp proc~bfgs_variable_metric_update->proc~mxdpgp proc~mxdpgs mxdpgs proc~bfgs_variable_metric_update->proc~mxdpgs proc~mxdpgu mxdpgu proc~bfgs_variable_metric_update->proc~mxdpgu proc~mxvdif mxvdif proc~bfgs_variable_metric_update->proc~mxvdif proc~mxvscl mxvscl proc~bfgs_variable_metric_update->proc~mxvscl proc~compute_con_and_dcon->proc~mxvcop proc~mxvneg mxvneg proc~compute_obj_and_dobj->proc~mxvneg proc~dual_range_space_qp->proc~mxvdir proc~dual_range_space_qp->proc~mxvdif proc~mxvsav mxvsav proc~dual_range_space_qp->proc~mxvsav proc~dual_range_space_quad_prog->proc~mxvcop proc~dual_range_space_quad_prog->proc~mxvdir proc~dual_range_space_quad_prog->proc~mxvina proc~determine_new_active_linear_constr determine_new_active_linear_constr proc~dual_range_space_quad_prog->proc~determine_new_active_linear_constr proc~determine_new_active_simple_bound determine_new_active_simple_bound proc~dual_range_space_quad_prog->proc~determine_new_active_simple_bound proc~dual_range_space_quad_prog->proc~mxdpgb proc~mxdpgf mxdpgf proc~dual_range_space_quad_prog->proc~mxdpgf proc~mxdprb mxdprb proc~dual_range_space_quad_prog->proc~mxdprb proc~mxdsmm mxdsmm proc~dual_range_space_quad_prog->proc~mxdsmm proc~mxvinv mxvinv proc~dual_range_space_quad_prog->proc~mxvinv proc~dual_range_space_quad_prog->proc~mxvneg proc~ops_after_constr_deletion psqp_class%ops_after_constr_deletion proc~dual_range_space_quad_prog->proc~ops_after_constr_deletion proc~update_tri_decomp_general update_tri_decomp_general proc~dual_range_space_quad_prog->proc~update_tri_decomp_general proc~line_search_interpolation line_search_interpolation proc~extended_line_search->proc~line_search_interpolation proc~determine_new_active_linear_constr->proc~mxvdot proc~mxdpgu->proc~mxvscl proc~update_tri_decomp_orthogonal update_tri_decomp_orthogonal proc~ops_after_constr_deletion->proc~update_tri_decomp_orthogonal proc~update_tri_decomp_general->proc~mxvcop proc~update_tri_decomp_general->proc~mxvdot proc~update_tri_decomp_general->proc~mxvset proc~update_tri_decomp_general->proc~mxdpgb proc~update_tri_decomp_general->proc~mxdprb proc~update_tri_decomp_general->proc~mxdsmm proc~mxdsmv mxdsmv proc~update_tri_decomp_general->proc~mxdsmv proc~update_tri_decomp_orthogonal->proc~mxvcop proc~update_tri_decomp_orthogonal->proc~mxvset proc~mxvort mxvort proc~update_tri_decomp_orthogonal->proc~mxvort proc~mxvrot mxvrot proc~update_tri_decomp_orthogonal->proc~mxvrot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine psqpn ( me , nf , nb , nc , x , bound_type , xl , xu , cf , constraint_type , & cl , cu , ipar , rpar , f , gmax , & cmax , iprnt , iterm , obj , dobj , con , dcon , report ) class ( psqp_class ), intent ( inout ) :: me integer , intent ( in ) :: nf !! number of variables integer , intent ( in ) :: nb !! choice of simple bounds. !! !! * `nb=0` -- simple bounds suppressed. !! * `nb>0` -- simple bounds accepted. integer , intent ( in ) :: nc !! number of general nonlinear constraints. real ( wp ), dimension ( nf ), intent ( inout ) :: x !! x(nf) vector of variables. integer , dimension ( nf ), intent ( in ) :: bound_type !! ix(nf) vector containing types of bounds. !! !! * `ix(i) = 0` -- variable x(i) is unbounded. !! * `ix(i) = 1` -- lower bound xl(i) <= x(i). !! * `ix(i) = 2` -- upper bound x(i) <= xu(i). !! * `ix(i) = 3` -- two side bound xl(i) <= x(i) <= xu(i). !! * `ix(i) = 5` -- variable x(i) is fixed. real ( wp ), dimension ( nf ), intent ( in ) :: xl !! xl(nf) vector containing lower bounds for variables. real ( wp ), dimension ( nf ), intent ( in ) :: xu !! xu(nf) vector containing upper bounds for variables. real ( wp ), dimension ( nc + 1 ), intent ( out ) :: cf !! cf(nc+1) vector containing values of the constraint functions. integer , dimension ( nc ), intent ( in ) :: constraint_type !! ic(nc) vector containing types of constraints: !! !! * `ic(kc) = 0` -- constraint cf(kc) is not used. !! * `ic(kc) = 1` -- lower constraint cl(kc) <= cf(kc). !! * `ic(kc) = 2` -- upper constraint cf(kc) <= cu(kc). !! * `ic(kc) = 3` -- two side constraint cl(kc) <= cf(kc) <= cu(kc). !! * `ic(kc) = 5` -- equality constraint cf(kc) == cl(kc). real ( wp ), dimension ( nc ), intent ( in ) :: cl !! cl(nc) vector containing lower bounds for constraint functions. real ( wp ), dimension ( nc ), intent ( in ) :: cu !! cu(nc) vector containing upper bounds for constraint functions. integer , dimension ( 6 ), intent ( in ) :: ipar !! integer paremeters: !! !! * `ipar(1)`  maximum number of iterations. !! * `ipar(2)`  maximum number of function evaluations. !! * `ipar(3)`  this parameter is not used in the subroutine psqp. !! * `ipar(4)`  this parameter is not used in the subroutine psqp. !! * `ipar(5)`  variable metric update used. !!   `ipar(5)=1` - the bfgs update. !!   `ipar(5)=2` - the hoshino update. !! * `ipar(6)`  correction of the variable metric update if a negative !!   curvature occurs. !!   `ipar(6)=1` - no correction. !!   `ipar(6)=2` - powell's correction. real ( wp ), dimension ( 5 ), intent ( in ) :: rpar !! real parameters: !! !! * `rpar(1)` -- maximum stepsize. !! * `rpar(2)` -- tolerance for change of variables. !! * `rpar(3)` -- tolerance for constraint violations. !! * `rpar(4)` -- tolerance for the gradient of the lagrangian function. !! * `rpar(5)` -- penalty coefficient. real ( wp ), intent ( out ) :: f !! value of the objective function. real ( wp ), intent ( out ) :: gmax !! maximum partial derivative of the lagrangian function. real ( wp ), intent ( out ) :: cmax !! maximum constraint violation. integer , intent ( in ) :: iprnt !! print specification: !! !! * `iprnt=0`      -- no print. !! * `abs(iprnt)=1` -- print of final results. !! * `abs(iprnt)=2` -- print of final results and iterations. !! * `iprnt>0`      -- basic final results. !! * `iprnt<0`      -- extended final results. integer , intent ( out ) :: iterm !! variable that indicates the cause of termination. !! !! * `iterm=1`  -- if abs(x-xo) was less than or equal to tolx in mtesx (usually two) subsequent iterations. !! * `iterm=2`  -- if abs(f-fo) was less than or equal to tolf in mtesf (usually two) subsequent iterations. !! * `iterm=3`  -- if f is less than or equal to tolb. !! * `iterm=4`  -- if gmax is less than or equal to tolg. !! * `iterm=11` -- if nit exceeded mit. iterm=12 - if nfv exceeded mfv. !! * `iterm=13` -- if nfg exceeded mfg. iterm<0 - if the method failed. !! * `iterm=-6` -- then the termination criterion has not been satisfied, but the point obtained if usually acceptable. procedure ( obj_func ) :: obj !! computation of the value of the objective function procedure ( dobj_func ) :: dobj !! computation of the gradient of the objective function procedure ( con_func ) :: con !! computation of the value of the constraint function procedure ( dcon_func ) :: dcon !! computation of the gradient of the constraint function procedure ( report_f ), optional :: report !! iteration report function. Note: this is independent of `iprnt`. !! If this function is associated, each iteration will be reported integer :: lcfd , lcfo , lcg , lcp , lcr , lcz , lg , lgc , lgf , lgo , lh , lia , ls , lxo integer , dimension (:), allocatable :: ia real ( wp ), dimension (:), allocatable :: ra integer , dimension (:), allocatable :: ic !! local copy of `constraint_type` since it is modified integer , dimension (:), allocatable :: ix !! local copy of `bound_type` since it is modified ! set the functions: me % obj => obj me % dobj => dobj me % con => con me % dcon => dcon if ( present ( report )) me % report => report allocate ( ia ( nf ), ra (( nf + nc + 8 ) * nf + 3 * nc + 1 )) allocate ( ic ( nc )) allocate ( ix ( nf )) ic = constraint_type ! make a copy of input ix = bound_type ! make a copy of input lcg = 1 lcfo = lcg + nf * nc lcfd = lcfo + nc + 1 lgc = lcfd + nc lcr = lgc + nf lcz = lcr + nf * ( nf + 1 ) / 2 lcp = lcz + nf lgf = lcp + nc lg = lgf + nf lh = lg + nf ls = lh + nf * ( nf + 1 ) / 2 lxo = ls + nf lgo = lxo + nf lia = 1 call me % psqp ( nf , nb , nc , x , ix , xl , xu , cf , ic , cl , cu , ra , ra ( lcfo ), ra ( lcfd ), & ra ( lgc ), ia , ra ( lcr ), ra ( lcz ), ra ( lcp ), ra ( lgf ), ra ( lg ), ra ( lh ), & ra ( ls ), ra ( lxo ), ra ( lgo ), rpar ( 1 ), rpar ( 2 ), rpar ( 3 ), rpar ( 4 ), & rpar ( 5 ), cmax , gmax , f , ipar ( 1 ), ipar ( 2 ), ipar ( 5 ), ipar ( 6 ), & iprnt , iterm ) deallocate ( ia , ra , ic , ix ) end subroutine psqpn","tags":"","url":"proc/psqpn.html"},{"title":"psqp – psqp","text":"private  subroutine psqp(me, nf, nb, nc, x, ix, xl, xu, cf, ic, cl, cu, cg, cfo, cfd, gc, ica, cr, cz, cp, gf, g, h, s, xo, go, xmax, tolx, tolc, tolg, rpf, cmax, gmax, f, mit, mfv, met, mec, iprnt, iterm) recursive quadratic programming method with the bfgs variable metric\n  update for general nonlinear programming problems. Method recursive quadratic programming method with the bfgs variable metric\n  update. Type Bound psqp_class Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf number of variables. integer :: nb choice of simple bounds. nb=0 - simple bounds suppressed. nb>0 - simple bounds accepted. integer :: nc number of linear constraints. real(kind=wp) :: x (*) x(nf)  vector of variables. integer, intent(inout) :: ix (*) ix(nf)  vector containing types of bounds. ix(i)=0 - variable x(i) is unbounded. ix(i)=1 - lover bound xl(i)<=x(i). ix(i)=2 - upper bound x(i)<=xu(i). ix(i)=3 - two side bound xl(i)<=x(i)<=xu(i). ix(i)=5 - variable x(i) is fixed. real(kind=wp) :: xl (*) xl(nf)  vector containing lower bounds for variables. real(kind=wp) :: xu (*) xu(nf)  vector containing upper bounds for variables. real(kind=wp) :: cf (*) cf(nc+1)  vector containing values of the constraint functions. integer, intent(inout) :: ic (*) ic(nc)  vector containing types of constraints. ic(kc)=0 - constraint cf(kc) is not used. ic(kc)=1 - lower constraint cl(kc)<=cf(kc). ic(kc)=2 - upper constraint cf(kc)<=cu(kc). ic(kc)=3 - two side constraint cl(kc)<=cf(kc)<=cu(kc). ic(kc)=5 - equality constraint cf(kc)==cl(kc). real(kind=wp) :: cl (*) cl(nc)  vector containing lower bounds for constraint functions. real(kind=wp) :: cu (*) cu(nc)  vector containing upper bounds for constraint functions. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals of the linear constraints. real(kind=wp) :: cfo (*) cfo(nc)  vector containing saved values of the constraint functions. real(kind=wp) :: cfd (*) cfd(nc)  vector containing increments of the constraint functions. real(kind=wp) :: gc (*) gc(nf)  gradient of the selected constraint function. integer :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cr (*) cr(nf*(nf+1)/2)  triangular decomposition of kernel\nof the orthogonal projection. real(kind=wp) :: cz (*) cz(nf)  vector of lagrange multipliers. real(kind=wp) :: cp (*) real(kind=wp) :: gf (*) gf(nf)  gradient of the model function. real(kind=wp) :: g (*) g(nf)  gradient of the objective function. real(kind=wp) :: h (*) h(nf*(nf+1)/2)  triangular decomposition or inversion of\nthe hessian matrix approximation. real(kind=wp) :: s (*) s(nf)  direction vector. real(kind=wp) :: xo (*) xo(nf)  vectors of variables difference. real(kind=wp) :: go (*) go(nf)  gradients difference. real(kind=wp) :: xmax maximum stepsize. real(kind=wp) :: tolx tolerance for change of variables. real(kind=wp) :: tolc tolerance for constraint violations. real(kind=wp) :: tolg tolerance for the gradient of the lagrangian function. real(kind=wp) :: rpf penalty coefficient. real(kind=wp) :: cmax maximum constraint violation. real(kind=wp) :: gmax maximum partial derivative of the lagrangian function. real(kind=wp) :: f value of the objective function. integer :: mit maximum number of iterations. integer :: mfv maximum number of function evaluations. integer :: met variable metric update used. met=1 - the bfgs update. met=2 - the hoshino update. integer :: mec correction if the negative curvature occurs. mec=1 - correction suppressed. mec=2 - powell's correction. integer :: iprnt print specification. iprnt=0      - no print. abs(iprnt)=1 - print of final results. abs(iprnt)=2 - print of final results and iterations. iprnt>0      - basic final results. iprnt<0      - extended final results. integer :: iterm variable that indicates the cause of termination. iterm=1-if abs(x-xo) was less than or equal to tolx in\n  mtesx (usually two) subsequent iterations. iterm=2-if abs(f-fo) was less than or equal to tolf in\n  mtesf (usually two) subsequent iterations. iterm=3-if f is less than or equal to tolb. iterm=4-if gmax is less than or equal to tolg. iterm=11-if nit exceeded mit. iterm=12-if nfv exceeded mfv. iterm=13-if nfg exceeded mfg. iterm<0-if the method failed. if iterm=-6, then the termination criterion has not been\n  satisfied, but the point obtained if usually acceptable. Calls proc~~psqp~~CallsGraph proc~psqp psqp_class%psqp proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~psqp->proc~bfgs_variable_metric_update proc~compute_augmented_lagrangian compute_augmented_lagrangian proc~psqp->proc~compute_augmented_lagrangian proc~compute_con_and_dcon psqp_class%compute_con_and_dcon proc~psqp->proc~compute_con_and_dcon proc~compute_new_penalty_parameters compute_new_penalty_parameters proc~psqp->proc~compute_new_penalty_parameters proc~compute_obj_and_dobj psqp_class%compute_obj_and_dobj proc~psqp->proc~compute_obj_and_dobj proc~dual_range_space_qp dual_range_space_qp proc~psqp->proc~dual_range_space_qp proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~psqp->proc~dual_range_space_quad_prog proc~extended_line_search psqp_class%extended_line_search proc~psqp->proc~extended_line_search proc~mxdsmi mxdsmi proc~psqp->proc~mxdsmi proc~mxvcop mxvcop proc~psqp->proc~mxvcop proc~mxvdir mxvdir proc~psqp->proc~mxvdir proc~mxvdot mxvdot proc~psqp->proc~mxvdot proc~mxvina mxvina proc~psqp->proc~mxvina proc~mxvmax mxvmax proc~psqp->proc~mxvmax proc~mxvset mxvset proc~psqp->proc~mxvset proc~test_simple_bound test_simple_bound proc~psqp->proc~test_simple_bound proc~transform_incompatible_qp_subproblem transform_incompatible_qp_subproblem proc~psqp->proc~transform_incompatible_qp_subproblem proc~bfgs_variable_metric_update->proc~mxvcop proc~bfgs_variable_metric_update->proc~mxvdir proc~bfgs_variable_metric_update->proc~mxvdot proc~mxdpgb mxdpgb proc~bfgs_variable_metric_update->proc~mxdpgb proc~mxdpgp mxdpgp proc~bfgs_variable_metric_update->proc~mxdpgp proc~mxdpgs mxdpgs proc~bfgs_variable_metric_update->proc~mxdpgs proc~mxdpgu mxdpgu proc~bfgs_variable_metric_update->proc~mxdpgu proc~mxvdif mxvdif proc~bfgs_variable_metric_update->proc~mxvdif proc~mxvscl mxvscl proc~bfgs_variable_metric_update->proc~mxvscl proc~compute_con_and_dcon->proc~mxvcop proc~mxvneg mxvneg proc~compute_obj_and_dobj->proc~mxvneg proc~dual_range_space_qp->proc~mxvdir proc~dual_range_space_qp->proc~mxvdif proc~mxvsav mxvsav proc~dual_range_space_qp->proc~mxvsav proc~dual_range_space_quad_prog->proc~mxvcop proc~dual_range_space_quad_prog->proc~mxvdir proc~dual_range_space_quad_prog->proc~mxvina proc~determine_new_active_linear_constr determine_new_active_linear_constr proc~dual_range_space_quad_prog->proc~determine_new_active_linear_constr proc~determine_new_active_simple_bound determine_new_active_simple_bound proc~dual_range_space_quad_prog->proc~determine_new_active_simple_bound proc~dual_range_space_quad_prog->proc~mxdpgb proc~mxdpgf mxdpgf proc~dual_range_space_quad_prog->proc~mxdpgf proc~mxdprb mxdprb proc~dual_range_space_quad_prog->proc~mxdprb proc~mxdsmm mxdsmm proc~dual_range_space_quad_prog->proc~mxdsmm proc~mxvinv mxvinv proc~dual_range_space_quad_prog->proc~mxvinv proc~dual_range_space_quad_prog->proc~mxvneg proc~ops_after_constr_deletion psqp_class%ops_after_constr_deletion proc~dual_range_space_quad_prog->proc~ops_after_constr_deletion proc~update_tri_decomp_general update_tri_decomp_general proc~dual_range_space_quad_prog->proc~update_tri_decomp_general proc~line_search_interpolation line_search_interpolation proc~extended_line_search->proc~line_search_interpolation proc~determine_new_active_linear_constr->proc~mxvdot proc~mxdpgu->proc~mxvscl proc~update_tri_decomp_orthogonal update_tri_decomp_orthogonal proc~ops_after_constr_deletion->proc~update_tri_decomp_orthogonal proc~update_tri_decomp_general->proc~mxvcop proc~update_tri_decomp_general->proc~mxvdot proc~update_tri_decomp_general->proc~mxvset proc~update_tri_decomp_general->proc~mxdpgb proc~update_tri_decomp_general->proc~mxdprb proc~update_tri_decomp_general->proc~mxdsmm proc~mxdsmv mxdsmv proc~update_tri_decomp_general->proc~mxdsmv proc~update_tri_decomp_orthogonal->proc~mxvcop proc~update_tri_decomp_orthogonal->proc~mxvset proc~mxvort mxvort proc~update_tri_decomp_orthogonal->proc~mxvort proc~mxvrot mxvrot proc~update_tri_decomp_orthogonal->proc~mxvrot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~psqp~~CalledByGraph proc~psqp psqp_class%psqp proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine psqp ( me , nf , nb , nc , x , ix , xl , xu , cf , ic , cl , cu , cg , cfo , cfd , gc , ica , & cr , cz , cp , gf , g , h , s , xo , go , xmax , tolx , tolc , tolg , rpf , & cmax , gmax , f , mit , mfv , met , mec , iprnt , iterm ) class ( psqp_class ), intent ( inout ) :: me real ( wp ) :: f !! value of the objective function. real ( wp ) :: cmax !! maximum constraint violation. real ( wp ) :: gmax !! maximum partial derivative of the lagrangian function. real ( wp ) :: rpf !! penalty coefficient. real ( wp ) :: tolx !! tolerance for change of variables. real ( wp ) :: tolc !! tolerance for constraint violations. real ( wp ) :: tolg !! tolerance for the gradient of the lagrangian function. real ( wp ) :: told !! real ( wp ) :: tols !! real ( wp ) :: xmax !! maximum stepsize. integer :: iprnt !! print specification. !! !! * iprnt=0      - no print. !! * abs(iprnt)=1 - print of final results. !! * abs(iprnt)=2 - print of final results and iterations. !! * iprnt>0      - basic final results. !! * iprnt<0      - extended final results. integer :: iterm !! variable that indicates the cause of termination. !! !! * iterm=1-if abs(x-xo) was less than or equal to tolx in !!   mtesx (usually two) subsequent iterations. !! * iterm=2-if abs(f-fo) was less than or equal to tolf in !!   mtesf (usually two) subsequent iterations. !! * iterm=3-if f is less than or equal to tolb. !! * iterm=4-if gmax is less than or equal to tolg. !! * iterm=11-if nit exceeded mit. !! * iterm=12-if nfv exceeded mfv. !! * iterm=13-if nfg exceeded mfg. !! * iterm<0-if the method failed. !! * if iterm=-6, then the termination criterion has not been !!   satisfied, but the point obtained if usually acceptable. integer :: met !! variable metric update used. !! !! * met=1 - the bfgs update. !! * met=2 - the hoshino update. integer :: met1 !! integer :: mec !! correction if the negative curvature occurs. !! !! * mec=1 - correction suppressed. !! * mec=2 - powell's correction. integer :: mes !! integer :: mfv !! maximum number of function evaluations. integer :: mit !! maximum number of iterations. integer :: nb !! choice of simple bounds. !! !! * nb=0 - simple bounds suppressed. !! * nb>0 - simple bounds accepted. integer :: nc !! number of linear constraints. integer :: nf !! number of variables. real ( wp ) :: cf ( * ) !! cf(nc+1)  vector containing values of the constraint functions. real ( wp ) :: cg ( * ) !! cg(nf*nc)  matrix whose columns are normals of the linear constraints. real ( wp ) :: cfo ( * ) !! cfo(nc)  vector containing saved values of the constraint functions. real ( wp ) :: cfd ( * ) !! cfd(nc)  vector containing increments of the constraint functions. real ( wp ) :: cl ( * ) !! cl(nc)  vector containing lower bounds for constraint functions. real ( wp ) :: cu ( * ) !! cu(nc)  vector containing upper bounds for constraint functions. real ( wp ) :: cp ( * ) !! real ( wp ) :: cr ( * ) !! cr(nf*(nf+1)/2)  triangular decomposition of kernel !! of the orthogonal projection. real ( wp ) :: cz ( * ) !! cz(nf)  vector of lagrange multipliers. real ( wp ) :: g ( * ) !! g(nf)  gradient of the objective function. real ( wp ) :: gc ( * ) !! gc(nf)  gradient of the selected constraint function. real ( wp ) :: gf ( * ) !! gf(nf)  gradient of the model function. real ( wp ) :: go ( * ) !! go(nf)  gradients difference. real ( wp ) :: h ( * ) !! h(nf*(nf+1)/2)  triangular decomposition or inversion of !! the hessian matrix approximation. real ( wp ) :: s ( * ) !! s(nf)  direction vector. real ( wp ) :: x ( * ) !! x(nf)  vector of variables. real ( wp ) :: xl ( * ) !! xl(nf)  vector containing lower bounds for variables. real ( wp ) :: xu ( * ) !! xu(nf)  vector containing upper bounds for variables. real ( wp ) :: xo ( * ) !! xo(nf)  vectors of variables difference. integer , intent ( inout ) :: ic ( * ) !! ic(nc)  vector containing types of constraints. !! !! * ic(kc)=0 - constraint cf(kc) is not used. !! * ic(kc)=1 - lower constraint cl(kc)<=cf(kc). !! * ic(kc)=2 - upper constraint cf(kc)<=cu(kc). !! * ic(kc)=3 - two side constraint cl(kc)<=cf(kc)<=cu(kc). !! * ic(kc)=5 - equality constraint cf(kc)==cl(kc). integer :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. integer , intent ( inout ) :: ix ( * ) !! ix(nf)  vector containing types of bounds. !! !! * ix(i)=0 - variable x(i) is unbounded. !! * ix(i)=1 - lover bound xl(i)<=x(i). !! * ix(i)=2 - upper bound x(i)<=xu(i). !! * ix(i)=3 - two side bound xl(i)<=x(i)<=xu(i). !! * ix(i)=5 - variable x(i) is fixed. real ( wp ) :: alf1 , alf2 , cmaxo , dmax , eps7 , eps9 , eta0 , & eta2 , eta9 , fmax , fmin , fo , gnorm , p , po , & r , rmax , rmin , ro , snorm , tolb , tolf , & umax , rp , fp , pp , ff , fc integer :: i , idecf , iext , irest , iterd , iterh , iterq , & iters , kbc , kbf , kc , kd , kit , ld , mred , mtesf , & mtesx , n , k , ntesx , iest , inits , kters , maxst , & isys , mfp , nred , ipom , lds if ( abs ( iprnt ) > 1 ) write ( 6 , '(1x,\"entry to psqp :\")' ) ! initiation kbf = 0 kbc = 0 if ( nb > 0 ) kbf = 2 if ( nc > 0 ) kbc = 2 me % nres = 0 me % ndec = 0 me % nrem = 0 me % nadd = 0 me % nit = 0 me % nfv = 0 me % nfg = 0 me % nfh = 0 isys = 0 iest = 0 iext = 0 mtesx = 2 mtesf = 2 inits = 1 iterm = 0 iters = 0 iterd = 0 iterq = 0 mred = 20 irest = 1 iters = 2 kters = 5 idecf = 1 eta0 = 1.0e-15_wp eta2 = 1.0e-15_wp eta9 = huge ( 1.0_wp ) !1.0e60_wp eps7 = 1.0e-15_wp eps9 = 1.0e-8_wp alf1 = 1.0e-10_wp alf2 = 1.0e10_wp fmax = huge ( 1.0_wp ) !1.0e60_wp fmin = - fmax tolb = - fmax dmax = eta9 tolf = 1.0e-16_wp if ( xmax <= 0.0_wp ) xmax = 1.0e+16_wp if ( tolx <= 0.0_wp ) tolx = 1.0e-16_wp if ( tolg <= 0.0_wp ) tolg = 1.0e-6_wp if ( tolc <= 0.0_wp ) tolc = 1.0e-6_wp told = 1.0e-8_wp tols = 1.0e-4_wp if ( rpf <= 0.0_wp ) rpf = 1.0e-4_wp if ( met <= 0 ) met = 1 met1 = 2 if ( mec <= 0 ) mec = 2 mes = 1 if ( mit <= 0 ) mit = 1000 if ( mfv <= 0 ) mfv = 2000 kd = 1 ld = - 1 kit = 0 call mxvset ( nc , 0.0_wp , cp ) ! initial operations with simple bounds if ( kbf > 0 ) then do i = 1 , nf if (( ix ( i ) == 3 . or . ix ( i ) == 4 ) . and . xu ( i ) <= xl ( i )) then xu ( i ) = xl ( i ) ix ( i ) = 5 elseif ( ix ( i ) == 5 . or . ix ( i ) == 6 ) then xl ( i ) = x ( i ) xu ( i ) = x ( i ) ix ( i ) = 5 end if if ( ix ( i ) == 1 . or . ix ( i ) == 3 ) x ( i ) = max ( x ( i ), xl ( i )) if ( ix ( i ) == 2 . or . ix ( i ) == 3 ) x ( i ) = min ( x ( i ), xu ( i )) end do end if ! initial operations with general constraints if ( kbc > 0 ) then k = 0 do kc = 1 , nc if (( ic ( kc ) == 3 . or . ic ( kc ) == 4 ) . and . cu ( kc ) <= cl ( kc )) then cu ( kc ) = cl ( kc ) ic ( kc ) = 5 elseif ( ic ( kc ) == 5 . or . ic ( kc ) == 6 ) then cu ( kc ) = cl ( kc ) ic ( kc ) = 5 end if k = k + nf end do end if if ( kbf > 0 ) then do i = 1 , nf if ( ix ( i ) >= 5 ) ix ( i ) = - ix ( i ) if ( ix ( i ) <= 0 ) then elseif (( ix ( i ) == 1 . or . ix ( i ) == 3 ) . and . x ( i ) <= xl ( i )) then x ( i ) = xl ( i ) elseif (( ix ( i ) == 2 . or . ix ( i ) == 3 ) . and . x ( i ) >= xu ( i )) then x ( i ) = xu ( i ) end if call test_simple_bound ( x , ix , xl , xu , eps9 , i ) if ( ix ( i ) > 10 ) ix ( i ) = 10 - ix ( i ) end do end if fo = fmin gmax = eta9 dmax = eta9 main : do lds = ld call me % compute_obj_and_dobj ( nf , x , gf , gf , ff , f , kd , ld , iext ) ld = lds call me % compute_con_and_dcon ( nf , nc , x , fc , cf , cl , cu , ic , gc , cg , cmax , kd , ld ) cf ( nc + 1 ) = f ! JW : seems to start with iter 0, so add 1 to iterations for report output if ( associated ( me % report )) call me % report ( me % nit + 1 , x ( 1 : nf ), j = f , f = cf ( 1 : nc )) if ( abs ( iprnt ) > 1 ) & write ( 6 , '(1x,\"nit=\",i9,2x,\"nfv=\",i9,2x,\"nfg=\",i9,2x,\"f=\",g13.6,2x,\"c=\",e8.1,2x,\"g=\",e8.1)' ) & me % nit , me % nfv , me % nfg , f , cmax , gmax ! start of the iteration with tests for termination. if ( iterm < 0 ) exit main if ( iters /= 0 ) then if ( f <= tolb ) then iterm = 3 exit main end if if ( dmax <= tolx ) then iterm = 1 ntesx = ntesx + 1 if ( ntesx >= mtesx ) exit main else ntesx = 0 end if end if if ( me % nit >= mit ) then iterm = 11 exit main end if if ( me % nfv >= mfv ) then iterm = 12 exit main end if iterm = 0 me % nit = me % nit + 1 restart : do ! restart n = nf if ( irest > 0 ) then call mxdsmi ( n , h ) ld = min ( ld , 1 ) idecf = 1 if ( kit < me % nit ) then me % nres = me % nres + 1 kit = me % nit else iterm = - 10 if ( iters < 0 ) iterm = iters - 5 exit main end if end if ! direction determination using a quadratic programming procedure call mxvcop ( nc + 1 , cf , cfo ) mfp = 2 ipom = 0 dir_loop : do call me % dual_range_space_quad_prog ( nf , nc , x , ix , xl , xu , cf , cfd , ic , ica , & cl , cu , cg , cr , cz , g , gf , h , s , mfp , kbf , & kbc , idecf , eta2 , eta9 , eps7 , & eps9 , umax , gmax , n , iterq ) if ( iterq < 0 ) then if ( ipom < 10 ) then ipom = ipom + 1 call transform_incompatible_qp_subproblem ( nc , cf , ic , cl , cu , kbc ) cycle dir_loop end if iterd = iterq - 10 else ipom = 0 iterd = 1 gmax = mxvmax ( nf , g ) gnorm = sqrt ( mxvdot ( nf , g , g )) snorm = sqrt ( mxvdot ( nf , s , s )) end if exit dir_loop end do dir_loop if ( iterd < 0 ) iterm = iterd if ( iterm == 0 ) then call mxvcop ( nc + 1 , cfo , cf ) ! test for sufficient descent p = mxvdot ( nf , g , s ) irest = 1 if ( snorm <= 0.0_wp ) then elseif ( p + told * gnorm * snorm <= 0.0_wp ) then irest = 0 end if if ( irest /= 0 ) cycle restart nred = 0 rmin = alf1 * gnorm / snorm rmax = min ( alf2 * gnorm / snorm , xmax / snorm ) if ( gmax <= tolg . and . cmax <= tolc ) then iterm = 4 exit main end if call compute_new_penalty_parameters ( nf , n , nc , ica , cz , cp ) call mxvina ( nc , ic ) call compute_augmented_lagrangian ( nf , n , nc , cf , ic , ica , cl , cu , cz , rpf , fc , f ) ! preparation of line search ro = 0.0_wp fo = f po = p cmaxo = cmax call mxvcop ( nf , x , xo ) call mxvcop ( nf , g , go ) call mxvcop ( nf , gf , cr ) call mxvcop ( nc + 1 , cf , cfo ) line_search : do ! line search without directional derivatives call me % extended_line_search ( r , ro , rp , f , fo , fp , po , pp , fmin , fmax , & rmin , rmax , tols , kd , ld , me % nit , kit , nred , & mred , maxst , iest , inits , iters , kters , mes , isys ) if ( isys == 0 ) then kd = 1 ! decision after unsuccessful line search if ( iters <= 0 ) then r = 0.0_wp f = fo p = po call mxvcop ( nf , xo , x ) call mxvcop ( nf , cr , gf ) call mxvcop ( nc + 1 , cfo , cf ) irest = 1 ld = kd cycle restart end if ! computation of the value and the gradient of the objective ! function together with the values and the gradients of the ! approximated functions if ( kd > ld ) then lds = ld call me % compute_obj_and_dobj ( nf , x , gf , gf , ff , f , kd , ld , iext ) ld = lds call me % compute_con_and_dcon ( nf , nc , x , fc , cf , cl , cu , ic , gc , & cg , cmax , kd , ld ) end if ! preparation of variable metric update call mxvcop ( nf , gf , g ) call dual_range_space_qp ( nf , n , x , xo , ica , cg , cz , g , go , r , f , fo , p , po , & cmax , cmaxo , dmax , kd , ld , iters ) ! variable metric update call bfgs_variable_metric_update ( n , h , g , s , xo , go , r , po , me % nit , & kit , iterh , met , met1 , mec ) ! if (mer>0.and.iterh>0) irest=1 cycle main ! end of the iteration else ! go to (11174,11172) isys+1 call mxvdir ( nf , r , s , xo , x ) lds = ld call me % compute_obj_and_dobj ( nf , x , gf , g , ff , f , kd , ld , iext ) ld = lds call me % compute_con_and_dcon ( nf , nc , x , fc , cf , cl , cu , ic , gc , cg , cmax , kd , ld ) cf ( nc + 1 ) = f call compute_augmented_lagrangian ( nf , n , nc , cf , ic , ica , cl , cu , cz , rpf , fc , f ) end if end do line_search end if exit restart end do restart exit main end do main if ( iprnt > 1 . or . iprnt < 0 ) write ( 6 , '(1x,\"exit from psqp :\")' ) if ( iprnt /= 0 ) & write ( 6 , '(1x,\"nit=\",i4,2x,\"nfv=\",i4,2x,\"nfg=\",i4,2x,\"f=\",g13.6,2x,\"c=\",e8.1,2x,\"g=\",e8.1,2x,\"iterm=\",i3)' ) & me % nit , me % nfv , me % nfg , f , cmax , gmax , iterm if ( iprnt < 0 ) write ( 6 , '(1x,\"x=\",5(g14.7,1x):/(3x,5(g14.7,1x)))' ) ( x ( i ), i = 1 , nf ) end subroutine psqp","tags":"","url":"proc/psqp.html"},{"title":"compute_con_and_dcon – psqp","text":"private  subroutine compute_con_and_dcon(me, nf, nc, x, fc, cf, cl, cu, ic, gc, cg, cmax, kd, ld) computation of the value and the gradient of the constraint function. Note This routine was formerly called pc1f01 . Type Bound psqp_class Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf number of variables. integer :: nc number of constraints. real(kind=wp) :: x (nf) x(nf) vector of variables. real(kind=wp) :: fc value of the selected constraint function. real(kind=wp) :: cf (*) cf(nc) vector containing values of constraint functions. real(kind=wp) :: cl (*) cl(nc) vector containing lower bounds for constraint functions. real(kind=wp) :: cu (*) cu(nc) vector containing upper bounds for constraint functions. integer :: ic (*) ic(nc) vector containing types of constraints. real(kind=wp) :: gc (nf) gc(nf) gradient of the selected constraint function. real(kind=wp) :: cg (*) cg(nf*nc) matrix whose columns are gradients of constraint functions. real(kind=wp) :: cmax maximum constraint violation. integer :: kd degree of required derivatives. integer :: ld degree of previously computed derivatives. Calls proc~~compute_con_and_dcon~~CallsGraph proc~compute_con_and_dcon psqp_class%compute_con_and_dcon proc~mxvcop mxvcop proc~compute_con_and_dcon->proc~mxvcop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_con_and_dcon~~CalledByGraph proc~compute_con_and_dcon psqp_class%compute_con_and_dcon proc~psqp psqp_class%psqp proc~psqp->proc~compute_con_and_dcon proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_con_and_dcon ( me , nf , nc , x , fc , cf , cl , cu , ic , gc , cg , cmax , kd , ld ) class ( psqp_class ), intent ( inout ) :: me real ( wp ) :: fc !! value of the selected constraint function. real ( wp ) :: cmax !! maximum constraint violation. integer :: kd !! degree of required derivatives. integer :: ld !! degree of previously computed derivatives. integer :: nc !! number of constraints. integer :: nf !! number of variables. real ( wp ) :: cf ( * ) !! cf(nc) vector containing values of constraint functions. real ( wp ) :: cl ( * ) !! cl(nc) vector containing lower bounds for constraint functions. real ( wp ) :: cu ( * ) !! cu(nc) vector containing upper bounds for constraint functions. integer :: ic ( * ) !! ic(nc) vector containing types of constraints. real ( wp ) :: gc ( nf ) !! gc(nf) gradient of the selected constraint function. real ( wp ) :: cg ( * ) !! cg(nf*nc) matrix whose columns are gradients of constraint functions. real ( wp ) :: x ( nf ) !! x(nf) vector of variables. real ( wp ) :: pom , temp integer :: kc if ( kd <= ld ) return if ( ld < 0 ) cmax = 0.0_wp do kc = 1 , nc if ( kd >= 0 ) then if ( ld < 0 ) then call me % con ( nf , kc , x , fc ) cf ( kc ) = fc if ( ic ( kc ) > 0 ) then pom = 0.0_wp temp = cf ( kc ) if ( ic ( kc ) == 1 . or . ic ( kc ) >= 3 ) pom = min ( pom , temp - cl ( kc )) if ( ic ( kc ) == 2 . or . ic ( kc ) >= 3 ) pom = min ( pom , cu ( kc ) - temp ) if ( pom < 0.0_wp ) cmax = max ( cmax , - pom ) end if else fc = cf ( kc ) end if if ( kd >= 1 ) then if ( ld >= 1 ) then call mxvcop ( nf , cg (( kc - 1 ) * nf + 1 ), gc ) else call me % dcon ( nf , kc , x , gc ) call mxvcop ( nf , gc , cg (( kc - 1 ) * nf + 1 )) end if end if end if end do ld = kd end subroutine compute_con_and_dcon","tags":"","url":"proc/compute_con_and_dcon.html"},{"title":"compute_obj_and_dobj – psqp","text":"private  subroutine compute_obj_and_dobj(me, nf, x, gf, g, ff, f, kd, ld, iext) computation of the value and the gradient of the objective function. Note This routine was formerly called pf1f01 . Type Bound psqp_class Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer, intent(in) :: nf number of variables. real(kind=wp), intent(in) :: x (nf) x(nf)   vector of variables. real(kind=wp), intent(out) :: gf (nf) gf(nf)  gradient of the model function. real(kind=wp), intent(out) :: g (nf) g(nf)   gradient of the objective function. real(kind=wp), intent(out) :: ff value of the model function. real(kind=wp), intent(out) :: f value of the objective function. integer, intent(in) :: kd degree of required derivatives. integer, intent(inout) :: ld degree of previously computed derivatives. integer, intent(in) :: iext type of extremum. iext=0 -- minimum. iext=1 -- maximum. Calls proc~~compute_obj_and_dobj~~CallsGraph proc~compute_obj_and_dobj psqp_class%compute_obj_and_dobj proc~mxvneg mxvneg proc~compute_obj_and_dobj->proc~mxvneg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_obj_and_dobj~~CalledByGraph proc~compute_obj_and_dobj psqp_class%compute_obj_and_dobj proc~psqp psqp_class%psqp proc~psqp->proc~compute_obj_and_dobj proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_obj_and_dobj ( me , nf , x , gf , g , ff , f , kd , ld , iext ) class ( psqp_class ), intent ( inout ) :: me integer , intent ( in ) :: nf !! number of variables. real ( wp ), intent ( in ) :: x ( nf ) !! x(nf)   vector of variables. real ( wp ), intent ( out ) :: gf ( nf ) !! gf(nf)  gradient of the model function. real ( wp ), intent ( out ) :: g ( nf ) !! g(nf)   gradient of the objective function. real ( wp ), intent ( out ) :: ff !! value of the model function. real ( wp ), intent ( out ) :: f !! value of the objective function. integer , intent ( in ) :: kd !! degree of required derivatives. integer , intent ( inout ) :: ld !! degree of previously computed derivatives. integer , intent ( in ) :: iext !! type of extremum. !! !! * `iext=0` -- minimum. !! * `iext=1` -- maximum. if ( kd <= ld ) return if ( ld < 0 ) then me % nfv = me % nfv + 1 call me % obj ( nf , x , ff ) if ( iext <= 0 ) then f = ff else f = - ff end if end if if ( kd >= 1 ) then if ( ld < 1 ) then me % nfg = me % nfg + 1 call me % dobj ( nf , x , gf ) if ( iext > 0 ) call mxvneg ( nf , gf , g ) end if end if ld = kd end subroutine compute_obj_and_dobj","tags":"","url":"proc/compute_obj_and_dobj.html"},{"title":"dual_range_space_quad_prog – psqp","text":"private  subroutine dual_range_space_quad_prog(me, nf, nc, x, ix, xl, xu, cf, cfd, ic, ica, cl, cu, cg, cr, cz, g, go, h, s, mfp, kbf, kbc, idecf, eta2, eta9, eps7, eps9, umax, gmax, n, iterq) dual range space quadratic programming method. Note This routine was formerly called plqdb1 . Type Bound psqp_class Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf number of variables. integer :: nc number of linear constraints. real(kind=wp) :: x (*) x(nf)   vector of variables. integer :: ix (*) ix(nf)  vector containing types of bounds. real(kind=wp) :: xl (*) xl(nf)  vector containing lower bounds for variables. real(kind=wp) :: xu (*) xu(nf)  vector containing upper bounds for variables. real(kind=wp) :: cf (*) cf(nf)  vector containing values of the constraint functions. real(kind=wp) :: cfd (*) cfd(nc)  vector containing increments of the constraint functions. integer :: ic (*) ic(nc)  vector containing types of constraints. integer :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cl (*) cl(nc)  vector containing lower bounds for constraint functions. real(kind=wp) :: cu (*) cu(nc)  vector containing upper bounds for constraint functions. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals of the linear constraints. real(kind=wp) :: cr (*) cr(nf*(nf+1)/2)  triangular decomposition of kernel of the orthogonal projection. real(kind=wp) :: cz (*) cz(nf)  vector of lagrange multipliers. real(kind=wp) :: g (*) g(nf)  gradient of the lagrangian function. real(kind=wp) :: go (*) go(nf)  saved gradient of the objective function. real(kind=wp) :: h (*) h(nf*(nf+1)/2)  triangular decomposition or inversion\nof the hessian matrix approximation. real(kind=wp) :: s (*) s(nf)  direction vector. integer :: mfp type of feasible point. mfp=1-arbitrary feasible point. mfp=2-optimum feasible point. mfp=3-repeated solution. integer :: kbf specification of simple bounds. kbf=0-no simple bounds. kbf=1-one sided simple bounds. kbf=2=two sided simple bounds. integer :: kbc specification of linear constraints. kbc=0 - no linear constraints. kbc=1 - one sided linear constraints. kbc=2 - two sided linear constraints. integer :: idecf decomposition indicator. idecf=0  - no decomposition. idecf=1  - gill-murray decomposition. idecf=9  - inversion. idecf=10 - diagonal matrix. real(kind=wp) :: eta2 tolerance for positive definiteness of the hessian matrix. real(kind=wp) :: eta9 maximum for real numbers. real(kind=wp) :: eps7 tolerance for linear independence of constraints. real(kind=wp) :: eps9 tolerance for activity of constraints. real(kind=wp) :: umax maximum absolute value of a negative lagrange multiplier. real(kind=wp) :: gmax maximum absolute value of a partial derivative. integer :: n dimension of the manifold defined by active constraints. integer :: iterq type of feasible point. iterq=1  - arbitrary feasible point. iterq=2  - optimum feasible point. iterq=-1 - feasible point does not exists. iterq=-2 - optimum feasible point does not exists. Calls proc~~dual_range_space_quad_prog~~CallsGraph proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~determine_new_active_linear_constr determine_new_active_linear_constr proc~dual_range_space_quad_prog->proc~determine_new_active_linear_constr proc~determine_new_active_simple_bound determine_new_active_simple_bound proc~dual_range_space_quad_prog->proc~determine_new_active_simple_bound proc~mxdpgb mxdpgb proc~dual_range_space_quad_prog->proc~mxdpgb proc~mxdpgf mxdpgf proc~dual_range_space_quad_prog->proc~mxdpgf proc~mxdprb mxdprb proc~dual_range_space_quad_prog->proc~mxdprb proc~mxdsmm mxdsmm proc~dual_range_space_quad_prog->proc~mxdsmm proc~mxvcop mxvcop proc~dual_range_space_quad_prog->proc~mxvcop proc~mxvdir mxvdir proc~dual_range_space_quad_prog->proc~mxvdir proc~mxvina mxvina proc~dual_range_space_quad_prog->proc~mxvina proc~mxvinv mxvinv proc~dual_range_space_quad_prog->proc~mxvinv proc~mxvneg mxvneg proc~dual_range_space_quad_prog->proc~mxvneg proc~ops_after_constr_deletion psqp_class%ops_after_constr_deletion proc~dual_range_space_quad_prog->proc~ops_after_constr_deletion proc~update_tri_decomp_general update_tri_decomp_general proc~dual_range_space_quad_prog->proc~update_tri_decomp_general proc~mxvdot mxvdot proc~determine_new_active_linear_constr->proc~mxvdot proc~update_tri_decomp_orthogonal update_tri_decomp_orthogonal proc~ops_after_constr_deletion->proc~update_tri_decomp_orthogonal proc~update_tri_decomp_general->proc~mxdpgb proc~update_tri_decomp_general->proc~mxdprb proc~update_tri_decomp_general->proc~mxdsmm proc~update_tri_decomp_general->proc~mxvcop proc~mxdsmv mxdsmv proc~update_tri_decomp_general->proc~mxdsmv proc~update_tri_decomp_general->proc~mxvdot proc~mxvset mxvset proc~update_tri_decomp_general->proc~mxvset proc~update_tri_decomp_orthogonal->proc~mxvcop proc~update_tri_decomp_orthogonal->proc~mxvset proc~mxvort mxvort proc~update_tri_decomp_orthogonal->proc~mxvort proc~mxvrot mxvrot proc~update_tri_decomp_orthogonal->proc~mxvrot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dual_range_space_quad_prog~~CalledByGraph proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dual_range_space_quad_prog ( me , nf , nc , x , ix , xl , xu , cf , cfd , & ic , ica , cl , cu , cg , cr , cz , g , go , h , s , & mfp , kbf , kbc , idecf , & eta2 , eta9 , eps7 , eps9 , umax , gmax , n , iterq ) class ( psqp_class ), intent ( inout ) :: me integer :: nf !! number of variables. integer :: nc !! number of linear constraints. integer :: ix ( * ) !! ix(nf)  vector containing types of bounds. integer :: ic ( * ) !! ic(nc)  vector containing types of constraints. integer :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. integer :: mfp !! type of feasible point. !! !! * mfp=1-arbitrary feasible point. !! * mfp=2-optimum feasible point. !! * mfp=3-repeated solution. integer :: kbf !! specification of simple bounds. !! !! * kbf=0-no simple bounds. !! * kbf=1-one sided simple bounds. !! * kbf=2=two sided simple bounds. integer :: kbc !! specification of linear constraints. !! !! * kbc=0 - no linear constraints. !! * kbc=1 - one sided linear constraints. !! * kbc=2 - two sided linear constraints. integer :: idecf !! decomposition indicator. !! !! * idecf=0  - no decomposition. !! * idecf=1  - gill-murray decomposition. !! * idecf=9  - inversion. !! * idecf=10 - diagonal matrix. integer :: n !! dimension of the manifold defined by active constraints. integer :: iterq !! type of feasible point. !! !! * iterq=1  - arbitrary feasible point. !! * iterq=2  - optimum feasible point. !! * iterq=-1 - feasible point does not exists. !! * iterq=-2 - optimum feasible point does not exists. real ( wp ) :: x ( * ) !! x(nf)   vector of variables. real ( wp ) :: xl ( * ) !! xl(nf)  vector containing lower bounds for variables. real ( wp ) :: xu ( * ) !! xu(nf)  vector containing upper bounds for variables. real ( wp ) :: cf ( * ) !! cf(nf)  vector containing values of the constraint functions. real ( wp ) :: cfd ( * ) !! cfd(nc)  vector containing increments of the constraint functions. real ( wp ) :: cl ( * ) !! cl(nc)  vector containing lower bounds for constraint functions. real ( wp ) :: cu ( * ) !! cu(nc)  vector containing upper bounds for constraint functions. real ( wp ) :: cg ( * ) !! cg(nf*nc)  matrix whose columns are normals of the linear constraints. real ( wp ) :: cr ( * ) !! cr(nf*(nf+1)/2)  triangular decomposition of kernel of the orthogonal projection. real ( wp ) :: cz ( * ) !! cz(nf)  vector of lagrange multipliers. real ( wp ) :: g ( * ) !! g(nf)  gradient of the lagrangian function. real ( wp ) :: go ( * ) !! go(nf)  saved gradient of the objective function. real ( wp ) :: h ( * ) !! h(nf*(nf+1)/2)  triangular decomposition or inversion !! of the hessian matrix approximation. real ( wp ) :: s ( * ) !! s(nf)  direction vector. real ( wp ) :: eta2 !! tolerance for positive definiteness of the hessian matrix. real ( wp ) :: eta9 !! maximum for real numbers. real ( wp ) :: eps7 !! tolerance for linear independence of constraints. real ( wp ) :: eps9 !! tolerance for activity of constraints. real ( wp ) :: umax !! maximum absolute value of a negative lagrange multiplier. real ( wp ) :: gmax !! maximum absolute value of a partial derivative. real ( wp ) :: con , temp , step , step1 , step2 , dmax , par , snorm integer :: nca , ncr , i , j , k , iold , jold , inew , jnew , knew , & inf , ier , krem , kc , nred con = eta9 if ( idecf < 0 ) idecf = 1 if ( idecf == 0 ) then ! gill-murray decomposition temp = eta2 call mxdpgf ( nf , h , inf , temp , step ) me % ndec = me % ndec + 1 idecf = 1 end if if ( idecf >= 2 . and . idecf <= 8 ) then iterq = - 10 return end if ! initiation nred = 0 jold = 0 jnew = 0 iterq = 0 dmax = 0.0_wp if ( mfp /= 3 ) then n = nf nca = 0 ncr = 0 if ( kbf > 0 ) call mxvina ( nf , ix ) if ( kbc > 0 ) call mxvina ( nc , ic ) end if outer : do ! direction determination call mxvneg ( nf , go , s ) do j = 1 , nca kc = ica ( j ) if ( kc > 0 ) then call mxvdir ( nf , cz ( j ), cg (( kc - 1 ) * nf + 1 ), s , s ) else k = - kc s ( k ) = s ( k ) + cz ( j ) end if end do call mxvcop ( nf , s , g ) if ( idecf == 1 ) then call mxdpgb ( nf , h , s , 0 ) else call mxdsmm ( nf , h , g , s ) end if if ( iterq /= 3 ) then ! check of feasibility inew = 0 par = 0.0_wp call determine_new_active_linear_constr ( nf , nc , cf , cfd , ic , cl , cu , & cg , s , eps9 , par , kbc , inew , knew ) call determine_new_active_simple_bound ( nf , ix , x , xl , xu , s , kbf , inew , & knew , eps9 , par ) if ( inew == 0 ) then ! solution achieved call mxvneg ( nf , g , g ) iterq = 2 return else snorm = 0.0_wp end if inner : do ier = 0 ! stepsize determination call update_tri_decomp_general ( nf , n , ica , cg , cr , h , s , g , eps7 , gmax , umax , & idecf , inew , me % nadd , ier , 1 ) call mxdprb ( nca , cr , g , - 1 ) if ( knew < 0 ) call mxvneg ( nca , g , g ) ! primal stepsize if ( ier /= 0 ) then step1 = con else step1 = - par / umax end if ! dual stepsize iold = 0 step2 = con do j = 1 , nca kc = ica ( j ) if ( kc >= 0 ) then k = ic ( kc ) else i = - kc k = ix ( i ) end if if ( k <= - 5 ) then elseif (( k == - 1 . or . k == - 3. ) . and . g ( j ) <= 0.0_wp ) then elseif (. not . (( k == - 2 . or . k == - 4. ) . and . g ( j ) >= 0.0_wp )) then temp = cz ( j ) / g ( j ) if ( step2 > temp ) then iold = j step2 = temp end if end if end do ! final stepsize step = min ( step1 , step2 ) if ( step >= con ) then ! feasible solution does not exist iterq = - 1 return end if ! new lagrange multipliers dmax = step call mxvdir ( nca , - step , g , cz , cz ) snorm = snorm + sign ( 1 , knew ) * step par = par - ( step / step1 ) * par if ( step == step1 ) then if ( n <= 0 ) then ! impossible situation iterq = - 5 return end if ! constraint addition if ( ier == 0 ) then n = n - 1 nca = nca + 1 ncr = ncr + nca cz ( nca ) = snorm end if if ( inew > 0 ) then kc = inew call mxvinv ( ic , kc , knew ) elseif ( abs ( knew ) == 1 ) then i = - inew call mxvinv ( ix , i , knew ) else i = - inew if ( knew > 0 ) ix ( i ) = - 3 if ( knew < 0 ) ix ( i ) = - 4 end if nred = nred + 1 me % nadd = me % nadd + 1 jnew = inew jold = 0 cycle outer end if ! constraint deletion do j = iold , nca - 1 cz ( j ) = cz ( j + 1 ) end do call me % ops_after_constr_deletion ( nf , nc , ix , ic , ica , cr , ic , g , n , iold , krem , ier ) ncr = ncr - nca nca = nca - 1 jold = iold jnew = 0 if ( kbc > 0 ) call mxvina ( nc , ic ) if ( kbf > 0 ) call mxvina ( nf , ix ) do j = 1 , nca kc = ica ( j ) if ( kc > 0 ) then ic ( kc ) = - ic ( kc ) else kc = - kc ix ( kc ) = - ix ( kc ) end if end do end do inner end if exit outer end do outer end subroutine dual_range_space_quad_prog","tags":"","url":"proc/dual_range_space_quad_prog.html"},{"title":"update_tri_decomp_general – psqp","text":"private  subroutine update_tri_decomp_general(nf, n, ica, cg, cr, h, s, g, eps7, gmax, umax, idecf, inew, nadd, ier, job) triangular decomposition of kernel of the general projection\n is updated after constraint addition. Note This routine was formerly called pladr1 . Arguments Type Intent Optional Attributes Name integer :: nf declared number of variables. integer :: n actual number of variables. integer :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals of\nthe linear constraints. real(kind=wp) :: cr (*) cr(nf*(nf+1)/2)  triangular decomposition of\nkernel of the orthogonal projection. real(kind=wp) :: h (*) h(nf*(nf+1)/2)  triangular decomposition or\ninversion of the hessian matrix approximation. real(kind=wp) :: s (*) s(nf)  auxiliary vector. real(kind=wp) :: g (*) g(nf)  vector used in the dual range space\nquadratic programming method. real(kind=wp) :: eps7 tolerance for linear independence of constraints. real(kind=wp) :: gmax maximum absolute value of a partial derivative. real(kind=wp) :: umax maximum absolute value of a negative\nlagrange multiplier. integer :: idecf decomposition indicator. idecf=0-no decomposition. idecf=1-gill-murray decomposition. idecf=9-inversion. idecf=10-diagonal matrix. integer :: inew index of the new active constraint. integer :: nadd number of constraint additions. integer :: ier error indicator. integer :: job specification of computation.\noutput vector g is not or is\ncomputed in case when n<=0 if\njob=0 or job=1 respectively. Calls proc~~update_tri_decomp_general~~CallsGraph proc~update_tri_decomp_general update_tri_decomp_general proc~mxdpgb mxdpgb proc~update_tri_decomp_general->proc~mxdpgb proc~mxdprb mxdprb proc~update_tri_decomp_general->proc~mxdprb proc~mxdsmm mxdsmm proc~update_tri_decomp_general->proc~mxdsmm proc~mxdsmv mxdsmv proc~update_tri_decomp_general->proc~mxdsmv proc~mxvcop mxvcop proc~update_tri_decomp_general->proc~mxvcop proc~mxvdot mxvdot proc~update_tri_decomp_general->proc~mxvdot proc~mxvset mxvset proc~update_tri_decomp_general->proc~mxvset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~update_tri_decomp_general~~CalledByGraph proc~update_tri_decomp_general update_tri_decomp_general proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~update_tri_decomp_general proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_tri_decomp_general ( nf , n , ica , cg , cr , h , s , g , eps7 , & gmax , umax , idecf , inew , nadd , ier , job ) integer :: nf !! declared number of variables. integer :: n !! actual number of variables. integer :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. integer :: idecf !! decomposition indicator. !! !! * idecf=0-no decomposition. !! * idecf=1-gill-murray decomposition. !! * idecf=9-inversion. !! * idecf=10-diagonal matrix. integer :: inew !! index of the new active constraint. integer :: nadd !! number of constraint additions. integer :: ier !! error indicator. integer :: job !! specification of computation. !! output vector g is not or is !! computed in case when n<=0 if !! job=0 or job=1 respectively. real ( wp ) :: cg ( * ) !! cg(nf*nc)  matrix whose columns are normals of !! the linear constraints. real ( wp ) :: cr ( * ) !! cr(nf*(nf+1)/2)  triangular decomposition of !! kernel of the orthogonal projection. real ( wp ) :: h ( * ) !! h(nf*(nf+1)/2)  triangular decomposition or !! inversion of the hessian matrix approximation. real ( wp ) :: s ( * ) !! s(nf)  auxiliary vector. real ( wp ) :: g ( * ) !! g(nf)  vector used in the dual range space !! quadratic programming method. real ( wp ) :: eps7 !! tolerance for linear independence of constraints. real ( wp ) :: gmax !! maximum absolute value of a partial derivative. real ( wp ) :: umax !! maximum absolute value of a negative !! lagrange multiplier. integer :: nca , ncr , jcg , j , k , l ier = 0 if ( job == 0 . and . n <= 0 ) ier = 2 if ( inew == 0 ) ier = 3 if ( idecf /= 1 . and . idecf /= 9 ) ier = - 2 if ( ier /= 0 ) return nca = nf - n ncr = nca * ( nca + 1 ) / 2 if ( inew > 0 ) then jcg = ( inew - 1 ) * nf + 1 if ( idecf == 1 ) then call mxvcop ( nf , cg ( jcg ), s ) call mxdpgb ( nf , h , s , 0 ) else call mxdsmm ( nf , h , cg ( jcg ), s ) end if gmax = mxvdot ( nf , cg ( jcg ), s ) else k = - inew if ( idecf == 1 ) then call mxvset ( nf , 0.0_wp , s ) s ( k ) = 1.0_wp call mxdpgb ( nf , h , s , 0 ) else call mxdsmv ( nf , h , s , k ) end if gmax = s ( k ) end if do j = 1 , nca l = ica ( j ) if ( l > 0 ) then g ( j ) = mxvdot ( nf , cg (( l - 1 ) * nf + 1 ), s ) else l = - l g ( j ) = s ( l ) end if end do if ( n == 0 ) then call mxdprb ( nca , cr , g , 1 ) umax = 0.0_wp ier = 2 return elseif ( nca == 0 ) then umax = gmax else call mxdprb ( nca , cr , g , 1 ) umax = gmax - mxvdot ( nca , g , g ) call mxvcop ( nca , g , cr ( ncr + 1 )) end if if ( umax <= eps7 * gmax ) then ier = 1 return else nca = nca + 1 ncr = ncr + nca ica ( nca ) = inew cr ( ncr ) = sqrt ( umax ) if ( job == 0 ) then n = n - 1 nadd = nadd + 1 end if end if end subroutine update_tri_decomp_general","tags":"","url":"proc/update_tri_decomp_general.html"},{"title":"determine_new_active_linear_constr – psqp","text":"private  subroutine determine_new_active_linear_constr(nf, nc, cf, cfd, ic, cl, cu, cg, s, eps9, par, kbc, inew, knew) determination of the new active linear constraint. Note This routine was formerly called plminn . Arguments Type Intent Optional Attributes Name integer :: nf number of variables. integer :: nc number of constraints. real(kind=wp) :: cf (*) cf(nc)  vector containing values of the\nconstraint functions. real(kind=wp) :: cfd (*) cfd(nc)  vector containing increments of\nthe constraint functions. integer :: ic (*) ic(nc)  vector containing types of constraints. real(kind=wp) :: cl (*) cl(nc)  vector containing lower bounds for\nconstraint functions. real(kind=wp) :: cu (*) cu(nc)  vector containing upper bounds for\nconstraint functions. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals\nof the linear constraints. real(kind=wp) :: s (*) s(nf)  direction vector. real(kind=wp) :: eps9 tolerance for active constraints. real(kind=wp) :: par auxiliary variable. integer :: kbc specification of linear constraints. kbc=0 - no linear constraints. kbc=1 - one sided linear constraints. kbc=2 - two sided linear constraints. integer :: inew index of the new active constraint. integer :: knew signum of the new active normal. Calls proc~~determine_new_active_linear_constr~~CallsGraph proc~determine_new_active_linear_constr determine_new_active_linear_constr proc~mxvdot mxvdot proc~determine_new_active_linear_constr->proc~mxvdot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~determine_new_active_linear_constr~~CalledByGraph proc~determine_new_active_linear_constr determine_new_active_linear_constr proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~determine_new_active_linear_constr proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine determine_new_active_linear_constr ( nf , nc , cf , cfd , ic , cl , cu , & cg , s , eps9 , par , kbc , inew , knew ) integer :: nf !! number of variables. integer :: nc !! number of constraints. integer :: ic ( * ) !! ic(nc)  vector containing types of constraints. integer :: kbc !! specification of linear constraints. !! !! * kbc=0 - no linear constraints. !! * kbc=1 - one sided linear constraints. !! * kbc=2 - two sided linear constraints. integer :: inew !! index of the new active constraint. integer :: knew !! signum of the new active normal. real ( wp ) :: cf ( * ) !! cf(nc)  vector containing values of the !! constraint functions. real ( wp ) :: cfd ( * ) !! cfd(nc)  vector containing increments of !! the constraint functions. real ( wp ) :: cl ( * ) !! cl(nc)  vector containing lower bounds for !! constraint functions. real ( wp ) :: cu ( * ) !! cu(nc)  vector containing upper bounds for !! constraint functions. real ( wp ) :: cg ( * ) !! cg(nf*nc)  matrix whose columns are normals !! of the linear constraints. real ( wp ) :: s ( * ) !! s(nf)  direction vector. real ( wp ) :: eps9 !! tolerance for active constraints. real ( wp ) :: par !! auxiliary variable. real ( wp ) :: temp , pom integer :: jcg , kc if ( kbc > 0 ) then jcg = 1 do kc = 1 , nc if ( ic ( kc ) > 0 ) then temp = mxvdot ( nf , cg ( jcg ), s ) cfd ( kc ) = temp temp = cf ( kc ) + temp if ( ic ( kc ) == 1 . or . ic ( kc ) >= 3 ) then pom = temp - cl ( kc ) if ( pom < min ( par , - eps9 * max ( abs ( cl ( kc )), 1.0_wp ))) then inew = kc knew = 1 par = pom end if end if if ( ic ( kc ) == 2 . or . ic ( kc ) >= 3 ) then pom = cu ( kc ) - temp if ( pom < min ( par , - eps9 * max ( abs ( cu ( kc )), 1.0_wp ))) then inew = kc knew = - 1 par = pom end if end if end if jcg = jcg + nf end do end if end subroutine determine_new_active_linear_constr","tags":"","url":"proc/determine_new_active_linear_constr.html"},{"title":"determine_new_active_simple_bound – psqp","text":"private  subroutine determine_new_active_simple_bound(nf, ix, xo, xl, xu, s, kbf, inew, knew, eps9, par) determination of the new active simple bound. Note This routine was formerly called plmins . Arguments Type Intent Optional Attributes Name integer :: nf declared number of variables. integer :: ix (*) ix(nf)  vector containing types of bounds. real(kind=wp) :: xo (*) xo(nf)  saved vector of variables. real(kind=wp) :: xl (*) xl(nf)  vector containing lower bounds\nfor variables. real(kind=wp) :: xu (*) xu(nf)  vector containing upper bounds\nfor variables. real(kind=wp) :: s (*) s(nf)  direction vector. integer :: kbf specification of simple bounds. kbf=0-no simple bounds. kbf=1-one sided simple bounds. kbf=2=two sided simple bounds. integer :: inew index of the new active constraint. integer :: knew signum of the new normal. real(kind=wp) :: eps9 tolerance for active constraints. real(kind=wp) :: par auxiliary variable. Called by proc~~determine_new_active_simple_bound~~CalledByGraph proc~determine_new_active_simple_bound determine_new_active_simple_bound proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~determine_new_active_simple_bound proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine determine_new_active_simple_bound ( nf , ix , xo , xl , xu , s , kbf , & inew , knew , eps9 , par ) real ( wp ) :: eps9 !! tolerance for active constraints. real ( wp ) :: par !! auxiliary variable. integer :: inew !! index of the new active constraint. integer :: kbf !! specification of simple bounds. !! !! * kbf=0-no simple bounds. !! * kbf=1-one sided simple bounds. !! * kbf=2=two sided simple bounds. integer :: knew !! signum of the new normal. integer :: nf !! declared number of variables. real ( wp ) :: s ( * ) !! s(nf)  direction vector. real ( wp ) :: xl ( * ) !! xl(nf)  vector containing lower bounds !! for variables. real ( wp ) :: xo ( * ) !! xo(nf)  saved vector of variables. real ( wp ) :: xu ( * ) !! xu(nf)  vector containing upper bounds !! for variables. integer :: ix ( * ) !! ix(nf)  vector containing types of bounds. real ( wp ) :: pom , temp integer :: i if ( kbf > 0 ) then do i = 1 , nf if ( ix ( i ) > 0 ) then temp = 1.0_wp if ( ix ( i ) == 1 . or . ix ( i ) >= 3 ) then pom = xo ( i ) + s ( i ) * temp - xl ( i ) if ( pom < min ( par , - eps9 * max ( abs ( xl ( i )), temp ))) then inew = - i knew = 1 par = pom end if end if if ( ix ( i ) == 2 . or . ix ( i ) >= 3 ) then pom = xu ( i ) - s ( i ) * temp - xo ( i ) if ( pom < min ( par , - eps9 * max ( abs ( xu ( i )), temp ))) then inew = - i knew = - 1 par = pom end if end if end if end do end if end subroutine determine_new_active_simple_bound","tags":"","url":"proc/determine_new_active_simple_bound.html"},{"title":"test_simple_bound – psqp","text":"private  subroutine test_simple_bound(x, ix, xl, xu, eps9, i) test on activity of a given simple bound. Note This routine was formerly called plnews . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (*) x(nf)  vector of variables. integer, intent(inout) :: ix (*) ix(nf)  vector containing types of bounds. real(kind=wp), intent(in) :: xl (*) xl(nf)  vector containing lower bounds for variables. real(kind=wp), intent(in) :: xu (*) xu(nf)  vector containing upper bounds for variables. real(kind=wp), intent(in) :: eps9 tolerance for active constraints. integer, intent(in) :: i index of tested simple bound. Called by proc~~test_simple_bound~~CalledByGraph proc~test_simple_bound test_simple_bound proc~psqp psqp_class%psqp proc~psqp->proc~test_simple_bound proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine test_simple_bound ( x , ix , xl , xu , eps9 , i ) real ( wp ), intent ( in ) :: x ( * ) !! x(nf)  vector of variables. integer , intent ( inout ) :: ix ( * ) !! ix(nf)  vector containing types of bounds. real ( wp ), intent ( in ) :: xl ( * ) !! xl(nf)  vector containing lower bounds for variables. real ( wp ), intent ( in ) :: xu ( * ) !! xu(nf)  vector containing upper bounds for variables. real ( wp ), intent ( in ) :: eps9 !! tolerance for active constraints. integer , intent ( in ) :: i !! index of tested simple bound. real ( wp ) :: temp temp = 1.0_wp if ( ix ( i ) <= 0 ) then elseif ( ix ( i ) == 1 ) then if ( x ( i ) <= xl ( i ) + eps9 * max ( abs ( xl ( i )), temp )) then ix ( i ) = 11 end if elseif ( ix ( i ) == 2 ) then if ( x ( i ) >= xu ( i ) - eps9 * max ( abs ( xu ( i )), temp )) then ix ( i ) = 12 end if elseif ( ix ( i ) == 3 . or . ix ( i ) == 4 ) then if ( x ( i ) <= xl ( i ) + eps9 * max ( abs ( xl ( i )), temp )) then ix ( i ) = 13 end if if ( x ( i ) >= xu ( i ) - eps9 * max ( abs ( xu ( i )), temp )) then ix ( i ) = 14 end if end if end subroutine test_simple_bound","tags":"","url":"proc/test_simple_bound.html"},{"title":"transform_incompatible_qp_subproblem – psqp","text":"private  subroutine transform_incompatible_qp_subproblem(nc, cf, ic, cl, cu, kbc) transformation of the incompatible quadratic programming subproblem. Note This routine was formerly called plredl . Arguments Type Intent Optional Attributes Name integer :: nc number of current linear constraints. real(kind=wp) :: cf (*) cf(nf)  vector containing values of the constraint functions. integer :: ic (nc) ic(nc)  vector containing types of constraints. real(kind=wp) :: cl (*) cl(nc)  vector containing lower bounds for constraint functions. real(kind=wp) :: cu (*) cu(nc)  vector containing upper bounds for constraint functions. integer :: kbc specification of linear constraints. kbc=0-no linear constraints. kbc=1-one sided linear constraints. kbc=2=two sided linear constraints. Called by proc~~transform_incompatible_qp_subproblem~~CalledByGraph proc~transform_incompatible_qp_subproblem transform_incompatible_qp_subproblem proc~psqp psqp_class%psqp proc~psqp->proc~transform_incompatible_qp_subproblem proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine transform_incompatible_qp_subproblem ( nc , cf , ic , cl , cu , kbc ) integer :: nc !! number of current linear constraints. integer :: ic ( nc ) !! ic(nc)  vector containing types of constraints. integer :: kbc !! specification of linear constraints. !! !! * kbc=0-no linear constraints. !! * kbc=1-one sided linear constraints. !! * kbc=2=two sided linear constraints. real ( wp ) :: cf ( * ) !! cf(nf)  vector containing values of the constraint functions. real ( wp ) :: cl ( * ) !! cl(nc)  vector containing lower bounds for constraint functions. real ( wp ) :: cu ( * ) !! cu(nc)  vector containing upper bounds for constraint functions. real ( wp ) :: temp integer :: k , kc if ( kbc > 0 ) then do kc = 1 , nc k = ic ( kc ) if ( abs ( k ) == 1 . or . abs ( k ) == 3 . or . abs ( k ) == 4 ) then temp = ( cf ( kc ) - cl ( kc )) if ( temp < 0 ) cf ( kc ) = cl ( kc ) + 0.1_wp * temp end if if ( abs ( k ) == 2 . or . abs ( k ) == 3 . or . abs ( k ) == 4 ) then temp = ( cf ( kc ) - cu ( kc )) if ( temp > 0 ) cf ( kc ) = cu ( kc ) + 0.1_wp * temp end if if ( abs ( k ) == 5 . or . abs ( k ) == 6 ) then temp = ( cf ( kc ) - cl ( kc )) cf ( kc ) = cl ( kc ) + 0.1_wp * temp end if end do end if end subroutine transform_incompatible_qp_subproblem","tags":"","url":"proc/transform_incompatible_qp_subproblem.html"},{"title":"ops_after_constr_deletion – psqp","text":"private  subroutine ops_after_constr_deletion(me, nf, nc, ix, ia, iaa, ar, ic, s, n, iold, krem, ier) operations after constraint deletion. Note This routine was formerly called plrmf0 . Type Bound psqp_class Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf declared number of variables. integer :: nc number of constraints. integer :: ix (*) ix(nf)  vector containing types of bounds. integer :: ia (*) ia(na)  vector containing types of deviations. integer :: iaa (*) iaa(nf+1)  vector containing indices of active\nfunctions. real(kind=wp) :: ar (*) ar((nf+1)*(nf+2)/2)  triangular decomposition\nof kernel of the orthogonal projection. integer :: ic (*) ic(nc)  vector containing types of constraints. real(kind=wp) :: s (*) s(nf+1)  auxiliary vector. integer :: n actual number of variables. integer :: iold index of the old active constraint. integer :: krem auxiliary variable. integer :: ier error indicator. Calls proc~~ops_after_constr_deletion~~CallsGraph proc~ops_after_constr_deletion psqp_class%ops_after_constr_deletion proc~update_tri_decomp_orthogonal update_tri_decomp_orthogonal proc~ops_after_constr_deletion->proc~update_tri_decomp_orthogonal proc~mxvcop mxvcop proc~update_tri_decomp_orthogonal->proc~mxvcop proc~mxvort mxvort proc~update_tri_decomp_orthogonal->proc~mxvort proc~mxvrot mxvrot proc~update_tri_decomp_orthogonal->proc~mxvrot proc~mxvset mxvset proc~update_tri_decomp_orthogonal->proc~mxvset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ops_after_constr_deletion~~CalledByGraph proc~ops_after_constr_deletion psqp_class%ops_after_constr_deletion proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~ops_after_constr_deletion proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine ops_after_constr_deletion ( me , nf , nc , ix , ia , iaa , ar , & ic , s , n , iold , krem , ier ) class ( psqp_class ), intent ( inout ) :: me integer :: ier !! error indicator. integer :: iold !! index of the old active constraint. integer :: krem !! auxiliary variable. integer :: n !! actual number of variables. integer :: nc !! number of constraints. integer :: nf !! declared number of variables. real ( wp ) :: ar ( * ) !! ar((nf+1)*(nf+2)/2)  triangular decomposition !! of kernel of the orthogonal projection. real ( wp ) :: s ( * ) !! s(nf+1)  auxiliary vector. integer :: ia ( * ) !! ia(na)  vector containing types of deviations. integer :: iaa ( * ) !! iaa(nf+1)  vector containing indices of active !! functions. integer :: ic ( * ) !! ic(nc)  vector containing types of constraints. integer :: ix ( * ) !! ix(nf)  vector containing types of bounds. integer :: l call update_tri_decomp_orthogonal ( nf , iaa , ar , s , n , iold , krem , ier ) n = n + 1 me % nrem = me % nrem + 1 l = iaa ( nf - n + 1 ) if ( l > nc ) then l = l - nc ia ( l ) = - ia ( l ) elseif ( l > 0 ) then ic ( l ) = - ic ( l ) else l = - l ix ( l ) = - ix ( l ) end if end subroutine ops_after_constr_deletion","tags":"","url":"proc/ops_after_constr_deletion.html"},{"title":"update_tri_decomp_orthogonal – psqp","text":"private  subroutine update_tri_decomp_orthogonal(nf, ica, cr, g, n, iold, krem, ier) triangular decomposition of kernel of the orthogonal projection is\n updated after constraint deletion. Note This routine was formerly called plrmr0 . Arguments Type Intent Optional Attributes Name integer :: nf declared number of variables. integer :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cr (*) cr(nf*(nf+1)/2)  triangular decomposition\nof kernel of the orthogonal projection. real(kind=wp) :: g (*) g(nf)  auxiliary vector. integer :: n actual number of variables. integer :: iold index of the old active constraint. integer :: krem auxiliary variable. integer :: ier error indicator. Calls proc~~update_tri_decomp_orthogonal~~CallsGraph proc~update_tri_decomp_orthogonal update_tri_decomp_orthogonal proc~mxvcop mxvcop proc~update_tri_decomp_orthogonal->proc~mxvcop proc~mxvort mxvort proc~update_tri_decomp_orthogonal->proc~mxvort proc~mxvrot mxvrot proc~update_tri_decomp_orthogonal->proc~mxvrot proc~mxvset mxvset proc~update_tri_decomp_orthogonal->proc~mxvset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~update_tri_decomp_orthogonal~~CalledByGraph proc~update_tri_decomp_orthogonal update_tri_decomp_orthogonal proc~ops_after_constr_deletion psqp_class%ops_after_constr_deletion proc~ops_after_constr_deletion->proc~update_tri_decomp_orthogonal proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~ops_after_constr_deletion proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_tri_decomp_orthogonal ( nf , ica , cr , g , n , iold , krem , ier ) integer :: ier !! error indicator. integer :: iold !! index of the old active constraint. integer :: krem !! auxiliary variable. integer :: n !! actual number of variables. integer :: nf !! declared number of variables. real ( wp ) :: cr ( * ) !! cr(nf*(nf+1)/2)  triangular decomposition !! of kernel of the orthogonal projection. real ( wp ) :: g ( * ) !! g(nf)  auxiliary vector. integer :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. real ( wp ) :: ck , cl integer :: i , j , k , kc , l , nca nca = nf - n if ( iold < nca ) then k = iold * ( iold - 1 ) / 2 kc = ica ( iold ) call mxvcop ( iold , cr ( k + 1 ), g ) call mxvset ( nca - iold , 0.0_wp , g ( iold + 1 )) k = k + iold do i = iold + 1 , nca k = k + i call mxvort ( cr ( k - 1 ), cr ( k ), ck , cl , ier ) call mxvrot ( g ( i - 1 ), g ( i ), ck , cl , ier ) l = k do j = i , nca - 1 l = l + j call mxvrot ( cr ( l - 1 ), cr ( l ), ck , cl , ier ) end do end do k = iold * ( iold - 1 ) / 2 do i = iold , nca - 1 l = k + i ica ( i ) = ica ( i + 1 ) call mxvcop ( i , cr ( l + 1 ), cr ( k + 1 )) k = l end do ica ( nca ) = kc call mxvcop ( nca , g , cr ( k + 1 )) end if krem = 1 end subroutine update_tri_decomp_orthogonal","tags":"","url":"proc/update_tri_decomp_orthogonal.html"},{"title":"line_search_interpolation – psqp","text":"private  subroutine line_search_interpolation(ro, rl, ru, ri, fo, fl, fu, fi, po, r, mode, mtyp, merr) extrapolation or interpolation for line search without directional\n derivatives. Method extrapolation or interpolation with standard model functions. Note This routine was formerly called pnint3 . Arguments Type Intent Optional Attributes Name real(kind=wp) :: ro initial value of the stepsize parameter. real(kind=wp) :: rl lower value of the stepsize parameter. real(kind=wp) :: ru upper value of the stepsize parameter. real(kind=wp) :: ri inner value of the stepsize parameter. real(kind=wp) :: fo value of the objective function for r=ro. real(kind=wp) :: fl value of the objective function for r=rl. real(kind=wp) :: fu value of the objective function for r=ru. real(kind=wp) :: fi value of the objective function for r=ri. real(kind=wp) :: po initial value of the directional derivative. real(kind=wp) :: r value of the stepsize parameter obtained. integer :: mode mode of line search. integer :: mtyp method selection mtyp=1 - bisection. mtyp=2 - two point quadratic interpolation. mtyp=2 - three point quadratic interpolation. integer :: merr error indicator. merr=0 for normal return. Called by proc~~line_search_interpolation~~CalledByGraph proc~line_search_interpolation line_search_interpolation proc~extended_line_search psqp_class%extended_line_search proc~extended_line_search->proc~line_search_interpolation proc~psqp psqp_class%psqp proc~psqp->proc~extended_line_search proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine line_search_interpolation ( ro , rl , ru , ri , fo , fl , fu , fi , & po , r , mode , mtyp , merr ) real ( wp ) :: fo !! value of the objective function for r=ro. real ( wp ) :: fl !! value of the objective function for r=rl. real ( wp ) :: fu !! value of the objective function for r=ru. real ( wp ) :: fi !! value of the objective function for r=ri. real ( wp ) :: po !! initial value of the directional derivative. real ( wp ) :: r !! value of the stepsize parameter obtained. real ( wp ) :: rl !! lower value of the stepsize parameter. real ( wp ) :: ru !! upper value of the stepsize parameter. real ( wp ) :: ri !! inner value of the stepsize parameter. real ( wp ) :: ro !! initial value of the stepsize parameter. integer :: merr !! error indicator. merr=0 for normal return. integer :: mode !! mode of line search. integer :: mtyp !! method selection !! !! * mtyp=1 - bisection. !! * mtyp=2 - two point quadratic interpolation. !! * mtyp=2 - three point quadratic interpolation. real ( wp ) :: ai , al , au , den , dis integer :: ntyp logical :: l1 , l2 real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: two = 2.0_wp real ( wp ), parameter :: three = 3.0_wp real ( wp ), parameter :: c1l = 1.1_wp real ( wp ), parameter :: c1u = 100 0.0_wp real ( wp ), parameter :: c2l = 1.0e-2_wp real ( wp ), parameter :: c2u = 0.9_wp real ( wp ), parameter :: c3l = 1.0e-1_wp merr = 0 if ( mode <= 0 ) return if ( po >= zero ) then merr = 2 return elseif ( ru <= rl ) then merr = 3 return end if l1 = rl <= ro l2 = ri <= rl main : do ntyp = mtyp , 1 , - 1 if ( ntyp == 1 ) then ! bisection if ( mode == 1 ) then r = two * ru return elseif ( ri - rl <= ru - ri ) then r = half * ( ri + ru ) return else r = half * ( rl + ri ) return end if elseif ( ntyp == mtyp . and . l1 ) then if (. not . l2 ) ai = ( fi - fo ) / ( ri * po ) au = ( fu - fo ) / ( ru * po ) end if if ( l1 . and . ( ntyp == 2 . or . l2 )) then ! two point quadratic extrapolation or interpolation if ( au >= one ) cycle main r = half * ru / ( one - au ) elseif (. not . l1 . or . . not . l2 . and . ntyp == 3 ) then ! three point quadratic extrapolation or interpolation al = ( fi - fl ) / ( ri - rl ) au = ( fu - fi ) / ( ru - ri ) den = au - al if ( den <= zero ) cycle main r = ri - half * ( au * ( ri - rl ) + al * ( ru - ri )) / den elseif ( l1 . and . . not . l2 . and . ntyp == 4 ) then ! three point cubic extrapolation or interpolation dis = ( ai - one ) * ( ru / ri ) den = ( au - one ) * ( ri / ru ) - dis dis = au + ai - den - two * ( one + dis ) dis = den * den - three * dis if ( dis < zero ) cycle main den = den + sqrt ( dis ) if ( den == zero ) cycle main r = ( ru - ri ) / den else cycle main end if if ( mode == 1 . and . r > ru ) then ! extrapolation accepted r = max ( r , c1l * ru ) r = min ( r , c1u * ru ) return elseif ( mode == 2 . and . r > rl . and . r < ru ) then ! interpolation accepted if ( ri == zero . and . ntyp /= 4 ) then r = max ( r , rl + c2l * ( ru - rl )) else r = max ( r , rl + c3l * ( ru - rl )) end if r = min ( r , rl + c2u * ( ru - rl )) if ( r /= ri ) return end if end do main end subroutine line_search_interpolation","tags":"","url":"proc/line_search_interpolation.html"},{"title":"compute_augmented_lagrangian – psqp","text":"private pure subroutine compute_augmented_lagrangian(nf, n, nc, cf, ic, ica, cl, cu, cz, rpf, fc, f) computation of value of the augmented lagrangian function. Note This routine was formerly called pp0af8 . Arguments Type Intent Optional Attributes Name integer, intent(in) :: nf number of variables. integer, intent(in) :: n dimension of the constraint null space. integer, intent(in) :: nc number of constraints. real(kind=wp), intent(in) :: cf (*) cf(nc+1)  vector containing values of the constraints. integer, intent(in) :: ic (*) ic(nc)  vector containing types of constraints. integer, intent(in) :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp), intent(in) :: cl (*) cl(nc)  vector containing lower bounds for constraint functions. real(kind=wp), intent(in) :: cu (*) cu(nc)  vector containing upper bounds for constraint functions. real(kind=wp), intent(in) :: cz (*) cz(nc)  vector of lagrange multipliers. real(kind=wp), intent(in) :: rpf penalty coefficient. real(kind=wp), intent(out) :: fc value of the penalty term. real(kind=wp), intent(out) :: f value of the penalty function. Called by proc~~compute_augmented_lagrangian~~CalledByGraph proc~compute_augmented_lagrangian compute_augmented_lagrangian proc~psqp psqp_class%psqp proc~psqp->proc~compute_augmented_lagrangian proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine compute_augmented_lagrangian ( nf , n , nc , cf , ic , ica , cl , cu , cz , rpf , fc , f ) integer , intent ( in ) :: nf !! number of variables. integer , intent ( in ) :: n !! dimension of the constraint null space. integer , intent ( in ) :: nc !! number of constraints. integer , intent ( in ) :: ic ( * ) !! ic(nc)  vector containing types of constraints. integer , intent ( in ) :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. real ( wp ), intent ( in ) :: cf ( * ) !! cf(nc+1)  vector containing values of the constraints. real ( wp ), intent ( in ) :: cl ( * ) !! cl(nc)  vector containing lower bounds for constraint functions. real ( wp ), intent ( in ) :: cu ( * ) !! cu(nc)  vector containing upper bounds for constraint functions. real ( wp ), intent ( in ) :: cz ( * ) !! cz(nc)  vector of lagrange multipliers. real ( wp ), intent ( in ) :: rpf !! penalty coefficient. real ( wp ), intent ( out ) :: fc !! value of the penalty term. real ( wp ), intent ( out ) :: f !! value of the penalty function. real ( wp ) :: pom , temp integer :: j , kc fc = 0.0_wp do kc = 1 , nc if ( ic ( kc ) > 0 ) then pom = 0.0_wp temp = cf ( kc ) if ( ic ( kc ) == 1 . or . ic ( kc ) >= 3 ) pom = min ( pom , temp - cl ( kc )) if ( ic ( kc ) == 2 . or . ic ( kc ) >= 3 ) pom = min ( pom , cu ( kc ) - temp ) fc = fc + rpf * abs ( pom ) end if end do do j = 1 , nf - n kc = ica ( j ) if ( kc > 0 ) then pom = 0.0_wp temp = cf ( kc ) if ( ic ( kc ) == 1 . or . ic ( kc ) == 3 . or . ic ( kc ) == 5 ) & pom = min ( pom , temp - cl ( kc )) if ( ic ( kc ) == 2 . or . ic ( kc ) == 4 . or . ic ( kc ) == 6 ) & pom = max ( pom , temp - cu ( kc )) fc = fc - cz ( j ) * pom end if end do f = cf ( nc + 1 ) + fc end subroutine compute_augmented_lagrangian","tags":"","url":"proc/compute_augmented_lagrangian.html"},{"title":"compute_new_penalty_parameters – psqp","text":"private pure subroutine compute_new_penalty_parameters(nf, n, nc, ica, cz, cp) computation of the new penalty parameters. Note This routine was formerly called ppset2 . Arguments Type Intent Optional Attributes Name integer, intent(in) :: nf declared number of variables. integer, intent(in) :: n actual number of variables. integer, intent(in) :: nc number of constraints. integer, intent(in) :: ica (*) vector containing indices of active constraints. real(kind=wp), intent(in) :: cz (*) vector of lagrange multipliers. real(kind=wp), intent(inout) :: cp (*) vector containing penalty parameters. Called by proc~~compute_new_penalty_parameters~~CalledByGraph proc~compute_new_penalty_parameters compute_new_penalty_parameters proc~psqp psqp_class%psqp proc~psqp->proc~compute_new_penalty_parameters proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine compute_new_penalty_parameters ( nf , n , nc , ica , cz , cp ) integer , intent ( in ) :: nf !! declared number of variables. integer , intent ( in ) :: n !! actual number of variables. integer , intent ( in ) :: nc !! number of constraints. integer , intent ( in ) :: ica ( * ) !! vector containing indices of active constraints. real ( wp ), intent ( in ) :: cz ( * ) !! vector of lagrange multipliers. real ( wp ), intent ( inout ) :: cp ( * ) !! vector containing penalty parameters. real ( wp ) :: temp integer :: j , l , kc do kc = 1 , nc cp ( kc ) = 0.5_wp * cp ( kc ) end do do j = 1 , nf - n l = ica ( j ) if ( l > 0 ) then temp = abs ( cz ( j )) cp ( l ) = max ( temp , cp ( l ) + 0.5_wp * temp ) end if end do end subroutine compute_new_penalty_parameters","tags":"","url":"proc/compute_new_penalty_parameters.html"},{"title":"extended_line_search – psqp","text":"private  subroutine extended_line_search(me, r, ro, rp, f, fo, fp, po, pp, fmin, fmax, rmin, rmax, tols, kd, ld, nit, kit, nred, mred, maxst, iest, inits, iters, kters, mes, isys) extended line search without directional derivatives. Method safeguarded extrapolation and interpolation with extended termination\n criteria. Note This routine was formerly called ps0l02 . Type Bound psqp_class Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me real(kind=wp) :: r value of the stepsize parameter. real(kind=wp) :: ro initial value of the stepsize parameter. real(kind=wp) :: rp previous value of the stepsize parameter. real(kind=wp) :: f value of the objective function. real(kind=wp) :: fo initial value of the objective function. real(kind=wp) :: fp previous value of the objective function. real(kind=wp) :: po initial value of the directional derivative. real(kind=wp) :: pp previous value of the directional derivative. real(kind=wp) :: fmin lower bound for value of the objective function. real(kind=wp) :: fmax upper bound for value of the objective function. real(kind=wp) :: rmin minimum value of the stepsize parameter real(kind=wp) :: rmax maximum value of the stepsize parameter real(kind=wp) :: tols termination tolerance for line search\n(in test on the change of the function value). integer :: kd degree of required dervatives. integer :: ld degree of previously computed derivatives. integer :: nit actual number of iterations. integer :: kit number of the iteration after last restart. integer :: nred actual number of extrapolations or interpolations. integer :: mred maximum number of extrapolations or interpolations. integer :: maxst maximum stepsize indicator. maxst=0 or maxst=1\nif maximum stepsize was not or was reached. integer :: iest lower bound specification. iest=0 or iest=1\nif lower bound is not or is given. integer :: inits choice of the initial stepsize. inits=0 - initial stepsize is specified in the calling program. inits=1 - unit initial stepsize. inits=2 - combined unit and quadratically estimated initial stepsize. inits=3 - quadratically estimated initial stepsize. integer :: iters termination indicator. iters=0 - zero step. iters=1 - perfect line search. iters=2   goldstein stepsize. iters=3 - curry stepsize. iters=4 - extended curry stepsize. iters=5 - armijo stepsize. iters=6 - first stepsize. iters=7 - maximum stepsize. iters=8 - unbounded function. iters=-1 - mred reached. iters=-2 - positive directional derivative. iters=-3 - error in interpolation. integer :: kters termination selection. kters=1 - perfect line search. kters=2 - goldstein stepsize. kters=3 - curry stepsize. kters=4 - extended curry stepsize. kters=5 - armijo stepsize. kters=6 - first stepsize. integer :: mes method selection. mes=1 - bisection. mes=2 - quadratic interpolation (with one directional derivative). mes=3 - quadratic interpolation (with two directional derivatives). mes=4 - cubic interpolation. mes=5 - conic interpolation. integer :: isys control parameter. Calls proc~~extended_line_search~~CallsGraph proc~extended_line_search psqp_class%extended_line_search proc~line_search_interpolation line_search_interpolation proc~extended_line_search->proc~line_search_interpolation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~extended_line_search~~CalledByGraph proc~extended_line_search psqp_class%extended_line_search proc~psqp psqp_class%psqp proc~psqp->proc~extended_line_search proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine extended_line_search ( me , r , ro , rp , f , fo , fp , po , pp , fmin , fmax , & rmin , rmax , tols , kd , ld , nit , kit , nred , mred , maxst , iest , & inits , iters , kters , mes , isys ) class ( psqp_class ), intent ( inout ) :: me integer :: kd !! degree of required dervatives. integer :: ld !! degree of previously computed derivatives. integer :: nit !! actual number of iterations. integer :: kit !! number of the iteration after last restart. integer :: nred !! actual number of extrapolations or interpolations. integer :: mred !! maximum number of extrapolations or interpolations. integer :: maxst !! maximum stepsize indicator. maxst=0 or maxst=1 !! if maximum stepsize was not or was reached. integer :: iest !! lower bound specification. iest=0 or iest=1 !! if lower bound is not or is given. integer :: inits !! choice of the initial stepsize. !! !! * inits=0 - initial stepsize is specified in the calling program. !! * inits=1 - unit initial stepsize. !! * inits=2 - combined unit and quadratically estimated initial stepsize. !! * inits=3 - quadratically estimated initial stepsize. integer :: iters !! termination indicator. !! !! * iters=0 - zero step. !! * iters=1 - perfect line search. !! * iters=2   goldstein stepsize. !! * iters=3 - curry stepsize. !! * iters=4 - extended curry stepsize. !! * iters=5 - armijo stepsize. !! * iters=6 - first stepsize. !! * iters=7 - maximum stepsize. !! * iters=8 - unbounded function. !! * iters=-1 - mred reached. !! * iters=-2 - positive directional derivative. !! * iters=-3 - error in interpolation. integer :: kters !! termination selection. !! !! * kters=1 - perfect line search. !! * kters=2 - goldstein stepsize. !! * kters=3 - curry stepsize. !! * kters=4 - extended curry stepsize. !! * kters=5 - armijo stepsize. !! * kters=6 - first stepsize. integer :: mes !! method selection. !! !! * mes=1 - bisection. !! * mes=2 - quadratic interpolation (with one directional derivative). !! * mes=3 - quadratic interpolation (with two directional derivatives). !! * mes=4 - cubic interpolation. !! * mes=5 - conic interpolation. integer :: isys !! control parameter. real ( wp ) :: r !! value of the stepsize parameter. real ( wp ) :: ro !! initial value of the stepsize parameter. real ( wp ) :: rp !! previous value of the stepsize parameter. real ( wp ) :: f !! value of the objective function. real ( wp ) :: fo !! initial value of the objective function. real ( wp ) :: fp !! previous value of the objective function. real ( wp ) :: po !! initial value of the directional derivative. real ( wp ) :: pp !! previous value of the directional derivative. real ( wp ) :: fmin !! lower bound for value of the objective function. real ( wp ) :: fmax !! upper bound for value of the objective function. real ( wp ) :: rmin !! minimum value of the stepsize parameter real ( wp ) :: rmax !! maximum value of the stepsize parameter real ( wp ) :: tols !! termination tolerance for line search !! (in test on the change of the function value). real ( wp ) :: rtemp integer :: merr , init1 logical :: l1 , l2 , l3 , l4 , l6 , l7 real ( wp ), parameter :: tol = 1.0d-4 if ( isys /= 1 ) then ! go to (1,3) isys+1 me % mes1 = 2 me % mes2 = 2 iters = 0 if ( po >= 0.0_wp ) then r = 0.0_wp iters = - 2 isys = 0 return end if if ( rmax <= 0.0_wp ) then iters = 0 isys = 0 return end if ! initial stepsize selection if ( inits > 0 ) then rtemp = fmin - f elseif ( iest == 0 ) then rtemp = f - fp else rtemp = max ( f - fp , 1 0.0_wp * ( fmin - f )) end if init1 = abs ( inits ) rp = 0.0_wp fp = fo pp = po if ( init1 == 0 ) then elseif ( init1 == 1 . or . inits >= 1 . and . iest == 0 ) then r = 1.0_wp elseif ( init1 == 2 ) then r = min ( 1.0_wp , 4.0_wp * rtemp / po ) elseif ( init1 == 3 ) then r = min ( 1.0_wp , 2.0_wp * rtemp / po ) elseif ( init1 == 4 ) then r = 2.0_wp * rtemp / po end if rtemp = r r = max ( r , rmin ) r = min ( r , rmax ) me % mode = 0 me % rl = 0.0_wp me % fl = fo me % ru = 0.0_wp me % fu = fo me % ri = 0.0_wp me % fi = fo elseif ( iters /= 0 ) then isys = 0 return else if ( f <= fmin ) then iters = 7 isys = 0 return else l1 = r <= rmin . and . nit /= kit l2 = r >= rmax l3 = f - fo <= tols * r * po . or . f - fmin <= ( fo - fmin ) / 1 0.0_wp l4 = f - fo >= ( 1.0_wp - tols ) * r * po . or . me % mes2 == 2 . and . me % mode == 2 l6 = me % ru - me % rl <= tol * me % ru . and . me % mode == 2 l7 = me % mes2 <= 2 . or . me % mode /= 0 maxst = 0 if ( l2 ) maxst = 1 end if ! test on termination if ( l1 . and . . not . l3 ) then iters = 0 isys = 0 return elseif ( l2 . and . . not . f >= me % fu ) then iters = 7 isys = 0 return elseif ( l6 ) then iters = 1 isys = 0 return elseif ( l3 . and . l7 . and . kters == 5 ) then iters = 5 isys = 0 return elseif ( l3 . and . l4 . and . l7 . and . & ( kters == 2 . or . kters == 3 . or . kters == 4 )) then iters = 2 isys = 0 return elseif ( kters < 0 . or . kters == 6 . and . l7 ) then iters = 6 isys = 0 return elseif ( abs ( nred ) >= mred ) then iters = - 1 isys = 0 return else rp = r fp = f me % mode = max ( me % mode , 1 ) me % mtyp = abs ( mes ) if ( f >= fmax ) me % mtyp = 1 end if if ( me % mode == 1 ) then ! interval change after extrapolation me % rl = me % ri me % fl = me % fi me % ri = me % ru me % fi = me % fu me % ru = r me % fu = f if ( f >= me % fi ) then nred = 0 me % mode = 2 elseif ( me % mes1 == 1 ) then me % mtyp = 1 end if ! interval change after interpolation elseif ( r <= me % ri ) then if ( f <= me % fi ) then me % ru = me % ri me % fu = me % fi me % ri = r me % fi = f else me % rl = r me % fl = f end if elseif ( f <= me % fi ) then me % rl = me % ri me % fl = me % fi me % ri = r me % fi = f else me % ru = r me % fu = f end if end if ! new stepsize selection (extrapolation or interpolation) call line_search_interpolation ( ro , me % rl , me % ru , me % ri , fo , me % fl , me % fu , & me % fi , po , r , me % mode , me % mtyp , merr ) if ( merr > 0 ) then iters = - merr isys = 0 return elseif ( me % mode == 1 ) then nred = nred - 1 r = min ( r , rmax ) elseif ( me % mode == 2 ) then nred = nred + 1 end if ! computation of the new function value kd = 0 ld = - 1 isys = 1 end subroutine extended_line_search","tags":"","url":"proc/extended_line_search.html"},{"title":"bfgs_variable_metric_update – psqp","text":"private  subroutine bfgs_variable_metric_update(n, h, g, s, xo, go, r, po, nit, kit, iterh, met, met1, mec) variable metric update of a dense symmetric positive definite matrix\n using the factorization b=l d trans(l). Method bfgs variable metric method. Note This routine was formerly called pudbg1 . Arguments Type Intent Optional Attributes Name integer :: n actual number of variables. real(kind=wp) :: h (*) h(m)  factorization b=l d trans(l) of a positive\ndefinite approximation of the hessian matrix. real(kind=wp) :: g (*) g(nf)  gradient of the objective function. real(kind=wp) :: s (*) s(nf)  auxiliary vector. real(kind=wp) :: xo (*) xo(nf)  vectors of variables difference. real(kind=wp) :: go (*) go(nf)  gradients difference. real(kind=wp) :: r value of the stepsize parameter. real(kind=wp) :: po old value of the directional derivative. integer :: nit actual number of iterations. integer :: kit number of the iteration after last restart. integer :: iterh termination indicator. iterh<0-bad decomposition. iterh=0-successful update. iterh>0-nonpositive parameters. integer :: met integer :: met1 selection of self scaling. met1=1-self scaling suppressed. met1=2 initial self scaling. integer :: mec correction if the negative curvature occurs. mec=1-correction suppressed. mec=2-powell's correction. Calls proc~~bfgs_variable_metric_update~~CallsGraph proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~mxdpgb mxdpgb proc~bfgs_variable_metric_update->proc~mxdpgb proc~mxdpgp mxdpgp proc~bfgs_variable_metric_update->proc~mxdpgp proc~mxdpgs mxdpgs proc~bfgs_variable_metric_update->proc~mxdpgs proc~mxdpgu mxdpgu proc~bfgs_variable_metric_update->proc~mxdpgu proc~mxvcop mxvcop proc~bfgs_variable_metric_update->proc~mxvcop proc~mxvdif mxvdif proc~bfgs_variable_metric_update->proc~mxvdif proc~mxvdir mxvdir proc~bfgs_variable_metric_update->proc~mxvdir proc~mxvdot mxvdot proc~bfgs_variable_metric_update->proc~mxvdot proc~mxvscl mxvscl proc~bfgs_variable_metric_update->proc~mxvscl proc~mxdpgu->proc~mxvscl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~bfgs_variable_metric_update~~CalledByGraph proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~psqp psqp_class%psqp proc~psqp->proc~bfgs_variable_metric_update proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine bfgs_variable_metric_update ( n , h , g , s , xo , go , r , po , nit , & kit , iterh , met , met1 , mec ) real ( wp ) :: po !! old value of the directional derivative. real ( wp ) :: r !! value of the stepsize parameter. integer :: iterh !! termination indicator. !! !! * iterh<0-bad decomposition. !! * iterh=0-successful update. !! * iterh>0-nonpositive parameters. integer :: kit !! number of the iteration after last restart. integer :: met !! integer :: met1 !! selection of self scaling. !! !! * met1=1-self scaling suppressed. !! * met1=2 initial self scaling. integer :: mec !! correction if the negative curvature occurs. !! !! * mec=1-correction suppressed. !! * mec=2-powell's correction. integer :: n !! actual number of variables. integer :: nit !! actual number of iterations. real ( wp ) :: g ( * ) !! g(nf)  gradient of the objective function. real ( wp ) :: go ( * ) !! go(nf)  gradients difference. real ( wp ) :: h ( * ) !! h(m)  factorization b=l*d*trans(l) of a positive !! definite approximation of the hessian matrix. real ( wp ) :: s ( * ) !! s(nf)  auxiliary vector. real ( wp ) :: xo ( * ) !! xo(nf)  vectors of variables difference. real ( wp ) :: a , b , c , gam , par , den , dis logical :: l1 , l3 l1 = met1 >= 3 . or . met1 == 2 . and . nit == kit l3 = . not . l1 ! determination of the parameters b, c b = mxvdot ( n , xo , go ) a = 0.0_wp if ( l1 ) then call mxvcop ( n , go , s ) call mxdpgb ( n , h , s , 1 ) a = mxdpgp ( n , h , s , s ) if ( a <= 0.0_wp ) then iterh = 1 return end if end if call mxvdif ( n , go , g , s ) call mxvscl ( n , r , s , s ) c = - r * po if ( c <= 0.0_wp ) then iterh = 3 return end if if ( mec > 1 ) then if ( b <= 1.0e-4_wp * c ) then ! powell's correction dis = ( 1.0_wp - 0.1_wp ) * c / ( c - b ) call mxvdif ( n , go , s , go ) call mxvdir ( n , dis , go , s , go ) b = c + dis * ( b - c ) if ( l1 ) a = c + 2.0_wp * ( 1.0_wp - dis ) * ( b - c ) + dis * dis * ( a - c ) end if elseif ( b <= 1.0e-4_wp * c ) then iterh = 2 return end if if ( l1 ) then ! determination of the parameter gam (self scaling) if ( met == 1 ) then par = c / b elseif ( a <= 0.0_wp ) then par = c / b else par = sqrt ( c / a ) end if gam = par if ( met1 > 1 ) then if ( nit /= kit ) l3 = gam < 0.5_wp . or . gam > 4.0_wp end if end if if ( l3 ) then gam = 1.0_wp par = gam end if if ( met == 1 ) then ! bfgs update call mxdpgu ( n , h , par / b , go , xo ) call mxdpgu ( n , h , - 1.0_wp / c , s , xo ) else ! hoshino update den = par * b + c dis = 0.5_wp * b call mxvdir ( n , par , go , s , s ) call mxdpgu ( n , h , par / dis , go , xo ) call mxdpgu ( n , h , - 1.0_wp / den , s , xo ) end if iterh = 0 if ( gam == 1.0_wp ) return call mxdpgs ( n , h , 1.0_wp / gam ) end subroutine bfgs_variable_metric_update","tags":"","url":"proc/bfgs_variable_metric_update.html"},{"title":"dual_range_space_qp – psqp","text":"private  subroutine dual_range_space_qp(nf, n, x, xo, ica, cg, cz, g, go, r, f, fo, p, po, cmax, cmaxo, dmax, kd, ld, iters) dual range space quadratic programming method for minimax\n approximation. Note This routine was formerly called pytrnd . Arguments Type Intent Optional Attributes Name integer, intent(in) :: nf declared number of variables. integer, intent(inout) :: n actual number of variables. real(kind=wp) :: x (*) x(nf)  vector of variables. real(kind=wp) :: xo (*) xo(nf)  saved vector of variables. integer, intent(in) :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals of the linear constraints. real(kind=wp) :: cz (*) cz(nf)  vector of lagrange multipliers. real(kind=wp) :: g (*) g(nf)  gradient of the lagrangian function. real(kind=wp) :: go (*) go(nf)  saved gradient of the lagrangian function. real(kind=wp) :: r value of the stepsize parameter. real(kind=wp) :: f new value of the objective function. real(kind=wp) :: fo old value of the objective function. real(kind=wp) :: p new value of the directional derivative. real(kind=wp) :: po old value of the directional derivative. real(kind=wp) :: cmax value of the constraint violation. real(kind=wp) :: cmaxo saved value of the constraint violation. real(kind=wp), intent(out) :: dmax maximum relative difference of variables. integer :: kd integer :: ld integer :: iters termination indicator for steplength determination.\niters=0 for zero step. Calls proc~~dual_range_space_qp~~CallsGraph proc~dual_range_space_qp dual_range_space_qp proc~mxvdif mxvdif proc~dual_range_space_qp->proc~mxvdif proc~mxvdir mxvdir proc~dual_range_space_qp->proc~mxvdir proc~mxvsav mxvsav proc~dual_range_space_qp->proc~mxvsav Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dual_range_space_qp~~CalledByGraph proc~dual_range_space_qp dual_range_space_qp proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_qp proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dual_range_space_qp ( nf , n , x , xo , ica , cg , cz , g , go , r , f , fo , & p , po , cmax , cmaxo , dmax , kd , ld , iters ) integer , intent ( in ) :: nf !! declared number of variables. integer , intent ( inout ) :: n !! actual number of variables. integer , intent ( in ) :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. real ( wp ) :: x ( * ) !! x(nf)  vector of variables. real ( wp ) :: xo ( * ) !! xo(nf)  saved vector of variables. real ( wp ) :: cg ( * ) !! cg(nf*nc)  matrix whose columns are normals of the linear constraints. real ( wp ) :: cz ( * ) !! cz(nf)  vector of lagrange multipliers. real ( wp ) :: g ( * ) !! g(nf)  gradient of the lagrangian function. real ( wp ) :: go ( * ) !! go(nf)  saved gradient of the lagrangian function. real ( wp ) :: r !! value of the stepsize parameter. real ( wp ) :: f !! new value of the objective function. real ( wp ) :: fo !! old value of the objective function. real ( wp ) :: p !! new value of the directional derivative. real ( wp ) :: po !! old value of the directional derivative. real ( wp ) :: cmax !! value of the constraint violation. real ( wp ) :: cmaxo !! saved value of the constraint violation. real ( wp ), intent ( out ) :: dmax !! maximum relative difference of variables. integer :: kd !! integer :: ld !! integer :: iters !! termination indicator for steplength determination. !! iters=0 for zero step. integer :: i , j , l do j = 1 , nf - n l = ica ( j ) if ( l > 0 ) then call mxvdir ( nf , - cz ( j ), cg (( l - 1 ) * nf + 1 ), g , g ) else l = - l g ( l ) = g ( l ) - cz ( j ) end if end do if ( iters > 0 ) then call mxvdif ( nf , x , xo , xo ) call mxvdif ( nf , g , go , go ) po = r * po p = r * p else f = fo p = po cmax = cmaxo call mxvsav ( nf , x , xo ) call mxvsav ( nf , g , go ) ld = kd end if dmax = 0.0_wp do i = 1 , nf dmax = max ( dmax , abs ( xo ( i )) / max ( abs ( x ( i )), 1.0_wp )) end do n = nf end subroutine dual_range_space_qp","tags":"","url":"proc/dual_range_space_qp.html"},{"title":"mxdpgp – psqp","text":"public pure function mxdpgp(n, a, x, y) computation of the number mxdpgp=trans(x)*d**(-1)*y where d is a\ndiagonal matrix in the factorization a+e=l*d*trans(l) obtained by the\nsubroutine mxdpgf . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(in) :: a (*) a(n*(n+1)/2) factorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . real(kind=wp), intent(in) :: x (*) input vector. real(kind=wp), intent(in) :: y (*) input vector. Return Value real(kind=wp) computed number mxdpgp=trans(x)*d**(-1)*y . Called by proc~~mxdpgp~~CalledByGraph proc~mxdpgp mxdpgp proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~bfgs_variable_metric_update->proc~mxdpgp proc~psqp psqp_class%psqp proc~psqp->proc~bfgs_variable_metric_update proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function mxdpgp ( n , a , x , y ) integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: a ( * ) !! `a(n*(n+1)/2)` factorization `a+e=l*d*trans(l)` !! obtained by the subroutine [[mxdpgf]]. real ( wp ), intent ( in ) :: x ( * ) !! input vector. real ( wp ), intent ( in ) :: y ( * ) !! input vector. real ( wp ) :: mxdpgp !! computed number `mxdpgp=trans(x)*d**(-1)*y`. real ( wp ) :: temp integer :: i , j j = 0 temp = 0.0_wp do i = 1 , n j = j + i temp = temp + x ( i ) * y ( i ) / a ( j ) end do mxdpgp = temp end function mxdpgp","tags":"","url":"proc/mxdpgp.html"},{"title":"mxvdot – psqp","text":"public pure function mxvdot(n, x, y) dot product of two vectors. JW: rewrote this routine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(in) :: y (*) y(n)  input vector. Return Value real(kind=wp) value of dot product mxvdot=trans(x)*y . Called by proc~~mxvdot~~CalledByGraph proc~mxvdot mxvdot proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~bfgs_variable_metric_update->proc~mxvdot proc~determine_new_active_linear_constr determine_new_active_linear_constr proc~determine_new_active_linear_constr->proc~mxvdot proc~psqp psqp_class%psqp proc~psqp->proc~mxvdot proc~psqp->proc~bfgs_variable_metric_update proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~psqp->proc~dual_range_space_quad_prog proc~update_tri_decomp_general update_tri_decomp_general proc~update_tri_decomp_general->proc~mxvdot proc~dual_range_space_quad_prog->proc~determine_new_active_linear_constr proc~dual_range_space_quad_prog->proc~update_tri_decomp_general proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function mxvdot ( n , x , y ) integer , intent ( in ) :: n !!vector dimension. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( in ) :: y ( * ) !! y(n)  input vector. real ( wp ) :: mxvdot !! value of dot product `mxvdot=trans(x)*y`. mxvdot = dot_product ( x ( 1 : n ), y ( 1 : n )) end function mxvdot","tags":"","url":"proc/mxvdot.html"},{"title":"mxvmax – psqp","text":"public pure function mxvmax(n, x) l-infinity norm of a vector. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: x (*) x(n)  input vector. Return Value real(kind=wp) l-infinity norm of the vector x. Called by proc~~mxvmax~~CalledByGraph proc~mxvmax mxvmax proc~psqp psqp_class%psqp proc~psqp->proc~mxvmax proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function mxvmax ( n , x ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ) :: mxvmax !! l-infinity norm of the vector x. integer :: i mxvmax = 0.0_wp do i = 1 , n mxvmax = max ( mxvmax , abs ( x ( i ))) end do end function mxvmax","tags":"","url":"proc/mxvmax.html"},{"title":"mxdpgb – psqp","text":"public pure subroutine mxdpgb(n, a, x, job) solution of a system of linear equations with a dense symmetric\n positive definite matrix a+e using the factorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . Method back substitution Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(in) :: a (*) a(n*(n+1)/2) factorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . real(kind=wp), intent(inout) :: x (*) x(n)  on input the right hand side of a\nsystem of linear equations. on output the\nsolution of a system of linear equations. integer, intent(in) :: job option if job=0 then x:=(a+e)**(-1)*x . if job>0 then x:=l**(-1)*x . if job<0 then x:=trans(l)**(-1)*x . Called by proc~~mxdpgb~~CalledByGraph proc~mxdpgb mxdpgb proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~bfgs_variable_metric_update->proc~mxdpgb proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~mxdpgb proc~update_tri_decomp_general update_tri_decomp_general proc~dual_range_space_quad_prog->proc~update_tri_decomp_general proc~update_tri_decomp_general->proc~mxdpgb proc~psqp psqp_class%psqp proc~psqp->proc~bfgs_variable_metric_update proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxdpgb ( n , a , x , job ) integer , intent ( in ) :: job !! option !! !! * if `job=0` then `x:=(a+e)**(-1)*x`. !! * if `job>0` then `x:=l**(-1)*x`. !! * if `job<0` then `x:=trans(l)**(-1)*x`. integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: a ( * ) !! `a(n*(n+1)/2)` factorization `a+e=l*d*trans(l)` !! obtained by the subroutine [[mxdpgf]]. real ( wp ), intent ( inout ) :: x ( * ) !! x(n)  on input the right hand side of a !! system of linear equations. on output the !! solution of a system of linear equations. integer :: i , ii , ij , j if ( job >= 0 ) then ! phase 1 : x:=l**(-1)*x ij = 0 do i = 1 , n do j = 1 , i - 1 ij = ij + 1 x ( i ) = x ( i ) - a ( ij ) * x ( j ) end do ij = ij + 1 end do endif if ( job == 0 ) then ! phase 2 : x:=d**(-1)*x ii = 0 do i = 1 , n ii = ii + i x ( i ) = x ( i ) / a ( ii ) end do endif if ( job <= 0 ) then ! phase 3 : x:=trans(l)**(-1)*x ii = n * ( n - 1 ) / 2 do i = n - 1 , 1 , - 1 ij = ii do j = i + 1 , n ij = ij + j - 1 x ( i ) = x ( i ) - a ( ij ) * x ( j ) end do ii = ii - i end do endif end subroutine mxdpgb","tags":"","url":"proc/mxdpgb.html"},{"title":"mxdpgf – psqp","text":"public pure subroutine mxdpgf(n, a, inf, alf, tau) factorization a+e=l*d*trans(l) of a dense symmetric positive definite\n matrix a+e where d and e are diagonal positive definite matrices and\n l is a lower triangular matrix. if a is sufficiently positive\n definite then e=0. Method p.e.gill, w.murray : newton type methods for unconstrained and\n    linearly constrained optimization, math. programming 28 (1974)\n    pp. 311-350. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(inout) :: a (*) a(n*(n+1)/2) on input a given dense symmetric (usually positive\ndefinite) matrix a stored in the packed form. on output the\ncomputed factorization a+e=l*d*trans(l) . integer, intent(out) :: inf an information obtained in the factorization process. if: inf=0 then a is sufficiently positive definite and e=0. if inf<0 then a is not sufficiently positive definite and e>0. if inf>0 then a is indefinite and inf is an index of the\n   most negative diagonal element used in the factorization\n   process. real(kind=wp), intent(inout) :: alf on input a desired tolerance for positive definiteness. on\noutput the most negative diagonal element used in the\nfactorization process (if inf>0). real(kind=wp), intent(out) :: tau maximum diagonal element of the matrix e. Called by proc~~mxdpgf~~CalledByGraph proc~mxdpgf mxdpgf proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~mxdpgf proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxdpgf ( n , a , inf , alf , tau ) real ( wp ), intent ( inout ) :: alf !! on input a desired tolerance for positive definiteness. on !! output the most negative diagonal element used in the !! factorization process (if inf>0). real ( wp ), intent ( out ) :: tau !! maximum diagonal element of the matrix e. integer , intent ( out ) :: inf !! an information obtained in the factorization process. if: !! !!  * `inf=0` then a is sufficiently positive definite and e=0. if !!  * `inf<0` then a is not sufficiently positive definite and e>0. if !!  * `inf>0` then a is indefinite and inf is an index of the !!    most negative diagonal element used in the factorization !!    process. integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( inout ) :: a ( * ) !! `a(n*(n+1)/2)`  on input a given dense symmetric (usually positive !! definite) matrix a stored in the packed form. on output the !! computed factorization `a+e=l*d*trans(l)`. real ( wp ) :: bet , del , gam , rho , sig , tol integer :: i , ij , ik , j , k , kj , kk , l l = 0 inf = 0 tol = alf ! estimation of the matrix norm alf = 0.0_wp bet = 0.0_wp gam = 0.0_wp tau = 0.0_wp kk = 0 do k = 1 , n kk = kk + k bet = max ( bet , abs ( a ( kk ))) kj = kk do j = k + 1 , n kj = kj + j - 1 gam = max ( gam , abs ( a ( kj ))) end do end do bet = max ( tol , bet , gam / n ) ! del = tol*bet del = tol * max ( bet , 1.0_wp ) kk = 0 do k = 1 , n kk = kk + k ! determination of a diagonal correction sig = a ( kk ) if ( alf > sig ) then alf = sig l = k endif gam = 0.0_wp kj = kk do j = k + 1 , n kj = kj + j - 1 gam = max ( gam , abs ( a ( kj ))) end do gam = gam * gam rho = max ( abs ( sig ), gam / bet , del ) if ( tau < rho - sig ) then tau = rho - sig inf = - 1 endif ! gaussian elimination a ( kk ) = rho kj = kk do j = k + 1 , n kj = kj + j - 1 gam = a ( kj ) a ( kj ) = gam / rho ik = kk ij = kj do i = k + 1 , j ik = ik + i - 1 ij = ij + 1 a ( ij ) = a ( ij ) - a ( ik ) * gam end do end do end do if ( l > 0 . and . abs ( alf ) > del ) inf = l end subroutine mxdpgf","tags":"","url":"proc/mxdpgf.html"},{"title":"mxdpgs – psqp","text":"public pure subroutine mxdpgs(n, a, alf) scaling of a dense symmetric positive definite matrix a+e using the\nfactorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(inout) :: a (*) a(n*(n+1)/2) factorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . real(kind=wp), intent(in) :: alf scaling factor. Called by proc~~mxdpgs~~CalledByGraph proc~mxdpgs mxdpgs proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~bfgs_variable_metric_update->proc~mxdpgs proc~psqp psqp_class%psqp proc~psqp->proc~bfgs_variable_metric_update proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxdpgs ( n , a , alf ) real ( wp ), intent ( in ) :: alf !! scaling factor. integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( inout ) :: a ( * ) !! `a(n*(n+1)/2)` factorization `a+e=l*d*trans(l)` !! obtained by the subroutine [[mxdpgf]]. integer :: i , j j = 0 do i = 1 , n j = j + i a ( j ) = a ( j ) * alf end do end subroutine mxdpgs","tags":"","url":"proc/mxdpgs.html"},{"title":"mxdpgu – psqp","text":"public pure subroutine mxdpgu(n, a, alf, x, y) correction of a dense symmetric positive definite matrix a+e in the\n factored form a+e=l*d*trans(l) obtained by the subroutine mxdpgf .\n the correction is defined as a+e:=a+e+alf*x*trans(x) where alf is a\n given scaling factor and x is a given vector. Method p.e.gill, w.murray, m.saunders: methods for computing and modifying\n    the ldv factors of a matrix, math. of comp. 29 (1974) pp. 1051-1077. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(inout) :: a (*) a(n*(n+1)/2) factorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . real(kind=wp), intent(in) :: alf scaling factor in the correction term. real(kind=wp), intent(in) :: x (*) vector in the correction term. real(kind=wp), intent(out) :: y (*) auxiliary vector. Calls proc~~mxdpgu~~CallsGraph proc~mxdpgu mxdpgu proc~mxvscl mxvscl proc~mxdpgu->proc~mxvscl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mxdpgu~~CalledByGraph proc~mxdpgu mxdpgu proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~bfgs_variable_metric_update->proc~mxdpgu proc~psqp psqp_class%psqp proc~psqp->proc~bfgs_variable_metric_update proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxdpgu ( n , a , alf , x , y ) integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: alf !! scaling factor in the correction term. real ( wp ), intent ( inout ) :: a ( * ) !! `a(n*(n+1)/2)` factorization `a+e=l*d*trans(l)` !! obtained by the subroutine [[mxdpgf]]. real ( wp ), intent ( in ) :: x ( * ) !! vector in the correction term. real ( wp ), intent ( out ) :: y ( * ) !! auxiliary vector. real ( wp ) :: alfr real ( wp ) :: b , d , p , r , t , to integer :: i , ii , ij , j real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: four = 4.0_wp real ( wp ), parameter :: con = 1.0e-8_wp if ( alf >= zero ) then ! forward correction in case when the scaling factor is nonnegative alfr = sqrt ( alf ) call mxvscl ( n , alfr , x , y ) to = one ii = 0 do i = 1 , n ii = ii + i d = a ( ii ) p = y ( i ) t = to + p * p / d r = to / t a ( ii ) = d / r b = p / ( d * t ) if ( a ( ii ) <= four * d ) then ! an easy formula for limited diagonal element ij = ii do j = i + 1 , n ij = ij + j - 1 d = a ( ij ) y ( j ) = y ( j ) - p * d a ( ij ) = d + b * y ( j ) end do else ! a more complicate but numerically stable formula for unlimited ! diagonal element ij = ii do j = i + 1 , n ij = ij + j - 1 d = a ( ij ) a ( ij ) = r * d + b * y ( j ) y ( j ) = y ( j ) - p * d end do endif to = t end do else ! backward correction in case when the scaling factor is negative alfr = sqrt ( - alf ) call mxvscl ( n , alfr , x , y ) to = one ij = 0 do i = 1 , n d = y ( i ) do j = 1 , i - 1 ij = ij + 1 d = d - a ( ij ) * y ( j ) end do y ( i ) = d ij = ij + 1 to = to - d * d / a ( ij ) end do if ( to <= zero ) to = con ii = n * ( n + 1 ) / 2 do i = n , 1 , - 1 d = a ( ii ) p = y ( i ) t = to + p * p / d a ( ii ) = d * to / t b = - p / ( d * to ) to = t ij = ii do j = i + 1 , n ij = ij + j - 1 d = a ( ij ) a ( ij ) = d + b * y ( j ) y ( j ) = y ( j ) + p * d end do ii = ii - i end do endif end subroutine mxdpgu","tags":"","url":"proc/mxdpgu.html"},{"title":"mxdprb – psqp","text":"public pure subroutine mxdprb(n, a, x, job) solution of a system of linear equations with a dense symmetric\n positive definite matrix a using the factorization a=trans(r)*r. Method back substitution Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(in) :: a (*) a(n (n+1)/2) factorization a=trans(r) r. real(kind=wp), intent(inout) :: x (*) x(n)  on input the right hand side of a system of linear\nequations. on output the solution of a system of linear\nequations. integer, intent(in) :: job option if job=0 then x:=a* (-1) x. if job>0 then x:=trans(r)* (-1) x. if job<0 then x:=r* (-1) x. Called by proc~~mxdprb~~CalledByGraph proc~mxdprb mxdprb proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~mxdprb proc~update_tri_decomp_general update_tri_decomp_general proc~dual_range_space_quad_prog->proc~update_tri_decomp_general proc~update_tri_decomp_general->proc~mxdprb proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxdprb ( n , a , x , job ) integer , intent ( in ) :: job !! option !! !! * if job=0 then x:=a**(-1)*x. !! * if job>0 then x:=trans(r)**(-1)*x. !! * if job<0 then x:=r**(-1)*x. integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: a ( * ) !! a(n*(n+1)/2) factorization a=trans(r)*r. real ( wp ), intent ( inout ) :: x ( * ) !! x(n)  on input the right hand side of a system of linear !! equations. on output the solution of a system of linear !! equations. integer :: i , ii , ij , j if ( job >= 0 ) then ! phase 1 : x:=trans(r)**(-1)*x ij = 0 do i = 1 , n do j = 1 , i - 1 ij = ij + 1 x ( i ) = x ( i ) - a ( ij ) * x ( j ) end do ij = ij + 1 x ( i ) = x ( i ) / a ( ij ) end do endif if ( job <= 0 ) then ! phase 2 : x:=r**(-1)*x ii = n * ( n + 1 ) / 2 do i = n , 1 , - 1 ij = ii do j = i + 1 , n ij = ij + j - 1 x ( i ) = x ( i ) - a ( ij ) * x ( j ) end do x ( i ) = x ( i ) / a ( ii ) ii = ii - i end do endif end subroutine mxdprb","tags":"","url":"proc/mxdprb.html"},{"title":"mxdsmi – psqp","text":"public pure subroutine mxdsmi(n, a) dense symmetric matrix a is set to the unit matrix with the same\norder. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(out) :: a (*) a(n*(n+1)/2) dense symmetric matrix\nstored in the packed form which is set\nto the unit matrix (i.e. a:=i ). Called by proc~~mxdsmi~~CalledByGraph proc~mxdsmi mxdsmi proc~psqp psqp_class%psqp proc~psqp->proc~mxdsmi proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxdsmi ( n , a ) integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( out ) :: a ( * ) !! `a(n*(n+1)/2)`  dense symmetric matrix !! stored in the packed form which is set !! to the unit matrix (i.e. `a:=i`). integer :: i , m m = n * ( n + 1 ) / 2 do i = 1 , m a ( i ) = 0.0_wp end do m = 0 do i = 1 , n m = m + i a ( m ) = 1.0_wp end do end subroutine mxdsmi","tags":"","url":"proc/mxdsmi.html"},{"title":"mxdsmm – psqp","text":"public pure subroutine mxdsmm(n, a, x, y) multiplication of a dense symmetric matrix a by a vector x. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(in) :: a (*) a(n*(n+1)/2) dense symmetric matrix stored in the packed form. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(out) :: y (*) y(n)  output vector equal to a*x . Called by proc~~mxdsmm~~CalledByGraph proc~mxdsmm mxdsmm proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~mxdsmm proc~update_tri_decomp_general update_tri_decomp_general proc~dual_range_space_quad_prog->proc~update_tri_decomp_general proc~update_tri_decomp_general->proc~mxdsmm proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxdsmm ( n , a , x , y ) integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: a ( * ) !! `a(n*(n+1)/2)`  dense symmetric matrix stored in the packed form. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( out ) :: y ( * ) !! y(n)  output vector equal to ` a*x`. real ( wp ) :: temp integer :: i , j , k , l k = 0 do i = 1 , n temp = 0.0_wp l = k do j = 1 , i l = l + 1 temp = temp + a ( l ) * x ( j ) end do do j = i + 1 , n l = l + j - 1 temp = temp + a ( l ) * x ( j ) end do y ( i ) = temp k = k + i end do end subroutine mxdsmm","tags":"","url":"proc/mxdsmm.html"},{"title":"mxdsmv – psqp","text":"public pure subroutine mxdsmv(n, a, x, k) k-th row of a dense symmetric matrix a is copied to the vector x. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(in) :: a (*) a(n*(n+1)/2) dense symmetric matrix\nstored in the packed form. real(kind=wp), intent(out) :: x (*) x(n)  output vector. integer, intent(in) :: k index of copied row. Called by proc~~mxdsmv~~CalledByGraph proc~mxdsmv mxdsmv proc~update_tri_decomp_general update_tri_decomp_general proc~update_tri_decomp_general->proc~mxdsmv proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~update_tri_decomp_general proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxdsmv ( n , a , x , k ) integer , intent ( in ) :: k !! index of copied row. integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: a ( * ) !! `a(n*(n+1)/2)`  dense symmetric matrix !! stored in the packed form. real ( wp ), intent ( out ) :: x ( * ) !! x(n)  output vector. integer :: i , l l = k * ( k - 1 ) / 2 do i = 1 , n if ( i <= k ) then l = l + 1 else l = l + i - 1 endif x ( i ) = a ( l ) end do end subroutine mxdsmv","tags":"","url":"proc/mxdsmv.html"},{"title":"mxvcop – psqp","text":"public pure subroutine mxvcop(n, x, y) copying of a vector. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(out) :: y (*) y(n)  output vector where y:= x . Called by proc~~mxvcop~~CalledByGraph proc~mxvcop mxvcop proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~bfgs_variable_metric_update->proc~mxvcop proc~compute_con_and_dcon psqp_class%compute_con_and_dcon proc~compute_con_and_dcon->proc~mxvcop proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~mxvcop proc~update_tri_decomp_general update_tri_decomp_general proc~dual_range_space_quad_prog->proc~update_tri_decomp_general proc~ops_after_constr_deletion psqp_class%ops_after_constr_deletion proc~dual_range_space_quad_prog->proc~ops_after_constr_deletion proc~psqp psqp_class%psqp proc~psqp->proc~mxvcop proc~psqp->proc~bfgs_variable_metric_update proc~psqp->proc~compute_con_and_dcon proc~psqp->proc~dual_range_space_quad_prog proc~update_tri_decomp_general->proc~mxvcop proc~update_tri_decomp_orthogonal update_tri_decomp_orthogonal proc~update_tri_decomp_orthogonal->proc~mxvcop proc~ops_after_constr_deletion->proc~update_tri_decomp_orthogonal proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxvcop ( n , x , y ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( out ) :: y ( * ) !! y(n)  output vector where `y:= x`. integer :: i do i = 1 , n y ( i ) = x ( i ) end do end subroutine mxvcop","tags":"","url":"proc/mxvcop.html"},{"title":"mxvdif – psqp","text":"public pure subroutine mxvdif(n, x, y, z) vector difference. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(in) :: y (*) y(n)  input vector. real(kind=wp), intent(out) :: z (*) z(n)  output vector where z:= x - y . Called by proc~~mxvdif~~CalledByGraph proc~mxvdif mxvdif proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~bfgs_variable_metric_update->proc~mxvdif proc~dual_range_space_qp dual_range_space_qp proc~dual_range_space_qp->proc~mxvdif proc~psqp psqp_class%psqp proc~psqp->proc~bfgs_variable_metric_update proc~psqp->proc~dual_range_space_qp proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxvdif ( n , x , y , z ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( in ) :: y ( * ) !! y(n)  input vector. real ( wp ), intent ( out ) :: z ( * ) !! z(n)  output vector where `z:= x - y`. integer :: i do i = 1 , n z ( i ) = x ( i ) - y ( i ) end do end subroutine mxvdif","tags":"","url":"proc/mxvdif.html"},{"title":"mxvdir – psqp","text":"public pure subroutine mxvdir(n, a, x, y, z) vector augmented by the scaled vector. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: a scaling factor. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(in) :: y (*) y(n)  input vector. real(kind=wp), intent(out) :: z (*) z(n)  output vector where z:= y + a*x . Called by proc~~mxvdir~~CalledByGraph proc~mxvdir mxvdir proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~bfgs_variable_metric_update->proc~mxvdir proc~dual_range_space_qp dual_range_space_qp proc~dual_range_space_qp->proc~mxvdir proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~mxvdir proc~psqp psqp_class%psqp proc~psqp->proc~mxvdir proc~psqp->proc~bfgs_variable_metric_update proc~psqp->proc~dual_range_space_qp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxvdir ( n , a , x , y , z ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: a !! scaling factor. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( in ) :: y ( * ) !! y(n)  input vector. real ( wp ), intent ( out ) :: z ( * ) !! z(n)  output vector where `z:= y + a*x`. integer :: i do i = 1 , n z ( i ) = y ( i ) + a * x ( i ) end do end subroutine mxvdir","tags":"","url":"proc/mxvdir.html"},{"title":"mxvina – psqp","text":"public pure subroutine mxvina(n, ix) elements of the integer vector are replaced by their absolute values. Note that this function also subtracts 10 from ix if the absolute value\nis greater than 10. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n dimension of the integer vector. integer, intent(inout) :: ix (*) vector which is updated so that ix(i):=abs(ix(i)) for all i. Called by proc~~mxvina~~CalledByGraph proc~mxvina mxvina proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~mxvina proc~psqp psqp_class%psqp proc~psqp->proc~mxvina proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxvina ( n , ix ) integer , intent ( in ) :: n !! dimension of the integer vector. integer , intent ( inout ) :: ix ( * ) !! vector which is updated so that !! `ix(i):=abs(ix(i))` for all i. integer :: i do i = 1 , n ix ( i ) = abs ( ix ( i )) if ( ix ( i ) > 10 ) ix ( i ) = ix ( i ) - 10 end do end subroutine mxvina","tags":"","url":"proc/mxvina.html"},{"title":"mxvinv – psqp","text":"public pure subroutine mxvinv(ix, i, job) change of the integer vector element for the constraint addition. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ix (*) ix(n)  integer vector. integer, intent(in) :: i index of the changed element. integer, intent(in) :: job change specification Called by proc~~mxvinv~~CalledByGraph proc~mxvinv mxvinv proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~mxvinv proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxvinv ( ix , i , job ) integer , intent ( in ) :: i !! index of the changed element. integer , intent ( in ) :: job !! change specification integer , intent ( inout ) :: ix ( * ) !! ix(n)  integer vector. if ( ( ix ( i ) == 3 . or . ix ( i ) == 5 ) . and . job < 0 ) ix ( i ) = ix ( i ) + 1 if ( ( ix ( i ) == 4 . or . ix ( i ) == 6 ) . and . job > 0 ) ix ( i ) = ix ( i ) - 1 ix ( i ) = - ix ( i ) end subroutine mxvinv","tags":"","url":"proc/mxvinv.html"},{"title":"mxvneg – psqp","text":"public pure subroutine mxvneg(n, x, y) change the signs of vector elements. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(out) :: y (*) y(n)  output vector where y:= - x . Called by proc~~mxvneg~~CalledByGraph proc~mxvneg mxvneg proc~compute_obj_and_dobj psqp_class%compute_obj_and_dobj proc~compute_obj_and_dobj->proc~mxvneg proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~mxvneg proc~psqp psqp_class%psqp proc~psqp->proc~compute_obj_and_dobj proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxvneg ( n , x , y ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( out ) :: y ( * ) !! y(n)  output vector where `y:= - x`. integer :: i do i = 1 , n y ( i ) = - x ( i ) end do end subroutine mxvneg","tags":"","url":"proc/mxvneg.html"},{"title":"mxvort – psqp","text":"public pure subroutine mxvort(xk, xl, ck, cl, ier) determination of an elementary orthogonal matrix for plane rotation. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: xk first value for plane rotation\n(xk is transformed to sqrt(xk 2+xl 2)) real(kind=wp), intent(inout) :: xl second value for plane rotation\n(xl is transformed to zero) real(kind=wp), intent(out) :: ck diagonal element of the elementary orthogonal matrix. real(kind=wp), intent(out) :: cl off-diagonal element of the elementary orthogonal matrix. integer, intent(out) :: ier information on the transformation. ier=0 -- general plane rotation. ier=1 -- permutation. ier=2 -- transformation suppressed. Called by proc~~mxvort~~CalledByGraph proc~mxvort mxvort proc~update_tri_decomp_orthogonal update_tri_decomp_orthogonal proc~update_tri_decomp_orthogonal->proc~mxvort proc~ops_after_constr_deletion psqp_class%ops_after_constr_deletion proc~ops_after_constr_deletion->proc~update_tri_decomp_orthogonal proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~ops_after_constr_deletion proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxvort ( xk , xl , ck , cl , ier ) real ( wp ), intent ( inout ) :: xk !! first value for plane rotation !! (xk is transformed to sqrt(xk**2+xl**2)) real ( wp ), intent ( inout ) :: xl !! second value for plane rotation !! (xl is transformed to zero) real ( wp ), intent ( out ) :: ck !! diagonal element of the elementary orthogonal matrix. real ( wp ), intent ( out ) :: cl !! off-diagonal element of the elementary orthogonal matrix. integer , intent ( out ) :: ier !! information on the transformation. !! !! * `ier=0` -- general plane rotation. !! * `ier=1` -- permutation. !! * `ier=2` -- transformation suppressed. real ( wp ) :: den , pom if ( xl == 0.0_wp ) then ier = 2 elseif ( xk == 0.0_wp ) then xk = xl xl = 0.0_wp ier = 1 else if ( abs ( xk ) >= abs ( xl ) ) then pom = xl / xk den = sqrt ( 1.0_wp + pom * pom ) ck = 1.0_wp / den cl = pom / den xk = xk * den else pom = xk / xl den = sqrt ( 1.0_wp + pom * pom ) cl = 1.0_wp / den ck = pom / den xk = xl * den endif xl = 0.0_wp ier = 0 endif end subroutine mxvort","tags":"","url":"proc/mxvort.html"},{"title":"mxvrot – psqp","text":"public pure subroutine mxvrot(xk, xl, ck, cl, ier) plane rotation is applied to two values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: xk first value for plane rotation. real(kind=wp), intent(inout) :: xl second value for plane rotation. real(kind=wp), intent(in) :: ck diagonal element of the elementary orthogonal matrix. real(kind=wp), intent(in) :: cl off-diagonal element of the elementary orthogonal matrix. integer, intent(in) :: ier information on the transformation: ier=0-general plane rotation. ier=1-permutation. ier=2-transformation suppressed. Called by proc~~mxvrot~~CalledByGraph proc~mxvrot mxvrot proc~update_tri_decomp_orthogonal update_tri_decomp_orthogonal proc~update_tri_decomp_orthogonal->proc~mxvrot proc~ops_after_constr_deletion psqp_class%ops_after_constr_deletion proc~ops_after_constr_deletion->proc~update_tri_decomp_orthogonal proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~dual_range_space_quad_prog->proc~ops_after_constr_deletion proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_quad_prog proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxvrot ( xk , xl , ck , cl , ier ) real ( wp ), intent ( in ) :: ck !! diagonal element of the elementary orthogonal matrix. real ( wp ), intent ( in ) :: cl !! off-diagonal element of the elementary orthogonal matrix. real ( wp ), intent ( inout ) :: xk !! first value for plane rotation. real ( wp ), intent ( inout ) :: xl !! second value for plane rotation. integer , intent ( in ) :: ier !! information on the transformation: !! !! * ier=0-general plane rotation. !! * ier=1-permutation. !! * ier=2-transformation suppressed. real ( wp ) :: yk , yl if ( ier == 0 ) then yk = xk yl = xl xk = ck * yk + cl * yl xl = cl * yk - ck * yl elseif ( ier == 1 ) then yk = xk xk = xl xl = yk endif end subroutine mxvrot","tags":"","url":"proc/mxvrot.html"},{"title":"mxvsav – psqp","text":"public pure subroutine mxvsav(n, x, y) difference of two vectors returned in the subtracted one. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(inout) :: x (*) x(n)  input vector. real(kind=wp), intent(inout) :: y (*) y(n)  update vector where y:= x - y . Called by proc~~mxvsav~~CalledByGraph proc~mxvsav mxvsav proc~dual_range_space_qp dual_range_space_qp proc~dual_range_space_qp->proc~mxvsav proc~psqp psqp_class%psqp proc~psqp->proc~dual_range_space_qp proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxvsav ( n , x , y ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( inout ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( inout ) :: y ( * ) !! y(n)  update vector where `y:= x - y`. real ( wp ) :: temp integer :: i do i = 1 , n temp = y ( i ) y ( i ) = x ( i ) - y ( i ) x ( i ) = temp end do end subroutine mxvsav","tags":"","url":"proc/mxvsav.html"},{"title":"mxvscl – psqp","text":"public pure subroutine mxvscl(n, a, x, y) scaling of a vector. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: a scaling factor. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(out) :: y (*) y(n)  output vector where y:= a*x . Called by proc~~mxvscl~~CalledByGraph proc~mxvscl mxvscl proc~bfgs_variable_metric_update bfgs_variable_metric_update proc~bfgs_variable_metric_update->proc~mxvscl proc~mxdpgu mxdpgu proc~bfgs_variable_metric_update->proc~mxdpgu proc~mxdpgu->proc~mxvscl proc~psqp psqp_class%psqp proc~psqp->proc~bfgs_variable_metric_update proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxvscl ( n , a , x , y ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: a !! scaling factor. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( out ) :: y ( * ) !! y(n)  output vector where `y:= a*x`. integer :: i do i = 1 , n y ( i ) = a * x ( i ) end do end subroutine mxvscl","tags":"","url":"proc/mxvscl.html"},{"title":"mxvset – psqp","text":"public pure subroutine mxvset(n, a, x) a scalar is set to all the elements of a vector. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: a initial value. real(kind=wp), intent(out) :: x (*) x(n)  output vector such that x(i)=a for all i. Called by proc~~mxvset~~CalledByGraph proc~mxvset mxvset proc~psqp psqp_class%psqp proc~psqp->proc~mxvset proc~dual_range_space_quad_prog psqp_class%dual_range_space_quad_prog proc~psqp->proc~dual_range_space_quad_prog proc~update_tri_decomp_general update_tri_decomp_general proc~update_tri_decomp_general->proc~mxvset proc~update_tri_decomp_orthogonal update_tri_decomp_orthogonal proc~update_tri_decomp_orthogonal->proc~mxvset proc~dual_range_space_quad_prog->proc~update_tri_decomp_general proc~ops_after_constr_deletion psqp_class%ops_after_constr_deletion proc~dual_range_space_quad_prog->proc~ops_after_constr_deletion proc~ops_after_constr_deletion->proc~update_tri_decomp_orthogonal proc~psqpn psqp_class%psqpn proc~psqpn->proc~psqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine mxvset ( n , a , x ) real ( wp ), intent ( in ) :: a !! initial value. integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( out ) :: x ( * ) !! x(n)  output vector such that `x(i)=a` for all i. integer :: i do i = 1 , n x ( i ) = a end do end subroutine mxvset","tags":"","url":"proc/mxvset.html"},{"title":"psqp_module – psqp","text":"PSQP: SQP variable metric method for general\n  nonlinear programming problems. History Original Fortran 77 code by Ladislav Luksan. Jacob Williams, Aug 2017,\n    Significant refactoring to modern Fortran. Uses psqp_matrix_module psqp_kind_module module~~psqp_module~~UsesGraph module~psqp_module psqp_module module~psqp_kind_module psqp_kind_module module~psqp_module->module~psqp_kind_module module~psqp_matrix_module psqp_matrix_module module~psqp_module->module~psqp_matrix_module iso_fortran_env iso_fortran_env module~psqp_kind_module->iso_fortran_env module~psqp_matrix_module->module~psqp_kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: psqp_wp = wp export the working precision Abstract Interfaces abstract interface private  subroutine obj_func(me, nf, x, ff) objective function interface Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf the number of variables real(kind=wp) :: x (nf) a vector of variables real(kind=wp) :: ff the value of the objective function abstract interface private  subroutine dobj_func(me, nf, x, gf) gradient of the objective function interface Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf the number of variables real(kind=wp) :: x (nf) a vector of variables real(kind=wp) :: gf (nf) the gradient of the objective function abstract interface private  subroutine con_func(me, nf, kc, x, fc) constraint function interface Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf the number of variables integer :: kc the index of the constraint function real(kind=wp) :: x (nf) a vector of variables real(kind=wp) :: fc the value of the constraint function abstract interface private  subroutine dcon_func(me, nf, kc, x, gc) gradient of the constraint function interface Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf the number of variables integer :: kc the index of the constraint function real(kind=wp) :: x (nf) a vector of variables and real(kind=wp) :: gc (nf) the gradient of the constraint function abstract interface private  subroutine report_f(me, iter, x, j, f) Report function to call once per iteration to report the solution. Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer, intent(in) :: iter Iteration number real(kind=wp), intent(in), dimension(:) :: x optimization variables real(kind=wp), intent(in) :: j Objective function value real(kind=wp), intent(in), dimension(:) :: f Constraint functions Derived Types type, public :: psqp_class The main PSQP class to use. Components Type Visibility Attributes Name Initial integer, public :: nres = 0 number of restarts. integer, public :: ndec = 0 number of matrix decomposition. integer, public :: nrem = 0 number of constraint deletions. integer, public :: nadd = 0 number of constraint additions. integer, public :: nit = 0 number of iterations. integer, public :: nfv = 0 number of function evaluations. integer, public :: nfg = 0 number of gradient evaluations. integer, public :: nfh = 0 number of hessian evaluations. integer, private :: mtyp = 0 integer, private :: mode = 0 integer, private :: mes1 = 0 integer, private :: mes2 = 0 real(kind=wp), private :: rl = 0.0_wp real(kind=wp), private :: fl = 0.0_wp real(kind=wp), private :: ru = 0.0_wp real(kind=wp), private :: fu = 0.0_wp real(kind=wp), private :: ri = 0.0_wp real(kind=wp), private :: fi = 0.0_wp procedure( obj_func ), private, pointer :: obj => null() objective function procedure( dobj_func ), private, pointer :: dobj => null() gradient of the objective function procedure( con_func ), private, pointer :: con => null() constraint function procedure( dcon_func ), private, pointer :: dcon => null() gradient of the constraint function procedure( report_f ), private, pointer :: report => null() iteration report function Type-Bound Procedures procedure, public :: psqpn procedure, public :: psqp procedure, private :: compute_obj_and_dobj procedure, private :: dual_range_space_quad_prog procedure, private :: ops_after_constr_deletion procedure, private :: compute_con_and_dcon procedure, private :: extended_line_search Subroutines private  subroutine psqpn (me, nf, nb, nc, x, bound_type, xl, xu, cf, constraint_type, cl, cu, ipar, rpar, f, gmax, cmax, iprnt, iterm, obj, dobj, con, dcon, report) Date 97/01/22 easy to use subroutine for general nonlinear programming problems. Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer, intent(in) :: nf number of variables integer, intent(in) :: nb choice of simple bounds. Read more… integer, intent(in) :: nc number of general nonlinear constraints. real(kind=wp), intent(inout), dimension(nf) :: x x(nf) vector of variables. integer, intent(in), dimension(nf) :: bound_type ix(nf) vector containing types of bounds. Read more… real(kind=wp), intent(in), dimension(nf) :: xl xl(nf) vector containing lower bounds for variables. real(kind=wp), intent(in), dimension(nf) :: xu xu(nf) vector containing upper bounds for variables. real(kind=wp), intent(out), dimension(nc+1) :: cf cf(nc+1) vector containing values of the constraint functions. integer, intent(in), dimension(nc) :: constraint_type ic(nc) vector containing types of constraints: Read more… real(kind=wp), intent(in), dimension(nc) :: cl cl(nc) vector containing lower bounds for constraint functions. real(kind=wp), intent(in), dimension(nc) :: cu cu(nc) vector containing upper bounds for constraint functions. integer, intent(in), dimension(6) :: ipar integer paremeters: Read more… real(kind=wp), intent(in), dimension(5) :: rpar real parameters: Read more… real(kind=wp), intent(out) :: f value of the objective function. real(kind=wp), intent(out) :: gmax maximum partial derivative of the lagrangian function. real(kind=wp), intent(out) :: cmax maximum constraint violation. integer, intent(in) :: iprnt print specification: Read more… integer, intent(out) :: iterm variable that indicates the cause of termination. Read more… procedure( obj_func ) :: obj computation of the value of the objective function procedure( dobj_func ) :: dobj computation of the gradient of the objective function procedure( con_func ) :: con computation of the value of the constraint function procedure( dcon_func ) :: dcon computation of the gradient of the constraint function procedure( report_f ), optional :: report iteration report function. Note: this is independent of iprnt . \nIf this function is associated, each iteration will be reported private  subroutine psqp (me, nf, nb, nc, x, ix, xl, xu, cf, ic, cl, cu, cg, cfo, cfd, gc, ica, cr, cz, cp, gf, g, h, s, xo, go, xmax, tolx, tolc, tolg, rpf, cmax, gmax, f, mit, mfv, met, mec, iprnt, iterm) Date 97/01/22 recursive quadratic programming method with the bfgs variable metric\n  update for general nonlinear programming problems. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf number of variables. integer :: nb choice of simple bounds. Read more… integer :: nc number of linear constraints. real(kind=wp) :: x (*) x(nf)  vector of variables. integer, intent(inout) :: ix (*) ix(nf)  vector containing types of bounds. Read more… real(kind=wp) :: xl (*) xl(nf)  vector containing lower bounds for variables. real(kind=wp) :: xu (*) xu(nf)  vector containing upper bounds for variables. real(kind=wp) :: cf (*) cf(nc+1)  vector containing values of the constraint functions. integer, intent(inout) :: ic (*) ic(nc)  vector containing types of constraints. Read more… real(kind=wp) :: cl (*) cl(nc)  vector containing lower bounds for constraint functions. real(kind=wp) :: cu (*) cu(nc)  vector containing upper bounds for constraint functions. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals of the linear constraints. real(kind=wp) :: cfo (*) cfo(nc)  vector containing saved values of the constraint functions. real(kind=wp) :: cfd (*) cfd(nc)  vector containing increments of the constraint functions. real(kind=wp) :: gc (*) gc(nf)  gradient of the selected constraint function. integer :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cr (*) cr(nf*(nf+1)/2)  triangular decomposition of kernel\nof the orthogonal projection. real(kind=wp) :: cz (*) cz(nf)  vector of lagrange multipliers. real(kind=wp) :: cp (*) real(kind=wp) :: gf (*) gf(nf)  gradient of the model function. real(kind=wp) :: g (*) g(nf)  gradient of the objective function. real(kind=wp) :: h (*) h(nf*(nf+1)/2)  triangular decomposition or inversion of\nthe hessian matrix approximation. real(kind=wp) :: s (*) s(nf)  direction vector. real(kind=wp) :: xo (*) xo(nf)  vectors of variables difference. real(kind=wp) :: go (*) go(nf)  gradients difference. real(kind=wp) :: xmax maximum stepsize. real(kind=wp) :: tolx tolerance for change of variables. real(kind=wp) :: tolc tolerance for constraint violations. real(kind=wp) :: tolg tolerance for the gradient of the lagrangian function. real(kind=wp) :: rpf penalty coefficient. real(kind=wp) :: cmax maximum constraint violation. real(kind=wp) :: gmax maximum partial derivative of the lagrangian function. real(kind=wp) :: f value of the objective function. integer :: mit maximum number of iterations. integer :: mfv maximum number of function evaluations. integer :: met variable metric update used. Read more… integer :: mec correction if the negative curvature occurs. Read more… integer :: iprnt print specification. Read more… integer :: iterm variable that indicates the cause of termination. Read more… private  subroutine compute_con_and_dcon (me, nf, nc, x, fc, cf, cl, cu, ic, gc, cg, cmax, kd, ld) Date 97/12/01 computation of the value and the gradient of the constraint function. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf number of variables. integer :: nc number of constraints. real(kind=wp) :: x (nf) x(nf) vector of variables. real(kind=wp) :: fc value of the selected constraint function. real(kind=wp) :: cf (*) cf(nc) vector containing values of constraint functions. real(kind=wp) :: cl (*) cl(nc) vector containing lower bounds for constraint functions. real(kind=wp) :: cu (*) cu(nc) vector containing upper bounds for constraint functions. integer :: ic (*) ic(nc) vector containing types of constraints. real(kind=wp) :: gc (nf) gc(nf) gradient of the selected constraint function. real(kind=wp) :: cg (*) cg(nf*nc) matrix whose columns are gradients of constraint functions. real(kind=wp) :: cmax maximum constraint violation. integer :: kd degree of required derivatives. integer :: ld degree of previously computed derivatives. private  subroutine compute_obj_and_dobj (me, nf, x, gf, g, ff, f, kd, ld, iext) Date 97/12/01 computation of the value and the gradient of the objective function. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer, intent(in) :: nf number of variables. real(kind=wp), intent(in) :: x (nf) x(nf)   vector of variables. real(kind=wp), intent(out) :: gf (nf) gf(nf)  gradient of the model function. real(kind=wp), intent(out) :: g (nf) g(nf)   gradient of the objective function. real(kind=wp), intent(out) :: ff value of the model function. real(kind=wp), intent(out) :: f value of the objective function. integer, intent(in) :: kd degree of required derivatives. integer, intent(inout) :: ld degree of previously computed derivatives. integer, intent(in) :: iext type of extremum. Read more… private  subroutine dual_range_space_quad_prog (me, nf, nc, x, ix, xl, xu, cf, cfd, ic, ica, cl, cu, cg, cr, cz, g, go, h, s, mfp, kbf, kbc, idecf, eta2, eta9, eps7, eps9, umax, gmax, n, iterq) Date 97/12/01 dual range space quadratic programming method. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf number of variables. integer :: nc number of linear constraints. real(kind=wp) :: x (*) x(nf)   vector of variables. integer :: ix (*) ix(nf)  vector containing types of bounds. real(kind=wp) :: xl (*) xl(nf)  vector containing lower bounds for variables. real(kind=wp) :: xu (*) xu(nf)  vector containing upper bounds for variables. real(kind=wp) :: cf (*) cf(nf)  vector containing values of the constraint functions. real(kind=wp) :: cfd (*) cfd(nc)  vector containing increments of the constraint functions. integer :: ic (*) ic(nc)  vector containing types of constraints. integer :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cl (*) cl(nc)  vector containing lower bounds for constraint functions. real(kind=wp) :: cu (*) cu(nc)  vector containing upper bounds for constraint functions. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals of the linear constraints. real(kind=wp) :: cr (*) cr(nf*(nf+1)/2)  triangular decomposition of kernel of the orthogonal projection. real(kind=wp) :: cz (*) cz(nf)  vector of lagrange multipliers. real(kind=wp) :: g (*) g(nf)  gradient of the lagrangian function. real(kind=wp) :: go (*) go(nf)  saved gradient of the objective function. real(kind=wp) :: h (*) h(nf*(nf+1)/2)  triangular decomposition or inversion\nof the hessian matrix approximation. real(kind=wp) :: s (*) s(nf)  direction vector. integer :: mfp type of feasible point. Read more… integer :: kbf specification of simple bounds. Read more… integer :: kbc specification of linear constraints. Read more… integer :: idecf decomposition indicator. Read more… real(kind=wp) :: eta2 tolerance for positive definiteness of the hessian matrix. real(kind=wp) :: eta9 maximum for real numbers. real(kind=wp) :: eps7 tolerance for linear independence of constraints. real(kind=wp) :: eps9 tolerance for activity of constraints. real(kind=wp) :: umax maximum absolute value of a negative lagrange multiplier. real(kind=wp) :: gmax maximum absolute value of a partial derivative. integer :: n dimension of the manifold defined by active constraints. integer :: iterq type of feasible point. Read more… private  subroutine update_tri_decomp_general (nf, n, ica, cg, cr, h, s, g, eps7, gmax, umax, idecf, inew, nadd, ier, job) Date 97/12/01 triangular decomposition of kernel of the general projection\n is updated after constraint addition. Read more… Arguments Type Intent Optional Attributes Name integer :: nf declared number of variables. integer :: n actual number of variables. integer :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals of\nthe linear constraints. real(kind=wp) :: cr (*) cr(nf*(nf+1)/2)  triangular decomposition of\nkernel of the orthogonal projection. real(kind=wp) :: h (*) h(nf*(nf+1)/2)  triangular decomposition or\ninversion of the hessian matrix approximation. real(kind=wp) :: s (*) s(nf)  auxiliary vector. real(kind=wp) :: g (*) g(nf)  vector used in the dual range space\nquadratic programming method. real(kind=wp) :: eps7 tolerance for linear independence of constraints. real(kind=wp) :: gmax maximum absolute value of a partial derivative. real(kind=wp) :: umax maximum absolute value of a negative\nlagrange multiplier. integer :: idecf decomposition indicator. Read more… integer :: inew index of the new active constraint. integer :: nadd number of constraint additions. integer :: ier error indicator. integer :: job specification of computation.\noutput vector g is not or is\ncomputed in case when n<=0 if\njob=0 or job=1 respectively. private  subroutine determine_new_active_linear_constr (nf, nc, cf, cfd, ic, cl, cu, cg, s, eps9, par, kbc, inew, knew) Date 97/12/01 determination of the new active linear constraint. Read more… Arguments Type Intent Optional Attributes Name integer :: nf number of variables. integer :: nc number of constraints. real(kind=wp) :: cf (*) cf(nc)  vector containing values of the\nconstraint functions. real(kind=wp) :: cfd (*) cfd(nc)  vector containing increments of\nthe constraint functions. integer :: ic (*) ic(nc)  vector containing types of constraints. real(kind=wp) :: cl (*) cl(nc)  vector containing lower bounds for\nconstraint functions. real(kind=wp) :: cu (*) cu(nc)  vector containing upper bounds for\nconstraint functions. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals\nof the linear constraints. real(kind=wp) :: s (*) s(nf)  direction vector. real(kind=wp) :: eps9 tolerance for active constraints. real(kind=wp) :: par auxiliary variable. integer :: kbc specification of linear constraints. Read more… integer :: inew index of the new active constraint. integer :: knew signum of the new active normal. private  subroutine determine_new_active_simple_bound (nf, ix, xo, xl, xu, s, kbf, inew, knew, eps9, par) Date 91/12/01 determination of the new active simple bound. Read more… Arguments Type Intent Optional Attributes Name integer :: nf declared number of variables. integer :: ix (*) ix(nf)  vector containing types of bounds. real(kind=wp) :: xo (*) xo(nf)  saved vector of variables. real(kind=wp) :: xl (*) xl(nf)  vector containing lower bounds\nfor variables. real(kind=wp) :: xu (*) xu(nf)  vector containing upper bounds\nfor variables. real(kind=wp) :: s (*) s(nf)  direction vector. integer :: kbf specification of simple bounds. Read more… integer :: inew index of the new active constraint. integer :: knew signum of the new normal. real(kind=wp) :: eps9 tolerance for active constraints. real(kind=wp) :: par auxiliary variable. private  subroutine test_simple_bound (x, ix, xl, xu, eps9, i) Date 97/12/01 test on activity of a given simple bound. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (*) x(nf)  vector of variables. integer, intent(inout) :: ix (*) ix(nf)  vector containing types of bounds. real(kind=wp), intent(in) :: xl (*) xl(nf)  vector containing lower bounds for variables. real(kind=wp), intent(in) :: xu (*) xu(nf)  vector containing upper bounds for variables. real(kind=wp), intent(in) :: eps9 tolerance for active constraints. integer, intent(in) :: i index of tested simple bound. private  subroutine transform_incompatible_qp_subproblem (nc, cf, ic, cl, cu, kbc) Date 98/12/01 transformation of the incompatible quadratic programming subproblem. Read more… Arguments Type Intent Optional Attributes Name integer :: nc number of current linear constraints. real(kind=wp) :: cf (*) cf(nf)  vector containing values of the constraint functions. integer :: ic (nc) ic(nc)  vector containing types of constraints. real(kind=wp) :: cl (*) cl(nc)  vector containing lower bounds for constraint functions. real(kind=wp) :: cu (*) cu(nc)  vector containing upper bounds for constraint functions. integer :: kbc specification of linear constraints. Read more… private  subroutine ops_after_constr_deletion (me, nf, nc, ix, ia, iaa, ar, ic, s, n, iold, krem, ier) Date 91/12/01 operations after constraint deletion. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me integer :: nf declared number of variables. integer :: nc number of constraints. integer :: ix (*) ix(nf)  vector containing types of bounds. integer :: ia (*) ia(na)  vector containing types of deviations. integer :: iaa (*) iaa(nf+1)  vector containing indices of active\nfunctions. real(kind=wp) :: ar (*) ar((nf+1)*(nf+2)/2)  triangular decomposition\nof kernel of the orthogonal projection. integer :: ic (*) ic(nc)  vector containing types of constraints. real(kind=wp) :: s (*) s(nf+1)  auxiliary vector. integer :: n actual number of variables. integer :: iold index of the old active constraint. integer :: krem auxiliary variable. integer :: ier error indicator. private  subroutine update_tri_decomp_orthogonal (nf, ica, cr, g, n, iold, krem, ier) Date 91/12/01 triangular decomposition of kernel of the orthogonal projection is\n updated after constraint deletion. Read more… Arguments Type Intent Optional Attributes Name integer :: nf declared number of variables. integer :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cr (*) cr(nf*(nf+1)/2)  triangular decomposition\nof kernel of the orthogonal projection. real(kind=wp) :: g (*) g(nf)  auxiliary vector. integer :: n actual number of variables. integer :: iold index of the old active constraint. integer :: krem auxiliary variable. integer :: ier error indicator. private  subroutine line_search_interpolation (ro, rl, ru, ri, fo, fl, fu, fi, po, r, mode, mtyp, merr) Date 91/12/01 extrapolation or interpolation for line search without directional\n derivatives. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp) :: ro initial value of the stepsize parameter. real(kind=wp) :: rl lower value of the stepsize parameter. real(kind=wp) :: ru upper value of the stepsize parameter. real(kind=wp) :: ri inner value of the stepsize parameter. real(kind=wp) :: fo value of the objective function for r=ro. real(kind=wp) :: fl value of the objective function for r=rl. real(kind=wp) :: fu value of the objective function for r=ru. real(kind=wp) :: fi value of the objective function for r=ri. real(kind=wp) :: po initial value of the directional derivative. real(kind=wp) :: r value of the stepsize parameter obtained. integer :: mode mode of line search. integer :: mtyp method selection Read more… integer :: merr error indicator. merr=0 for normal return. private pure subroutine compute_augmented_lagrangian (nf, n, nc, cf, ic, ica, cl, cu, cz, rpf, fc, f) Date 97/12/01 computation of value of the augmented lagrangian function. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nf number of variables. integer, intent(in) :: n dimension of the constraint null space. integer, intent(in) :: nc number of constraints. real(kind=wp), intent(in) :: cf (*) cf(nc+1)  vector containing values of the constraints. integer, intent(in) :: ic (*) ic(nc)  vector containing types of constraints. integer, intent(in) :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp), intent(in) :: cl (*) cl(nc)  vector containing lower bounds for constraint functions. real(kind=wp), intent(in) :: cu (*) cu(nc)  vector containing upper bounds for constraint functions. real(kind=wp), intent(in) :: cz (*) cz(nc)  vector of lagrange multipliers. real(kind=wp), intent(in) :: rpf penalty coefficient. real(kind=wp), intent(out) :: fc value of the penalty term. real(kind=wp), intent(out) :: f value of the penalty function. private pure subroutine compute_new_penalty_parameters (nf, n, nc, ica, cz, cp) Date 97/12/01 computation of the new penalty parameters. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nf declared number of variables. integer, intent(in) :: n actual number of variables. integer, intent(in) :: nc number of constraints. integer, intent(in) :: ica (*) vector containing indices of active constraints. real(kind=wp), intent(in) :: cz (*) vector of lagrange multipliers. real(kind=wp), intent(inout) :: cp (*) vector containing penalty parameters. private  subroutine extended_line_search (me, r, ro, rp, f, fo, fp, po, pp, fmin, fmax, rmin, rmax, tols, kd, ld, nit, kit, nred, mred, maxst, iest, inits, iters, kters, mes, isys) Date 97/12/01 extended line search without directional derivatives. Read more… Arguments Type Intent Optional Attributes Name class( psqp_class ), intent(inout) :: me real(kind=wp) :: r value of the stepsize parameter. real(kind=wp) :: ro initial value of the stepsize parameter. real(kind=wp) :: rp previous value of the stepsize parameter. real(kind=wp) :: f value of the objective function. real(kind=wp) :: fo initial value of the objective function. real(kind=wp) :: fp previous value of the objective function. real(kind=wp) :: po initial value of the directional derivative. real(kind=wp) :: pp previous value of the directional derivative. real(kind=wp) :: fmin lower bound for value of the objective function. real(kind=wp) :: fmax upper bound for value of the objective function. real(kind=wp) :: rmin minimum value of the stepsize parameter real(kind=wp) :: rmax maximum value of the stepsize parameter real(kind=wp) :: tols termination tolerance for line search\n(in test on the change of the function value). integer :: kd degree of required dervatives. integer :: ld degree of previously computed derivatives. integer :: nit actual number of iterations. integer :: kit number of the iteration after last restart. integer :: nred actual number of extrapolations or interpolations. integer :: mred maximum number of extrapolations or interpolations. integer :: maxst maximum stepsize indicator. maxst=0 or maxst=1\nif maximum stepsize was not or was reached. integer :: iest lower bound specification. iest=0 or iest=1\nif lower bound is not or is given. integer :: inits choice of the initial stepsize. Read more… integer :: iters termination indicator. Read more… integer :: kters termination selection. Read more… integer :: mes method selection. Read more… integer :: isys control parameter. private  subroutine bfgs_variable_metric_update (n, h, g, s, xo, go, r, po, nit, kit, iterh, met, met1, mec) Date 92/12/01 variable metric update of a dense symmetric positive definite matrix\n using the factorization b=l d trans(l). Read more… Arguments Type Intent Optional Attributes Name integer :: n actual number of variables. real(kind=wp) :: h (*) h(m)  factorization b=l d trans(l) of a positive\ndefinite approximation of the hessian matrix. real(kind=wp) :: g (*) g(nf)  gradient of the objective function. real(kind=wp) :: s (*) s(nf)  auxiliary vector. real(kind=wp) :: xo (*) xo(nf)  vectors of variables difference. real(kind=wp) :: go (*) go(nf)  gradients difference. real(kind=wp) :: r value of the stepsize parameter. real(kind=wp) :: po old value of the directional derivative. integer :: nit actual number of iterations. integer :: kit number of the iteration after last restart. integer :: iterh termination indicator. Read more… integer :: met integer :: met1 selection of self scaling. Read more… integer :: mec correction if the negative curvature occurs. Read more… private  subroutine dual_range_space_qp (nf, n, x, xo, ica, cg, cz, g, go, r, f, fo, p, po, cmax, cmaxo, dmax, kd, ld, iters) Date 91/12/01 dual range space quadratic programming method for minimax\n approximation. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nf declared number of variables. integer, intent(inout) :: n actual number of variables. real(kind=wp) :: x (*) x(nf)  vector of variables. real(kind=wp) :: xo (*) xo(nf)  saved vector of variables. integer, intent(in) :: ica (*) ica(nf)  vector containing indices of active constraints. real(kind=wp) :: cg (*) cg(nf*nc)  matrix whose columns are normals of the linear constraints. real(kind=wp) :: cz (*) cz(nf)  vector of lagrange multipliers. real(kind=wp) :: g (*) g(nf)  gradient of the lagrangian function. real(kind=wp) :: go (*) go(nf)  saved gradient of the lagrangian function. real(kind=wp) :: r value of the stepsize parameter. real(kind=wp) :: f new value of the objective function. real(kind=wp) :: fo old value of the objective function. real(kind=wp) :: p new value of the directional derivative. real(kind=wp) :: po old value of the directional derivative. real(kind=wp) :: cmax value of the constraint violation. real(kind=wp) :: cmaxo saved value of the constraint violation. real(kind=wp), intent(out) :: dmax maximum relative difference of variables. integer :: kd integer :: ld integer :: iters termination indicator for steplength determination.\niters=0 for zero step.","tags":"","url":"module/psqp_module.html"},{"title":"psqp_matrix_module – psqp","text":"Matrix routines. History Original version: LU, 1991 Note Some of these could just be replaced with normal array operations. Uses psqp_kind_module module~~psqp_matrix_module~~UsesGraph module~psqp_matrix_module psqp_matrix_module module~psqp_kind_module psqp_kind_module module~psqp_matrix_module->module~psqp_kind_module iso_fortran_env iso_fortran_env module~psqp_kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~psqp_matrix_module~~UsedByGraph module~psqp_matrix_module psqp_matrix_module module~psqp_module psqp_module module~psqp_module->module~psqp_matrix_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure function mxdpgp (n, a, x, y) Date 91/12/01 computation of the number mxdpgp=trans(x)*d**(-1)*y where d is a\ndiagonal matrix in the factorization a+e=l*d*trans(l) obtained by the\nsubroutine mxdpgf . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(in) :: a (*) a(n*(n+1)/2) factorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . real(kind=wp), intent(in) :: x (*) input vector. real(kind=wp), intent(in) :: y (*) input vector. Return Value real(kind=wp) computed number mxdpgp=trans(x)*d**(-1)*y . public pure function mxvdot (n, x, y) Date 91/12/01 dot product of two vectors. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(in) :: y (*) y(n)  input vector. Return Value real(kind=wp) value of dot product mxvdot=trans(x)*y . public pure function mxvmax (n, x) Date 91/12/01 l-infinity norm of a vector. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: x (*) x(n)  input vector. Return Value real(kind=wp) l-infinity norm of the vector x. Subroutines public pure subroutine mxdpgb (n, a, x, job) Date 91/12/01 solution of a system of linear equations with a dense symmetric\n positive definite matrix a+e using the factorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(in) :: a (*) a(n*(n+1)/2) factorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . real(kind=wp), intent(inout) :: x (*) x(n)  on input the right hand side of a\nsystem of linear equations. on output the\nsolution of a system of linear equations. integer, intent(in) :: job option Read more… public pure subroutine mxdpgf (n, a, inf, alf, tau) Date 89/12/01 factorization a+e=l*d*trans(l) of a dense symmetric positive definite\n matrix a+e where d and e are diagonal positive definite matrices and\n l is a lower triangular matrix. if a is sufficiently positive\n definite then e=0. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(inout) :: a (*) a(n*(n+1)/2) on input a given dense symmetric (usually positive\ndefinite) matrix a stored in the packed form. on output the\ncomputed factorization a+e=l*d*trans(l) . integer, intent(out) :: inf an information obtained in the factorization process. if: Read more… real(kind=wp), intent(inout) :: alf on input a desired tolerance for positive definiteness. on\noutput the most negative diagonal element used in the\nfactorization process (if inf>0). real(kind=wp), intent(out) :: tau maximum diagonal element of the matrix e. public pure subroutine mxdpgs (n, a, alf) Date 91/12/01 scaling of a dense symmetric positive definite matrix a+e using the\nfactorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(inout) :: a (*) a(n*(n+1)/2) factorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . real(kind=wp), intent(in) :: alf scaling factor. public pure subroutine mxdpgu (n, a, alf, x, y) Date 89/12/01 correction of a dense symmetric positive definite matrix a+e in the\n factored form a+e=l*d*trans(l) obtained by the subroutine mxdpgf .\n the correction is defined as a+e:=a+e+alf*x*trans(x) where alf is a\n given scaling factor and x is a given vector. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(inout) :: a (*) a(n*(n+1)/2) factorization a+e=l*d*trans(l) obtained by the subroutine mxdpgf . real(kind=wp), intent(in) :: alf scaling factor in the correction term. real(kind=wp), intent(in) :: x (*) vector in the correction term. real(kind=wp), intent(out) :: y (*) auxiliary vector. public pure subroutine mxdprb (n, a, x, job) Date 89/12/01 solution of a system of linear equations with a dense symmetric\n positive definite matrix a using the factorization a=trans(r)*r. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(in) :: a (*) a(n (n+1)/2) factorization a=trans(r) r. real(kind=wp), intent(inout) :: x (*) x(n)  on input the right hand side of a system of linear\nequations. on output the solution of a system of linear\nequations. integer, intent(in) :: job option Read more… public pure subroutine mxdsmi (n, a) Date 88/12/01 dense symmetric matrix a is set to the unit matrix with the same\norder. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(out) :: a (*) a(n*(n+1)/2) dense symmetric matrix\nstored in the packed form which is set\nto the unit matrix (i.e. a:=i ). public pure subroutine mxdsmm (n, a, x, y) Date 89/12/01 multiplication of a dense symmetric matrix a by a vector x. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(in) :: a (*) a(n*(n+1)/2) dense symmetric matrix stored in the packed form. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(out) :: y (*) y(n)  output vector equal to a*x . public pure subroutine mxdsmv (n, a, x, k) Date 91/12/01 k-th row of a dense symmetric matrix a is copied to the vector x. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the matrix a. real(kind=wp), intent(in) :: a (*) a(n*(n+1)/2) dense symmetric matrix\nstored in the packed form. real(kind=wp), intent(out) :: x (*) x(n)  output vector. integer, intent(in) :: k index of copied row. public pure subroutine mxvcop (n, x, y) Date 88/12/01 copying of a vector. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(out) :: y (*) y(n)  output vector where y:= x . public pure subroutine mxvdif (n, x, y, z) Date 88/12/01 vector difference. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(in) :: y (*) y(n)  input vector. real(kind=wp), intent(out) :: z (*) z(n)  output vector where z:= x - y . public pure subroutine mxvdir (n, a, x, y, z) Date 91/12/01 vector augmented by the scaled vector. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: a scaling factor. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(in) :: y (*) y(n)  input vector. real(kind=wp), intent(out) :: z (*) z(n)  output vector where z:= y + a*x . public pure subroutine mxvina (n, ix) Date 90/12/01 elements of the integer vector are replaced by their absolute values. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n dimension of the integer vector. integer, intent(inout) :: ix (*) vector which is updated so that ix(i):=abs(ix(i)) for all i. public pure subroutine mxvinv (ix, i, job) Date 91/12/01 change of the integer vector element for the constraint addition. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: ix (*) ix(n)  integer vector. integer, intent(in) :: i index of the changed element. integer, intent(in) :: job change specification public pure subroutine mxvneg (n, x, y) Date 88/12/01 change the signs of vector elements. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(out) :: y (*) y(n)  output vector where y:= - x . public pure subroutine mxvort (xk, xl, ck, cl, ier) Date 91/12/01 determination of an elementary orthogonal matrix for plane rotation. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: xk first value for plane rotation\n(xk is transformed to sqrt(xk 2+xl 2)) real(kind=wp), intent(inout) :: xl second value for plane rotation\n(xl is transformed to zero) real(kind=wp), intent(out) :: ck diagonal element of the elementary orthogonal matrix. real(kind=wp), intent(out) :: cl off-diagonal element of the elementary orthogonal matrix. integer, intent(out) :: ier information on the transformation. Read more… public pure subroutine mxvrot (xk, xl, ck, cl, ier) Date 91/12/01 plane rotation is applied to two values. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: xk first value for plane rotation. real(kind=wp), intent(inout) :: xl second value for plane rotation. real(kind=wp), intent(in) :: ck diagonal element of the elementary orthogonal matrix. real(kind=wp), intent(in) :: cl off-diagonal element of the elementary orthogonal matrix. integer, intent(in) :: ier information on the transformation: Read more… public pure subroutine mxvsav (n, x, y) Date 91/12/01 difference of two vectors returned in the subtracted one. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(inout) :: x (*) x(n)  input vector. real(kind=wp), intent(inout) :: y (*) y(n)  update vector where y:= x - y . public pure subroutine mxvscl (n, a, x, y) Date 88/12/01 scaling of a vector. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: a scaling factor. real(kind=wp), intent(in) :: x (*) x(n)  input vector. real(kind=wp), intent(out) :: y (*) y(n)  output vector where y:= a*x . public pure subroutine mxvset (n, a, x) Date 88/12/01 a scalar is set to all the elements of a vector. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n vector dimension. real(kind=wp), intent(in) :: a initial value. real(kind=wp), intent(out) :: x (*) x(n)  output vector such that x(i)=a for all i.","tags":"","url":"module/psqp_matrix_module.html"},{"title":"psqp_kind_module – psqp","text":"Numeric kind definitions. Uses iso_fortran_env module~~psqp_kind_module~~UsesGraph module~psqp_kind_module psqp_kind_module iso_fortran_env iso_fortran_env module~psqp_kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~psqp_kind_module~~UsedByGraph module~psqp_kind_module psqp_kind_module module~psqp_matrix_module psqp_matrix_module module~psqp_matrix_module->module~psqp_kind_module module~psqp_module psqp_module module~psqp_module->module~psqp_kind_module module~psqp_module->module~psqp_matrix_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: wp = real64 Real working precision if not specified [8 bytes] integer, public, parameter :: psqp_wp = wp Working real precision","tags":"","url":"module/psqp_kind_module.html"},{"title":"psqp_module.f90 – psqp","text":"This file depends on sourcefile~~psqp_module.f90~~EfferentGraph sourcefile~psqp_module.f90 psqp_module.f90 sourcefile~psqp_kind_module.f90 psqp_kind_module.F90 sourcefile~psqp_module.f90->sourcefile~psqp_kind_module.f90 sourcefile~psqp_matrix_module.f90 psqp_matrix_module.f90 sourcefile~psqp_module.f90->sourcefile~psqp_matrix_module.f90 sourcefile~psqp_matrix_module.f90->sourcefile~psqp_kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !*********************************************************************** !> !  PSQP: SQP variable metric method for general !  nonlinear programming problems. ! !### History !  * [Original Fortran 77 code](http://www.cs.cas.cz/~luksan/subroutines.html) !    by Ladislav Luksan. !  * Jacob Williams, Aug 2017, !    Significant refactoring to modern Fortran. module psqp_module use psqp_matrix_module use psqp_kind_module , only : wp => psqp_wp implicit none private integer , parameter , public :: psqp_wp = wp !! export the working precision type , public :: psqp_class !! The main PSQP class to use. private ! these were formerly in the `stat` common block: integer , public :: nres = 0 !! number of restarts. integer , public :: ndec = 0 !! number of matrix decomposition. integer , public :: nrem = 0 !! number of constraint deletions. integer , public :: nadd = 0 !! number of constraint additions. integer , public :: nit = 0 !! number of iterations. integer , public :: nfv = 0 !! number of function evaluations. integer , public :: nfg = 0 !! number of gradient evaluations. integer , public :: nfh = 0 !! number of hessian evaluations. ! formerly saved variables in extended_line_search: integer :: mtyp = 0 integer :: mode = 0 integer :: mes1 = 0 integer :: mes2 = 0 real ( wp ) :: rl = 0.0_wp real ( wp ) :: fl = 0.0_wp real ( wp ) :: ru = 0.0_wp real ( wp ) :: fu = 0.0_wp real ( wp ) :: ri = 0.0_wp real ( wp ) :: fi = 0.0_wp procedure ( obj_func ), pointer :: obj => null () !! objective function procedure ( dobj_func ), pointer :: dobj => null () !! gradient of the objective function procedure ( con_func ), pointer :: con => null () !! constraint function procedure ( dcon_func ), pointer :: dcon => null () !! gradient of the constraint function procedure ( report_f ), pointer :: report => null () !! iteration report function contains private procedure , public :: psqpn procedure , public :: psqp procedure :: compute_obj_and_dobj procedure :: dual_range_space_quad_prog procedure :: ops_after_constr_deletion procedure :: compute_con_and_dcon procedure :: extended_line_search end type psqp_class abstract interface subroutine obj_func ( me , nf , x , ff ) !! objective function interface import :: wp , psqp_class implicit none class ( psqp_class ), intent ( inout ) :: me integer :: nf !! the number of variables real ( wp ) :: x ( nf ) !! a vector of variables real ( wp ) :: ff !! the value of the objective function end subroutine obj_func subroutine dobj_func ( me , nf , x , gf ) !! gradient of the objective function interface import :: wp , psqp_class implicit none class ( psqp_class ), intent ( inout ) :: me integer :: nf !! the number of variables real ( wp ) :: x ( nf ) !! a vector of variables real ( wp ) :: gf ( nf ) !! the gradient of the objective function end subroutine dobj_func subroutine con_func ( me , nf , kc , x , fc ) !! constraint function interface import :: wp , psqp_class implicit none class ( psqp_class ), intent ( inout ) :: me integer :: nf !! the number of variables integer :: kc !! the index of the constraint function real ( wp ) :: x ( nf ) !! a vector of variables real ( wp ) :: fc !! the value of the constraint function end subroutine con_func subroutine dcon_func ( me , nf , kc , x , gc ) !! gradient of the constraint function interface import :: wp , psqp_class implicit none class ( psqp_class ), intent ( inout ) :: me integer :: nf !! the number of variables integer :: kc !! the index of the constraint function real ( wp ) :: x ( nf ) !! a vector of variables and real ( wp ) :: gc ( nf ) !! the gradient of the constraint function end subroutine dcon_func subroutine report_f ( me , iter , x , j , f ) !! Report function to call once per iteration to report the solution. import :: wp , psqp_class implicit none class ( psqp_class ), intent ( inout ) :: me integer , intent ( in ) :: iter !! Iteration number real ( wp ), dimension (:), intent ( in ) :: x !! optimization variables real ( wp ), intent ( in ) :: j !! Objective function value real ( wp ), dimension (:), intent ( in ) :: f !! Constraint functions end subroutine report_f end interface contains !*********************************************************************** !*********************************************************************** !> date: 97/01/22 ! ! easy to use subroutine for general nonlinear programming problems. subroutine psqpn ( me , nf , nb , nc , x , bound_type , xl , xu , cf , constraint_type , & cl , cu , ipar , rpar , f , gmax , & cmax , iprnt , iterm , obj , dobj , con , dcon , report ) class ( psqp_class ), intent ( inout ) :: me integer , intent ( in ) :: nf !! number of variables integer , intent ( in ) :: nb !! choice of simple bounds. !! !! * `nb=0` -- simple bounds suppressed. !! * `nb>0` -- simple bounds accepted. integer , intent ( in ) :: nc !! number of general nonlinear constraints. real ( wp ), dimension ( nf ), intent ( inout ) :: x !! x(nf) vector of variables. integer , dimension ( nf ), intent ( in ) :: bound_type !! ix(nf) vector containing types of bounds. !! !! * `ix(i) = 0` -- variable x(i) is unbounded. !! * `ix(i) = 1` -- lower bound xl(i) <= x(i). !! * `ix(i) = 2` -- upper bound x(i) <= xu(i). !! * `ix(i) = 3` -- two side bound xl(i) <= x(i) <= xu(i). !! * `ix(i) = 5` -- variable x(i) is fixed. real ( wp ), dimension ( nf ), intent ( in ) :: xl !! xl(nf) vector containing lower bounds for variables. real ( wp ), dimension ( nf ), intent ( in ) :: xu !! xu(nf) vector containing upper bounds for variables. real ( wp ), dimension ( nc + 1 ), intent ( out ) :: cf !! cf(nc+1) vector containing values of the constraint functions. integer , dimension ( nc ), intent ( in ) :: constraint_type !! ic(nc) vector containing types of constraints: !! !! * `ic(kc) = 0` -- constraint cf(kc) is not used. !! * `ic(kc) = 1` -- lower constraint cl(kc) <= cf(kc). !! * `ic(kc) = 2` -- upper constraint cf(kc) <= cu(kc). !! * `ic(kc) = 3` -- two side constraint cl(kc) <= cf(kc) <= cu(kc). !! * `ic(kc) = 5` -- equality constraint cf(kc) == cl(kc). real ( wp ), dimension ( nc ), intent ( in ) :: cl !! cl(nc) vector containing lower bounds for constraint functions. real ( wp ), dimension ( nc ), intent ( in ) :: cu !! cu(nc) vector containing upper bounds for constraint functions. integer , dimension ( 6 ), intent ( in ) :: ipar !! integer paremeters: !! !! * `ipar(1)`  maximum number of iterations. !! * `ipar(2)`  maximum number of function evaluations. !! * `ipar(3)`  this parameter is not used in the subroutine psqp. !! * `ipar(4)`  this parameter is not used in the subroutine psqp. !! * `ipar(5)`  variable metric update used. !!   `ipar(5)=1` - the bfgs update. !!   `ipar(5)=2` - the hoshino update. !! * `ipar(6)`  correction of the variable metric update if a negative !!   curvature occurs. !!   `ipar(6)=1` - no correction. !!   `ipar(6)=2` - powell's correction. real ( wp ), dimension ( 5 ), intent ( in ) :: rpar !! real parameters: !! !! * `rpar(1)` -- maximum stepsize. !! * `rpar(2)` -- tolerance for change of variables. !! * `rpar(3)` -- tolerance for constraint violations. !! * `rpar(4)` -- tolerance for the gradient of the lagrangian function. !! * `rpar(5)` -- penalty coefficient. real ( wp ), intent ( out ) :: f !! value of the objective function. real ( wp ), intent ( out ) :: gmax !! maximum partial derivative of the lagrangian function. real ( wp ), intent ( out ) :: cmax !! maximum constraint violation. integer , intent ( in ) :: iprnt !! print specification: !! !! * `iprnt=0`      -- no print. !! * `abs(iprnt)=1` -- print of final results. !! * `abs(iprnt)=2` -- print of final results and iterations. !! * `iprnt>0`      -- basic final results. !! * `iprnt<0`      -- extended final results. integer , intent ( out ) :: iterm !! variable that indicates the cause of termination. !! !! * `iterm=1`  -- if abs(x-xo) was less than or equal to tolx in mtesx (usually two) subsequent iterations. !! * `iterm=2`  -- if abs(f-fo) was less than or equal to tolf in mtesf (usually two) subsequent iterations. !! * `iterm=3`  -- if f is less than or equal to tolb. !! * `iterm=4`  -- if gmax is less than or equal to tolg. !! * `iterm=11` -- if nit exceeded mit. iterm=12 - if nfv exceeded mfv. !! * `iterm=13` -- if nfg exceeded mfg. iterm<0 - if the method failed. !! * `iterm=-6` -- then the termination criterion has not been satisfied, but the point obtained if usually acceptable. procedure ( obj_func ) :: obj !! computation of the value of the objective function procedure ( dobj_func ) :: dobj !! computation of the gradient of the objective function procedure ( con_func ) :: con !! computation of the value of the constraint function procedure ( dcon_func ) :: dcon !! computation of the gradient of the constraint function procedure ( report_f ), optional :: report !! iteration report function. Note: this is independent of `iprnt`. !! If this function is associated, each iteration will be reported integer :: lcfd , lcfo , lcg , lcp , lcr , lcz , lg , lgc , lgf , lgo , lh , lia , ls , lxo integer , dimension (:), allocatable :: ia real ( wp ), dimension (:), allocatable :: ra integer , dimension (:), allocatable :: ic !! local copy of `constraint_type` since it is modified integer , dimension (:), allocatable :: ix !! local copy of `bound_type` since it is modified ! set the functions: me % obj => obj me % dobj => dobj me % con => con me % dcon => dcon if ( present ( report )) me % report => report allocate ( ia ( nf ), ra (( nf + nc + 8 ) * nf + 3 * nc + 1 )) allocate ( ic ( nc )) allocate ( ix ( nf )) ic = constraint_type ! make a copy of input ix = bound_type ! make a copy of input lcg = 1 lcfo = lcg + nf * nc lcfd = lcfo + nc + 1 lgc = lcfd + nc lcr = lgc + nf lcz = lcr + nf * ( nf + 1 ) / 2 lcp = lcz + nf lgf = lcp + nc lg = lgf + nf lh = lg + nf ls = lh + nf * ( nf + 1 ) / 2 lxo = ls + nf lgo = lxo + nf lia = 1 call me % psqp ( nf , nb , nc , x , ix , xl , xu , cf , ic , cl , cu , ra , ra ( lcfo ), ra ( lcfd ), & ra ( lgc ), ia , ra ( lcr ), ra ( lcz ), ra ( lcp ), ra ( lgf ), ra ( lg ), ra ( lh ), & ra ( ls ), ra ( lxo ), ra ( lgo ), rpar ( 1 ), rpar ( 2 ), rpar ( 3 ), rpar ( 4 ), & rpar ( 5 ), cmax , gmax , f , ipar ( 1 ), ipar ( 2 ), ipar ( 5 ), ipar ( 6 ), & iprnt , iterm ) deallocate ( ia , ra , ic , ix ) end subroutine psqpn !*********************************************************************** !*********************************************************************** !> date: 97/01/22 ! !  recursive quadratic programming method with the bfgs variable metric !  update for general nonlinear programming problems. ! !### Method !  recursive quadratic programming method with the bfgs variable metric !  update. subroutine psqp ( me , nf , nb , nc , x , ix , xl , xu , cf , ic , cl , cu , cg , cfo , cfd , gc , ica , & cr , cz , cp , gf , g , h , s , xo , go , xmax , tolx , tolc , tolg , rpf , & cmax , gmax , f , mit , mfv , met , mec , iprnt , iterm ) class ( psqp_class ), intent ( inout ) :: me real ( wp ) :: f !! value of the objective function. real ( wp ) :: cmax !! maximum constraint violation. real ( wp ) :: gmax !! maximum partial derivative of the lagrangian function. real ( wp ) :: rpf !! penalty coefficient. real ( wp ) :: tolx !! tolerance for change of variables. real ( wp ) :: tolc !! tolerance for constraint violations. real ( wp ) :: tolg !! tolerance for the gradient of the lagrangian function. real ( wp ) :: told !! real ( wp ) :: tols !! real ( wp ) :: xmax !! maximum stepsize. integer :: iprnt !! print specification. !! !! * iprnt=0      - no print. !! * abs(iprnt)=1 - print of final results. !! * abs(iprnt)=2 - print of final results and iterations. !! * iprnt>0      - basic final results. !! * iprnt<0      - extended final results. integer :: iterm !! variable that indicates the cause of termination. !! !! * iterm=1-if abs(x-xo) was less than or equal to tolx in !!   mtesx (usually two) subsequent iterations. !! * iterm=2-if abs(f-fo) was less than or equal to tolf in !!   mtesf (usually two) subsequent iterations. !! * iterm=3-if f is less than or equal to tolb. !! * iterm=4-if gmax is less than or equal to tolg. !! * iterm=11-if nit exceeded mit. !! * iterm=12-if nfv exceeded mfv. !! * iterm=13-if nfg exceeded mfg. !! * iterm<0-if the method failed. !! * if iterm=-6, then the termination criterion has not been !!   satisfied, but the point obtained if usually acceptable. integer :: met !! variable metric update used. !! !! * met=1 - the bfgs update. !! * met=2 - the hoshino update. integer :: met1 !! integer :: mec !! correction if the negative curvature occurs. !! !! * mec=1 - correction suppressed. !! * mec=2 - powell's correction. integer :: mes !! integer :: mfv !! maximum number of function evaluations. integer :: mit !! maximum number of iterations. integer :: nb !! choice of simple bounds. !! !! * nb=0 - simple bounds suppressed. !! * nb>0 - simple bounds accepted. integer :: nc !! number of linear constraints. integer :: nf !! number of variables. real ( wp ) :: cf ( * ) !! cf(nc+1)  vector containing values of the constraint functions. real ( wp ) :: cg ( * ) !! cg(nf*nc)  matrix whose columns are normals of the linear constraints. real ( wp ) :: cfo ( * ) !! cfo(nc)  vector containing saved values of the constraint functions. real ( wp ) :: cfd ( * ) !! cfd(nc)  vector containing increments of the constraint functions. real ( wp ) :: cl ( * ) !! cl(nc)  vector containing lower bounds for constraint functions. real ( wp ) :: cu ( * ) !! cu(nc)  vector containing upper bounds for constraint functions. real ( wp ) :: cp ( * ) !! real ( wp ) :: cr ( * ) !! cr(nf*(nf+1)/2)  triangular decomposition of kernel !! of the orthogonal projection. real ( wp ) :: cz ( * ) !! cz(nf)  vector of lagrange multipliers. real ( wp ) :: g ( * ) !! g(nf)  gradient of the objective function. real ( wp ) :: gc ( * ) !! gc(nf)  gradient of the selected constraint function. real ( wp ) :: gf ( * ) !! gf(nf)  gradient of the model function. real ( wp ) :: go ( * ) !! go(nf)  gradients difference. real ( wp ) :: h ( * ) !! h(nf*(nf+1)/2)  triangular decomposition or inversion of !! the hessian matrix approximation. real ( wp ) :: s ( * ) !! s(nf)  direction vector. real ( wp ) :: x ( * ) !! x(nf)  vector of variables. real ( wp ) :: xl ( * ) !! xl(nf)  vector containing lower bounds for variables. real ( wp ) :: xu ( * ) !! xu(nf)  vector containing upper bounds for variables. real ( wp ) :: xo ( * ) !! xo(nf)  vectors of variables difference. integer , intent ( inout ) :: ic ( * ) !! ic(nc)  vector containing types of constraints. !! !! * ic(kc)=0 - constraint cf(kc) is not used. !! * ic(kc)=1 - lower constraint cl(kc)<=cf(kc). !! * ic(kc)=2 - upper constraint cf(kc)<=cu(kc). !! * ic(kc)=3 - two side constraint cl(kc)<=cf(kc)<=cu(kc). !! * ic(kc)=5 - equality constraint cf(kc)==cl(kc). integer :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. integer , intent ( inout ) :: ix ( * ) !! ix(nf)  vector containing types of bounds. !! !! * ix(i)=0 - variable x(i) is unbounded. !! * ix(i)=1 - lover bound xl(i)<=x(i). !! * ix(i)=2 - upper bound x(i)<=xu(i). !! * ix(i)=3 - two side bound xl(i)<=x(i)<=xu(i). !! * ix(i)=5 - variable x(i) is fixed. real ( wp ) :: alf1 , alf2 , cmaxo , dmax , eps7 , eps9 , eta0 , & eta2 , eta9 , fmax , fmin , fo , gnorm , p , po , & r , rmax , rmin , ro , snorm , tolb , tolf , & umax , rp , fp , pp , ff , fc integer :: i , idecf , iext , irest , iterd , iterh , iterq , & iters , kbc , kbf , kc , kd , kit , ld , mred , mtesf , & mtesx , n , k , ntesx , iest , inits , kters , maxst , & isys , mfp , nred , ipom , lds if ( abs ( iprnt ) > 1 ) write ( 6 , '(1x,\"entry to psqp :\")' ) ! initiation kbf = 0 kbc = 0 if ( nb > 0 ) kbf = 2 if ( nc > 0 ) kbc = 2 me % nres = 0 me % ndec = 0 me % nrem = 0 me % nadd = 0 me % nit = 0 me % nfv = 0 me % nfg = 0 me % nfh = 0 isys = 0 iest = 0 iext = 0 mtesx = 2 mtesf = 2 inits = 1 iterm = 0 iters = 0 iterd = 0 iterq = 0 mred = 20 irest = 1 iters = 2 kters = 5 idecf = 1 eta0 = 1.0e-15_wp eta2 = 1.0e-15_wp eta9 = huge ( 1.0_wp ) !1.0e60_wp eps7 = 1.0e-15_wp eps9 = 1.0e-8_wp alf1 = 1.0e-10_wp alf2 = 1.0e10_wp fmax = huge ( 1.0_wp ) !1.0e60_wp fmin = - fmax tolb = - fmax dmax = eta9 tolf = 1.0e-16_wp if ( xmax <= 0.0_wp ) xmax = 1.0e+16_wp if ( tolx <= 0.0_wp ) tolx = 1.0e-16_wp if ( tolg <= 0.0_wp ) tolg = 1.0e-6_wp if ( tolc <= 0.0_wp ) tolc = 1.0e-6_wp told = 1.0e-8_wp tols = 1.0e-4_wp if ( rpf <= 0.0_wp ) rpf = 1.0e-4_wp if ( met <= 0 ) met = 1 met1 = 2 if ( mec <= 0 ) mec = 2 mes = 1 if ( mit <= 0 ) mit = 1000 if ( mfv <= 0 ) mfv = 2000 kd = 1 ld = - 1 kit = 0 call mxvset ( nc , 0.0_wp , cp ) ! initial operations with simple bounds if ( kbf > 0 ) then do i = 1 , nf if (( ix ( i ) == 3 . or . ix ( i ) == 4 ) . and . xu ( i ) <= xl ( i )) then xu ( i ) = xl ( i ) ix ( i ) = 5 elseif ( ix ( i ) == 5 . or . ix ( i ) == 6 ) then xl ( i ) = x ( i ) xu ( i ) = x ( i ) ix ( i ) = 5 end if if ( ix ( i ) == 1 . or . ix ( i ) == 3 ) x ( i ) = max ( x ( i ), xl ( i )) if ( ix ( i ) == 2 . or . ix ( i ) == 3 ) x ( i ) = min ( x ( i ), xu ( i )) end do end if ! initial operations with general constraints if ( kbc > 0 ) then k = 0 do kc = 1 , nc if (( ic ( kc ) == 3 . or . ic ( kc ) == 4 ) . and . cu ( kc ) <= cl ( kc )) then cu ( kc ) = cl ( kc ) ic ( kc ) = 5 elseif ( ic ( kc ) == 5 . or . ic ( kc ) == 6 ) then cu ( kc ) = cl ( kc ) ic ( kc ) = 5 end if k = k + nf end do end if if ( kbf > 0 ) then do i = 1 , nf if ( ix ( i ) >= 5 ) ix ( i ) = - ix ( i ) if ( ix ( i ) <= 0 ) then elseif (( ix ( i ) == 1 . or . ix ( i ) == 3 ) . and . x ( i ) <= xl ( i )) then x ( i ) = xl ( i ) elseif (( ix ( i ) == 2 . or . ix ( i ) == 3 ) . and . x ( i ) >= xu ( i )) then x ( i ) = xu ( i ) end if call test_simple_bound ( x , ix , xl , xu , eps9 , i ) if ( ix ( i ) > 10 ) ix ( i ) = 10 - ix ( i ) end do end if fo = fmin gmax = eta9 dmax = eta9 main : do lds = ld call me % compute_obj_and_dobj ( nf , x , gf , gf , ff , f , kd , ld , iext ) ld = lds call me % compute_con_and_dcon ( nf , nc , x , fc , cf , cl , cu , ic , gc , cg , cmax , kd , ld ) cf ( nc + 1 ) = f ! JW : seems to start with iter 0, so add 1 to iterations for report output if ( associated ( me % report )) call me % report ( me % nit + 1 , x ( 1 : nf ), j = f , f = cf ( 1 : nc )) if ( abs ( iprnt ) > 1 ) & write ( 6 , '(1x,\"nit=\",i9,2x,\"nfv=\",i9,2x,\"nfg=\",i9,2x,\"f=\",g13.6,2x,\"c=\",e8.1,2x,\"g=\",e8.1)' ) & me % nit , me % nfv , me % nfg , f , cmax , gmax ! start of the iteration with tests for termination. if ( iterm < 0 ) exit main if ( iters /= 0 ) then if ( f <= tolb ) then iterm = 3 exit main end if if ( dmax <= tolx ) then iterm = 1 ntesx = ntesx + 1 if ( ntesx >= mtesx ) exit main else ntesx = 0 end if end if if ( me % nit >= mit ) then iterm = 11 exit main end if if ( me % nfv >= mfv ) then iterm = 12 exit main end if iterm = 0 me % nit = me % nit + 1 restart : do ! restart n = nf if ( irest > 0 ) then call mxdsmi ( n , h ) ld = min ( ld , 1 ) idecf = 1 if ( kit < me % nit ) then me % nres = me % nres + 1 kit = me % nit else iterm = - 10 if ( iters < 0 ) iterm = iters - 5 exit main end if end if ! direction determination using a quadratic programming procedure call mxvcop ( nc + 1 , cf , cfo ) mfp = 2 ipom = 0 dir_loop : do call me % dual_range_space_quad_prog ( nf , nc , x , ix , xl , xu , cf , cfd , ic , ica , & cl , cu , cg , cr , cz , g , gf , h , s , mfp , kbf , & kbc , idecf , eta2 , eta9 , eps7 , & eps9 , umax , gmax , n , iterq ) if ( iterq < 0 ) then if ( ipom < 10 ) then ipom = ipom + 1 call transform_incompatible_qp_subproblem ( nc , cf , ic , cl , cu , kbc ) cycle dir_loop end if iterd = iterq - 10 else ipom = 0 iterd = 1 gmax = mxvmax ( nf , g ) gnorm = sqrt ( mxvdot ( nf , g , g )) snorm = sqrt ( mxvdot ( nf , s , s )) end if exit dir_loop end do dir_loop if ( iterd < 0 ) iterm = iterd if ( iterm == 0 ) then call mxvcop ( nc + 1 , cfo , cf ) ! test for sufficient descent p = mxvdot ( nf , g , s ) irest = 1 if ( snorm <= 0.0_wp ) then elseif ( p + told * gnorm * snorm <= 0.0_wp ) then irest = 0 end if if ( irest /= 0 ) cycle restart nred = 0 rmin = alf1 * gnorm / snorm rmax = min ( alf2 * gnorm / snorm , xmax / snorm ) if ( gmax <= tolg . and . cmax <= tolc ) then iterm = 4 exit main end if call compute_new_penalty_parameters ( nf , n , nc , ica , cz , cp ) call mxvina ( nc , ic ) call compute_augmented_lagrangian ( nf , n , nc , cf , ic , ica , cl , cu , cz , rpf , fc , f ) ! preparation of line search ro = 0.0_wp fo = f po = p cmaxo = cmax call mxvcop ( nf , x , xo ) call mxvcop ( nf , g , go ) call mxvcop ( nf , gf , cr ) call mxvcop ( nc + 1 , cf , cfo ) line_search : do ! line search without directional derivatives call me % extended_line_search ( r , ro , rp , f , fo , fp , po , pp , fmin , fmax , & rmin , rmax , tols , kd , ld , me % nit , kit , nred , & mred , maxst , iest , inits , iters , kters , mes , isys ) if ( isys == 0 ) then kd = 1 ! decision after unsuccessful line search if ( iters <= 0 ) then r = 0.0_wp f = fo p = po call mxvcop ( nf , xo , x ) call mxvcop ( nf , cr , gf ) call mxvcop ( nc + 1 , cfo , cf ) irest = 1 ld = kd cycle restart end if ! computation of the value and the gradient of the objective ! function together with the values and the gradients of the ! approximated functions if ( kd > ld ) then lds = ld call me % compute_obj_and_dobj ( nf , x , gf , gf , ff , f , kd , ld , iext ) ld = lds call me % compute_con_and_dcon ( nf , nc , x , fc , cf , cl , cu , ic , gc , & cg , cmax , kd , ld ) end if ! preparation of variable metric update call mxvcop ( nf , gf , g ) call dual_range_space_qp ( nf , n , x , xo , ica , cg , cz , g , go , r , f , fo , p , po , & cmax , cmaxo , dmax , kd , ld , iters ) ! variable metric update call bfgs_variable_metric_update ( n , h , g , s , xo , go , r , po , me % nit , & kit , iterh , met , met1 , mec ) ! if (mer>0.and.iterh>0) irest=1 cycle main ! end of the iteration else ! go to (11174,11172) isys+1 call mxvdir ( nf , r , s , xo , x ) lds = ld call me % compute_obj_and_dobj ( nf , x , gf , g , ff , f , kd , ld , iext ) ld = lds call me % compute_con_and_dcon ( nf , nc , x , fc , cf , cl , cu , ic , gc , cg , cmax , kd , ld ) cf ( nc + 1 ) = f call compute_augmented_lagrangian ( nf , n , nc , cf , ic , ica , cl , cu , cz , rpf , fc , f ) end if end do line_search end if exit restart end do restart exit main end do main if ( iprnt > 1 . or . iprnt < 0 ) write ( 6 , '(1x,\"exit from psqp :\")' ) if ( iprnt /= 0 ) & write ( 6 , '(1x,\"nit=\",i4,2x,\"nfv=\",i4,2x,\"nfg=\",i4,2x,\"f=\",g13.6,2x,\"c=\",e8.1,2x,\"g=\",e8.1,2x,\"iterm=\",i3)' ) & me % nit , me % nfv , me % nfg , f , cmax , gmax , iterm if ( iprnt < 0 ) write ( 6 , '(1x,\"x=\",5(g14.7,1x):/(3x,5(g14.7,1x)))' ) ( x ( i ), i = 1 , nf ) end subroutine psqp !*********************************************************************** !> date: 97/12/01 ! ! computation of the value and the gradient of the constraint function. ! !@note This routine was formerly called `pc1f01`. subroutine compute_con_and_dcon ( me , nf , nc , x , fc , cf , cl , cu , ic , gc , cg , cmax , kd , ld ) class ( psqp_class ), intent ( inout ) :: me real ( wp ) :: fc !! value of the selected constraint function. real ( wp ) :: cmax !! maximum constraint violation. integer :: kd !! degree of required derivatives. integer :: ld !! degree of previously computed derivatives. integer :: nc !! number of constraints. integer :: nf !! number of variables. real ( wp ) :: cf ( * ) !! cf(nc) vector containing values of constraint functions. real ( wp ) :: cl ( * ) !! cl(nc) vector containing lower bounds for constraint functions. real ( wp ) :: cu ( * ) !! cu(nc) vector containing upper bounds for constraint functions. integer :: ic ( * ) !! ic(nc) vector containing types of constraints. real ( wp ) :: gc ( nf ) !! gc(nf) gradient of the selected constraint function. real ( wp ) :: cg ( * ) !! cg(nf*nc) matrix whose columns are gradients of constraint functions. real ( wp ) :: x ( nf ) !! x(nf) vector of variables. real ( wp ) :: pom , temp integer :: kc if ( kd <= ld ) return if ( ld < 0 ) cmax = 0.0_wp do kc = 1 , nc if ( kd >= 0 ) then if ( ld < 0 ) then call me % con ( nf , kc , x , fc ) cf ( kc ) = fc if ( ic ( kc ) > 0 ) then pom = 0.0_wp temp = cf ( kc ) if ( ic ( kc ) == 1 . or . ic ( kc ) >= 3 ) pom = min ( pom , temp - cl ( kc )) if ( ic ( kc ) == 2 . or . ic ( kc ) >= 3 ) pom = min ( pom , cu ( kc ) - temp ) if ( pom < 0.0_wp ) cmax = max ( cmax , - pom ) end if else fc = cf ( kc ) end if if ( kd >= 1 ) then if ( ld >= 1 ) then call mxvcop ( nf , cg (( kc - 1 ) * nf + 1 ), gc ) else call me % dcon ( nf , kc , x , gc ) call mxvcop ( nf , gc , cg (( kc - 1 ) * nf + 1 )) end if end if end if end do ld = kd end subroutine compute_con_and_dcon !*********************************************************************** !> date: 97/12/01 ! ! computation of the value and the gradient of the objective function. ! !@note This routine was formerly called `pf1f01`. subroutine compute_obj_and_dobj ( me , nf , x , gf , g , ff , f , kd , ld , iext ) class ( psqp_class ), intent ( inout ) :: me integer , intent ( in ) :: nf !! number of variables. real ( wp ), intent ( in ) :: x ( nf ) !! x(nf)   vector of variables. real ( wp ), intent ( out ) :: gf ( nf ) !! gf(nf)  gradient of the model function. real ( wp ), intent ( out ) :: g ( nf ) !! g(nf)   gradient of the objective function. real ( wp ), intent ( out ) :: ff !! value of the model function. real ( wp ), intent ( out ) :: f !! value of the objective function. integer , intent ( in ) :: kd !! degree of required derivatives. integer , intent ( inout ) :: ld !! degree of previously computed derivatives. integer , intent ( in ) :: iext !! type of extremum. !! !! * `iext=0` -- minimum. !! * `iext=1` -- maximum. if ( kd <= ld ) return if ( ld < 0 ) then me % nfv = me % nfv + 1 call me % obj ( nf , x , ff ) if ( iext <= 0 ) then f = ff else f = - ff end if end if if ( kd >= 1 ) then if ( ld < 1 ) then me % nfg = me % nfg + 1 call me % dobj ( nf , x , gf ) if ( iext > 0 ) call mxvneg ( nf , gf , g ) end if end if ld = kd end subroutine compute_obj_and_dobj !*********************************************************************** !> date: 97/12/01 ! ! dual range space quadratic programming method. ! !@note This routine was formerly called `plqdb1`. subroutine dual_range_space_quad_prog ( me , nf , nc , x , ix , xl , xu , cf , cfd , & ic , ica , cl , cu , cg , cr , cz , g , go , h , s , & mfp , kbf , kbc , idecf , & eta2 , eta9 , eps7 , eps9 , umax , gmax , n , iterq ) class ( psqp_class ), intent ( inout ) :: me integer :: nf !! number of variables. integer :: nc !! number of linear constraints. integer :: ix ( * ) !! ix(nf)  vector containing types of bounds. integer :: ic ( * ) !! ic(nc)  vector containing types of constraints. integer :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. integer :: mfp !! type of feasible point. !! !! * mfp=1-arbitrary feasible point. !! * mfp=2-optimum feasible point. !! * mfp=3-repeated solution. integer :: kbf !! specification of simple bounds. !! !! * kbf=0-no simple bounds. !! * kbf=1-one sided simple bounds. !! * kbf=2=two sided simple bounds. integer :: kbc !! specification of linear constraints. !! !! * kbc=0 - no linear constraints. !! * kbc=1 - one sided linear constraints. !! * kbc=2 - two sided linear constraints. integer :: idecf !! decomposition indicator. !! !! * idecf=0  - no decomposition. !! * idecf=1  - gill-murray decomposition. !! * idecf=9  - inversion. !! * idecf=10 - diagonal matrix. integer :: n !! dimension of the manifold defined by active constraints. integer :: iterq !! type of feasible point. !! !! * iterq=1  - arbitrary feasible point. !! * iterq=2  - optimum feasible point. !! * iterq=-1 - feasible point does not exists. !! * iterq=-2 - optimum feasible point does not exists. real ( wp ) :: x ( * ) !! x(nf)   vector of variables. real ( wp ) :: xl ( * ) !! xl(nf)  vector containing lower bounds for variables. real ( wp ) :: xu ( * ) !! xu(nf)  vector containing upper bounds for variables. real ( wp ) :: cf ( * ) !! cf(nf)  vector containing values of the constraint functions. real ( wp ) :: cfd ( * ) !! cfd(nc)  vector containing increments of the constraint functions. real ( wp ) :: cl ( * ) !! cl(nc)  vector containing lower bounds for constraint functions. real ( wp ) :: cu ( * ) !! cu(nc)  vector containing upper bounds for constraint functions. real ( wp ) :: cg ( * ) !! cg(nf*nc)  matrix whose columns are normals of the linear constraints. real ( wp ) :: cr ( * ) !! cr(nf*(nf+1)/2)  triangular decomposition of kernel of the orthogonal projection. real ( wp ) :: cz ( * ) !! cz(nf)  vector of lagrange multipliers. real ( wp ) :: g ( * ) !! g(nf)  gradient of the lagrangian function. real ( wp ) :: go ( * ) !! go(nf)  saved gradient of the objective function. real ( wp ) :: h ( * ) !! h(nf*(nf+1)/2)  triangular decomposition or inversion !! of the hessian matrix approximation. real ( wp ) :: s ( * ) !! s(nf)  direction vector. real ( wp ) :: eta2 !! tolerance for positive definiteness of the hessian matrix. real ( wp ) :: eta9 !! maximum for real numbers. real ( wp ) :: eps7 !! tolerance for linear independence of constraints. real ( wp ) :: eps9 !! tolerance for activity of constraints. real ( wp ) :: umax !! maximum absolute value of a negative lagrange multiplier. real ( wp ) :: gmax !! maximum absolute value of a partial derivative. real ( wp ) :: con , temp , step , step1 , step2 , dmax , par , snorm integer :: nca , ncr , i , j , k , iold , jold , inew , jnew , knew , & inf , ier , krem , kc , nred con = eta9 if ( idecf < 0 ) idecf = 1 if ( idecf == 0 ) then ! gill-murray decomposition temp = eta2 call mxdpgf ( nf , h , inf , temp , step ) me % ndec = me % ndec + 1 idecf = 1 end if if ( idecf >= 2 . and . idecf <= 8 ) then iterq = - 10 return end if ! initiation nred = 0 jold = 0 jnew = 0 iterq = 0 dmax = 0.0_wp if ( mfp /= 3 ) then n = nf nca = 0 ncr = 0 if ( kbf > 0 ) call mxvina ( nf , ix ) if ( kbc > 0 ) call mxvina ( nc , ic ) end if outer : do ! direction determination call mxvneg ( nf , go , s ) do j = 1 , nca kc = ica ( j ) if ( kc > 0 ) then call mxvdir ( nf , cz ( j ), cg (( kc - 1 ) * nf + 1 ), s , s ) else k = - kc s ( k ) = s ( k ) + cz ( j ) end if end do call mxvcop ( nf , s , g ) if ( idecf == 1 ) then call mxdpgb ( nf , h , s , 0 ) else call mxdsmm ( nf , h , g , s ) end if if ( iterq /= 3 ) then ! check of feasibility inew = 0 par = 0.0_wp call determine_new_active_linear_constr ( nf , nc , cf , cfd , ic , cl , cu , & cg , s , eps9 , par , kbc , inew , knew ) call determine_new_active_simple_bound ( nf , ix , x , xl , xu , s , kbf , inew , & knew , eps9 , par ) if ( inew == 0 ) then ! solution achieved call mxvneg ( nf , g , g ) iterq = 2 return else snorm = 0.0_wp end if inner : do ier = 0 ! stepsize determination call update_tri_decomp_general ( nf , n , ica , cg , cr , h , s , g , eps7 , gmax , umax , & idecf , inew , me % nadd , ier , 1 ) call mxdprb ( nca , cr , g , - 1 ) if ( knew < 0 ) call mxvneg ( nca , g , g ) ! primal stepsize if ( ier /= 0 ) then step1 = con else step1 = - par / umax end if ! dual stepsize iold = 0 step2 = con do j = 1 , nca kc = ica ( j ) if ( kc >= 0 ) then k = ic ( kc ) else i = - kc k = ix ( i ) end if if ( k <= - 5 ) then elseif (( k == - 1 . or . k == - 3. ) . and . g ( j ) <= 0.0_wp ) then elseif (. not . (( k == - 2 . or . k == - 4. ) . and . g ( j ) >= 0.0_wp )) then temp = cz ( j ) / g ( j ) if ( step2 > temp ) then iold = j step2 = temp end if end if end do ! final stepsize step = min ( step1 , step2 ) if ( step >= con ) then ! feasible solution does not exist iterq = - 1 return end if ! new lagrange multipliers dmax = step call mxvdir ( nca , - step , g , cz , cz ) snorm = snorm + sign ( 1 , knew ) * step par = par - ( step / step1 ) * par if ( step == step1 ) then if ( n <= 0 ) then ! impossible situation iterq = - 5 return end if ! constraint addition if ( ier == 0 ) then n = n - 1 nca = nca + 1 ncr = ncr + nca cz ( nca ) = snorm end if if ( inew > 0 ) then kc = inew call mxvinv ( ic , kc , knew ) elseif ( abs ( knew ) == 1 ) then i = - inew call mxvinv ( ix , i , knew ) else i = - inew if ( knew > 0 ) ix ( i ) = - 3 if ( knew < 0 ) ix ( i ) = - 4 end if nred = nred + 1 me % nadd = me % nadd + 1 jnew = inew jold = 0 cycle outer end if ! constraint deletion do j = iold , nca - 1 cz ( j ) = cz ( j + 1 ) end do call me % ops_after_constr_deletion ( nf , nc , ix , ic , ica , cr , ic , g , n , iold , krem , ier ) ncr = ncr - nca nca = nca - 1 jold = iold jnew = 0 if ( kbc > 0 ) call mxvina ( nc , ic ) if ( kbf > 0 ) call mxvina ( nf , ix ) do j = 1 , nca kc = ica ( j ) if ( kc > 0 ) then ic ( kc ) = - ic ( kc ) else kc = - kc ix ( kc ) = - ix ( kc ) end if end do end do inner end if exit outer end do outer end subroutine dual_range_space_quad_prog !*********************************************************************** !> date: 97/12/01 ! ! triangular decomposition of kernel of the general projection ! is updated after constraint addition. ! !@note This routine was formerly called `pladr1`. subroutine update_tri_decomp_general ( nf , n , ica , cg , cr , h , s , g , eps7 , & gmax , umax , idecf , inew , nadd , ier , job ) integer :: nf !! declared number of variables. integer :: n !! actual number of variables. integer :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. integer :: idecf !! decomposition indicator. !! !! * idecf=0-no decomposition. !! * idecf=1-gill-murray decomposition. !! * idecf=9-inversion. !! * idecf=10-diagonal matrix. integer :: inew !! index of the new active constraint. integer :: nadd !! number of constraint additions. integer :: ier !! error indicator. integer :: job !! specification of computation. !! output vector g is not or is !! computed in case when n<=0 if !! job=0 or job=1 respectively. real ( wp ) :: cg ( * ) !! cg(nf*nc)  matrix whose columns are normals of !! the linear constraints. real ( wp ) :: cr ( * ) !! cr(nf*(nf+1)/2)  triangular decomposition of !! kernel of the orthogonal projection. real ( wp ) :: h ( * ) !! h(nf*(nf+1)/2)  triangular decomposition or !! inversion of the hessian matrix approximation. real ( wp ) :: s ( * ) !! s(nf)  auxiliary vector. real ( wp ) :: g ( * ) !! g(nf)  vector used in the dual range space !! quadratic programming method. real ( wp ) :: eps7 !! tolerance for linear independence of constraints. real ( wp ) :: gmax !! maximum absolute value of a partial derivative. real ( wp ) :: umax !! maximum absolute value of a negative !! lagrange multiplier. integer :: nca , ncr , jcg , j , k , l ier = 0 if ( job == 0 . and . n <= 0 ) ier = 2 if ( inew == 0 ) ier = 3 if ( idecf /= 1 . and . idecf /= 9 ) ier = - 2 if ( ier /= 0 ) return nca = nf - n ncr = nca * ( nca + 1 ) / 2 if ( inew > 0 ) then jcg = ( inew - 1 ) * nf + 1 if ( idecf == 1 ) then call mxvcop ( nf , cg ( jcg ), s ) call mxdpgb ( nf , h , s , 0 ) else call mxdsmm ( nf , h , cg ( jcg ), s ) end if gmax = mxvdot ( nf , cg ( jcg ), s ) else k = - inew if ( idecf == 1 ) then call mxvset ( nf , 0.0_wp , s ) s ( k ) = 1.0_wp call mxdpgb ( nf , h , s , 0 ) else call mxdsmv ( nf , h , s , k ) end if gmax = s ( k ) end if do j = 1 , nca l = ica ( j ) if ( l > 0 ) then g ( j ) = mxvdot ( nf , cg (( l - 1 ) * nf + 1 ), s ) else l = - l g ( j ) = s ( l ) end if end do if ( n == 0 ) then call mxdprb ( nca , cr , g , 1 ) umax = 0.0_wp ier = 2 return elseif ( nca == 0 ) then umax = gmax else call mxdprb ( nca , cr , g , 1 ) umax = gmax - mxvdot ( nca , g , g ) call mxvcop ( nca , g , cr ( ncr + 1 )) end if if ( umax <= eps7 * gmax ) then ier = 1 return else nca = nca + 1 ncr = ncr + nca ica ( nca ) = inew cr ( ncr ) = sqrt ( umax ) if ( job == 0 ) then n = n - 1 nadd = nadd + 1 end if end if end subroutine update_tri_decomp_general !*********************************************************************** !> date: 97/12/01 ! ! determination of the new active linear constraint. ! !@note This routine was formerly called `plminn`. subroutine determine_new_active_linear_constr ( nf , nc , cf , cfd , ic , cl , cu , & cg , s , eps9 , par , kbc , inew , knew ) integer :: nf !! number of variables. integer :: nc !! number of constraints. integer :: ic ( * ) !! ic(nc)  vector containing types of constraints. integer :: kbc !! specification of linear constraints. !! !! * kbc=0 - no linear constraints. !! * kbc=1 - one sided linear constraints. !! * kbc=2 - two sided linear constraints. integer :: inew !! index of the new active constraint. integer :: knew !! signum of the new active normal. real ( wp ) :: cf ( * ) !! cf(nc)  vector containing values of the !! constraint functions. real ( wp ) :: cfd ( * ) !! cfd(nc)  vector containing increments of !! the constraint functions. real ( wp ) :: cl ( * ) !! cl(nc)  vector containing lower bounds for !! constraint functions. real ( wp ) :: cu ( * ) !! cu(nc)  vector containing upper bounds for !! constraint functions. real ( wp ) :: cg ( * ) !! cg(nf*nc)  matrix whose columns are normals !! of the linear constraints. real ( wp ) :: s ( * ) !! s(nf)  direction vector. real ( wp ) :: eps9 !! tolerance for active constraints. real ( wp ) :: par !! auxiliary variable. real ( wp ) :: temp , pom integer :: jcg , kc if ( kbc > 0 ) then jcg = 1 do kc = 1 , nc if ( ic ( kc ) > 0 ) then temp = mxvdot ( nf , cg ( jcg ), s ) cfd ( kc ) = temp temp = cf ( kc ) + temp if ( ic ( kc ) == 1 . or . ic ( kc ) >= 3 ) then pom = temp - cl ( kc ) if ( pom < min ( par , - eps9 * max ( abs ( cl ( kc )), 1.0_wp ))) then inew = kc knew = 1 par = pom end if end if if ( ic ( kc ) == 2 . or . ic ( kc ) >= 3 ) then pom = cu ( kc ) - temp if ( pom < min ( par , - eps9 * max ( abs ( cu ( kc )), 1.0_wp ))) then inew = kc knew = - 1 par = pom end if end if end if jcg = jcg + nf end do end if end subroutine determine_new_active_linear_constr !*********************************************************************** !> date: 91/12/01 ! ! determination of the new active simple bound. ! !@note This routine was formerly called `plmins`. subroutine determine_new_active_simple_bound ( nf , ix , xo , xl , xu , s , kbf , & inew , knew , eps9 , par ) real ( wp ) :: eps9 !! tolerance for active constraints. real ( wp ) :: par !! auxiliary variable. integer :: inew !! index of the new active constraint. integer :: kbf !! specification of simple bounds. !! !! * kbf=0-no simple bounds. !! * kbf=1-one sided simple bounds. !! * kbf=2=two sided simple bounds. integer :: knew !! signum of the new normal. integer :: nf !! declared number of variables. real ( wp ) :: s ( * ) !! s(nf)  direction vector. real ( wp ) :: xl ( * ) !! xl(nf)  vector containing lower bounds !! for variables. real ( wp ) :: xo ( * ) !! xo(nf)  saved vector of variables. real ( wp ) :: xu ( * ) !! xu(nf)  vector containing upper bounds !! for variables. integer :: ix ( * ) !! ix(nf)  vector containing types of bounds. real ( wp ) :: pom , temp integer :: i if ( kbf > 0 ) then do i = 1 , nf if ( ix ( i ) > 0 ) then temp = 1.0_wp if ( ix ( i ) == 1 . or . ix ( i ) >= 3 ) then pom = xo ( i ) + s ( i ) * temp - xl ( i ) if ( pom < min ( par , - eps9 * max ( abs ( xl ( i )), temp ))) then inew = - i knew = 1 par = pom end if end if if ( ix ( i ) == 2 . or . ix ( i ) >= 3 ) then pom = xu ( i ) - s ( i ) * temp - xo ( i ) if ( pom < min ( par , - eps9 * max ( abs ( xu ( i )), temp ))) then inew = - i knew = - 1 par = pom end if end if end if end do end if end subroutine determine_new_active_simple_bound !*********************************************************************** !> date: 97/12/01 ! ! test on activity of a given simple bound. ! !@note This routine was formerly called `plnews`. subroutine test_simple_bound ( x , ix , xl , xu , eps9 , i ) real ( wp ), intent ( in ) :: x ( * ) !! x(nf)  vector of variables. integer , intent ( inout ) :: ix ( * ) !! ix(nf)  vector containing types of bounds. real ( wp ), intent ( in ) :: xl ( * ) !! xl(nf)  vector containing lower bounds for variables. real ( wp ), intent ( in ) :: xu ( * ) !! xu(nf)  vector containing upper bounds for variables. real ( wp ), intent ( in ) :: eps9 !! tolerance for active constraints. integer , intent ( in ) :: i !! index of tested simple bound. real ( wp ) :: temp temp = 1.0_wp if ( ix ( i ) <= 0 ) then elseif ( ix ( i ) == 1 ) then if ( x ( i ) <= xl ( i ) + eps9 * max ( abs ( xl ( i )), temp )) then ix ( i ) = 11 end if elseif ( ix ( i ) == 2 ) then if ( x ( i ) >= xu ( i ) - eps9 * max ( abs ( xu ( i )), temp )) then ix ( i ) = 12 end if elseif ( ix ( i ) == 3 . or . ix ( i ) == 4 ) then if ( x ( i ) <= xl ( i ) + eps9 * max ( abs ( xl ( i )), temp )) then ix ( i ) = 13 end if if ( x ( i ) >= xu ( i ) - eps9 * max ( abs ( xu ( i )), temp )) then ix ( i ) = 14 end if end if end subroutine test_simple_bound !*********************************************************************** !> date: 98/12/01 ! ! transformation of the incompatible quadratic programming subproblem. ! !@note This routine was formerly called `plredl`. subroutine transform_incompatible_qp_subproblem ( nc , cf , ic , cl , cu , kbc ) integer :: nc !! number of current linear constraints. integer :: ic ( nc ) !! ic(nc)  vector containing types of constraints. integer :: kbc !! specification of linear constraints. !! !! * kbc=0-no linear constraints. !! * kbc=1-one sided linear constraints. !! * kbc=2=two sided linear constraints. real ( wp ) :: cf ( * ) !! cf(nf)  vector containing values of the constraint functions. real ( wp ) :: cl ( * ) !! cl(nc)  vector containing lower bounds for constraint functions. real ( wp ) :: cu ( * ) !! cu(nc)  vector containing upper bounds for constraint functions. real ( wp ) :: temp integer :: k , kc if ( kbc > 0 ) then do kc = 1 , nc k = ic ( kc ) if ( abs ( k ) == 1 . or . abs ( k ) == 3 . or . abs ( k ) == 4 ) then temp = ( cf ( kc ) - cl ( kc )) if ( temp < 0 ) cf ( kc ) = cl ( kc ) + 0.1_wp * temp end if if ( abs ( k ) == 2 . or . abs ( k ) == 3 . or . abs ( k ) == 4 ) then temp = ( cf ( kc ) - cu ( kc )) if ( temp > 0 ) cf ( kc ) = cu ( kc ) + 0.1_wp * temp end if if ( abs ( k ) == 5 . or . abs ( k ) == 6 ) then temp = ( cf ( kc ) - cl ( kc )) cf ( kc ) = cl ( kc ) + 0.1_wp * temp end if end do end if end subroutine transform_incompatible_qp_subproblem !*********************************************************************** !> date: 91/12/01 ! ! operations after constraint deletion. ! !@note This routine was formerly called `plrmf0`. subroutine ops_after_constr_deletion ( me , nf , nc , ix , ia , iaa , ar , & ic , s , n , iold , krem , ier ) class ( psqp_class ), intent ( inout ) :: me integer :: ier !! error indicator. integer :: iold !! index of the old active constraint. integer :: krem !! auxiliary variable. integer :: n !! actual number of variables. integer :: nc !! number of constraints. integer :: nf !! declared number of variables. real ( wp ) :: ar ( * ) !! ar((nf+1)*(nf+2)/2)  triangular decomposition !! of kernel of the orthogonal projection. real ( wp ) :: s ( * ) !! s(nf+1)  auxiliary vector. integer :: ia ( * ) !! ia(na)  vector containing types of deviations. integer :: iaa ( * ) !! iaa(nf+1)  vector containing indices of active !! functions. integer :: ic ( * ) !! ic(nc)  vector containing types of constraints. integer :: ix ( * ) !! ix(nf)  vector containing types of bounds. integer :: l call update_tri_decomp_orthogonal ( nf , iaa , ar , s , n , iold , krem , ier ) n = n + 1 me % nrem = me % nrem + 1 l = iaa ( nf - n + 1 ) if ( l > nc ) then l = l - nc ia ( l ) = - ia ( l ) elseif ( l > 0 ) then ic ( l ) = - ic ( l ) else l = - l ix ( l ) = - ix ( l ) end if end subroutine ops_after_constr_deletion !*********************************************************************** !> date: 91/12/01 ! ! triangular decomposition of kernel of the orthogonal projection is ! updated after constraint deletion. ! !@note This routine was formerly called `plrmr0`. subroutine update_tri_decomp_orthogonal ( nf , ica , cr , g , n , iold , krem , ier ) integer :: ier !! error indicator. integer :: iold !! index of the old active constraint. integer :: krem !! auxiliary variable. integer :: n !! actual number of variables. integer :: nf !! declared number of variables. real ( wp ) :: cr ( * ) !! cr(nf*(nf+1)/2)  triangular decomposition !! of kernel of the orthogonal projection. real ( wp ) :: g ( * ) !! g(nf)  auxiliary vector. integer :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. real ( wp ) :: ck , cl integer :: i , j , k , kc , l , nca nca = nf - n if ( iold < nca ) then k = iold * ( iold - 1 ) / 2 kc = ica ( iold ) call mxvcop ( iold , cr ( k + 1 ), g ) call mxvset ( nca - iold , 0.0_wp , g ( iold + 1 )) k = k + iold do i = iold + 1 , nca k = k + i call mxvort ( cr ( k - 1 ), cr ( k ), ck , cl , ier ) call mxvrot ( g ( i - 1 ), g ( i ), ck , cl , ier ) l = k do j = i , nca - 1 l = l + j call mxvrot ( cr ( l - 1 ), cr ( l ), ck , cl , ier ) end do end do k = iold * ( iold - 1 ) / 2 do i = iold , nca - 1 l = k + i ica ( i ) = ica ( i + 1 ) call mxvcop ( i , cr ( l + 1 ), cr ( k + 1 )) k = l end do ica ( nca ) = kc call mxvcop ( nca , g , cr ( k + 1 )) end if krem = 1 end subroutine update_tri_decomp_orthogonal !*********************************************************************** !> date: 91/12/01 ! ! extrapolation or interpolation for line search without directional ! derivatives. ! !### Method ! extrapolation or interpolation with standard model functions. ! !@note This routine was formerly called `pnint3`. subroutine line_search_interpolation ( ro , rl , ru , ri , fo , fl , fu , fi , & po , r , mode , mtyp , merr ) real ( wp ) :: fo !! value of the objective function for r=ro. real ( wp ) :: fl !! value of the objective function for r=rl. real ( wp ) :: fu !! value of the objective function for r=ru. real ( wp ) :: fi !! value of the objective function for r=ri. real ( wp ) :: po !! initial value of the directional derivative. real ( wp ) :: r !! value of the stepsize parameter obtained. real ( wp ) :: rl !! lower value of the stepsize parameter. real ( wp ) :: ru !! upper value of the stepsize parameter. real ( wp ) :: ri !! inner value of the stepsize parameter. real ( wp ) :: ro !! initial value of the stepsize parameter. integer :: merr !! error indicator. merr=0 for normal return. integer :: mode !! mode of line search. integer :: mtyp !! method selection !! !! * mtyp=1 - bisection. !! * mtyp=2 - two point quadratic interpolation. !! * mtyp=2 - three point quadratic interpolation. real ( wp ) :: ai , al , au , den , dis integer :: ntyp logical :: l1 , l2 real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: two = 2.0_wp real ( wp ), parameter :: three = 3.0_wp real ( wp ), parameter :: c1l = 1.1_wp real ( wp ), parameter :: c1u = 100 0.0_wp real ( wp ), parameter :: c2l = 1.0e-2_wp real ( wp ), parameter :: c2u = 0.9_wp real ( wp ), parameter :: c3l = 1.0e-1_wp merr = 0 if ( mode <= 0 ) return if ( po >= zero ) then merr = 2 return elseif ( ru <= rl ) then merr = 3 return end if l1 = rl <= ro l2 = ri <= rl main : do ntyp = mtyp , 1 , - 1 if ( ntyp == 1 ) then ! bisection if ( mode == 1 ) then r = two * ru return elseif ( ri - rl <= ru - ri ) then r = half * ( ri + ru ) return else r = half * ( rl + ri ) return end if elseif ( ntyp == mtyp . and . l1 ) then if (. not . l2 ) ai = ( fi - fo ) / ( ri * po ) au = ( fu - fo ) / ( ru * po ) end if if ( l1 . and . ( ntyp == 2 . or . l2 )) then ! two point quadratic extrapolation or interpolation if ( au >= one ) cycle main r = half * ru / ( one - au ) elseif (. not . l1 . or . . not . l2 . and . ntyp == 3 ) then ! three point quadratic extrapolation or interpolation al = ( fi - fl ) / ( ri - rl ) au = ( fu - fi ) / ( ru - ri ) den = au - al if ( den <= zero ) cycle main r = ri - half * ( au * ( ri - rl ) + al * ( ru - ri )) / den elseif ( l1 . and . . not . l2 . and . ntyp == 4 ) then ! three point cubic extrapolation or interpolation dis = ( ai - one ) * ( ru / ri ) den = ( au - one ) * ( ri / ru ) - dis dis = au + ai - den - two * ( one + dis ) dis = den * den - three * dis if ( dis < zero ) cycle main den = den + sqrt ( dis ) if ( den == zero ) cycle main r = ( ru - ri ) / den else cycle main end if if ( mode == 1 . and . r > ru ) then ! extrapolation accepted r = max ( r , c1l * ru ) r = min ( r , c1u * ru ) return elseif ( mode == 2 . and . r > rl . and . r < ru ) then ! interpolation accepted if ( ri == zero . and . ntyp /= 4 ) then r = max ( r , rl + c2l * ( ru - rl )) else r = max ( r , rl + c3l * ( ru - rl )) end if r = min ( r , rl + c2u * ( ru - rl )) if ( r /= ri ) return end if end do main end subroutine line_search_interpolation !*********************************************************************** !> date: 97/12/01 ! ! computation of value of the augmented lagrangian function. ! !@note This routine was formerly called `pp0af8`. pure subroutine compute_augmented_lagrangian ( nf , n , nc , cf , ic , ica , cl , cu , cz , rpf , fc , f ) integer , intent ( in ) :: nf !! number of variables. integer , intent ( in ) :: n !! dimension of the constraint null space. integer , intent ( in ) :: nc !! number of constraints. integer , intent ( in ) :: ic ( * ) !! ic(nc)  vector containing types of constraints. integer , intent ( in ) :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. real ( wp ), intent ( in ) :: cf ( * ) !! cf(nc+1)  vector containing values of the constraints. real ( wp ), intent ( in ) :: cl ( * ) !! cl(nc)  vector containing lower bounds for constraint functions. real ( wp ), intent ( in ) :: cu ( * ) !! cu(nc)  vector containing upper bounds for constraint functions. real ( wp ), intent ( in ) :: cz ( * ) !! cz(nc)  vector of lagrange multipliers. real ( wp ), intent ( in ) :: rpf !! penalty coefficient. real ( wp ), intent ( out ) :: fc !! value of the penalty term. real ( wp ), intent ( out ) :: f !! value of the penalty function. real ( wp ) :: pom , temp integer :: j , kc fc = 0.0_wp do kc = 1 , nc if ( ic ( kc ) > 0 ) then pom = 0.0_wp temp = cf ( kc ) if ( ic ( kc ) == 1 . or . ic ( kc ) >= 3 ) pom = min ( pom , temp - cl ( kc )) if ( ic ( kc ) == 2 . or . ic ( kc ) >= 3 ) pom = min ( pom , cu ( kc ) - temp ) fc = fc + rpf * abs ( pom ) end if end do do j = 1 , nf - n kc = ica ( j ) if ( kc > 0 ) then pom = 0.0_wp temp = cf ( kc ) if ( ic ( kc ) == 1 . or . ic ( kc ) == 3 . or . ic ( kc ) == 5 ) & pom = min ( pom , temp - cl ( kc )) if ( ic ( kc ) == 2 . or . ic ( kc ) == 4 . or . ic ( kc ) == 6 ) & pom = max ( pom , temp - cu ( kc )) fc = fc - cz ( j ) * pom end if end do f = cf ( nc + 1 ) + fc end subroutine compute_augmented_lagrangian !*********************************************************************** !> date: 97/12/01 ! ! computation of the new penalty parameters. ! !@note This routine was formerly called `ppset2`. pure subroutine compute_new_penalty_parameters ( nf , n , nc , ica , cz , cp ) integer , intent ( in ) :: nf !! declared number of variables. integer , intent ( in ) :: n !! actual number of variables. integer , intent ( in ) :: nc !! number of constraints. integer , intent ( in ) :: ica ( * ) !! vector containing indices of active constraints. real ( wp ), intent ( in ) :: cz ( * ) !! vector of lagrange multipliers. real ( wp ), intent ( inout ) :: cp ( * ) !! vector containing penalty parameters. real ( wp ) :: temp integer :: j , l , kc do kc = 1 , nc cp ( kc ) = 0.5_wp * cp ( kc ) end do do j = 1 , nf - n l = ica ( j ) if ( l > 0 ) then temp = abs ( cz ( j )) cp ( l ) = max ( temp , cp ( l ) + 0.5_wp * temp ) end if end do end subroutine compute_new_penalty_parameters !*********************************************************************** !> date: 97/12/01 ! !  extended line search without directional derivatives. ! !### Method ! safeguarded extrapolation and interpolation with extended termination ! criteria. ! !@note This routine was formerly called `ps0l02`. subroutine extended_line_search ( me , r , ro , rp , f , fo , fp , po , pp , fmin , fmax , & rmin , rmax , tols , kd , ld , nit , kit , nred , mred , maxst , iest , & inits , iters , kters , mes , isys ) class ( psqp_class ), intent ( inout ) :: me integer :: kd !! degree of required dervatives. integer :: ld !! degree of previously computed derivatives. integer :: nit !! actual number of iterations. integer :: kit !! number of the iteration after last restart. integer :: nred !! actual number of extrapolations or interpolations. integer :: mred !! maximum number of extrapolations or interpolations. integer :: maxst !! maximum stepsize indicator. maxst=0 or maxst=1 !! if maximum stepsize was not or was reached. integer :: iest !! lower bound specification. iest=0 or iest=1 !! if lower bound is not or is given. integer :: inits !! choice of the initial stepsize. !! !! * inits=0 - initial stepsize is specified in the calling program. !! * inits=1 - unit initial stepsize. !! * inits=2 - combined unit and quadratically estimated initial stepsize. !! * inits=3 - quadratically estimated initial stepsize. integer :: iters !! termination indicator. !! !! * iters=0 - zero step. !! * iters=1 - perfect line search. !! * iters=2   goldstein stepsize. !! * iters=3 - curry stepsize. !! * iters=4 - extended curry stepsize. !! * iters=5 - armijo stepsize. !! * iters=6 - first stepsize. !! * iters=7 - maximum stepsize. !! * iters=8 - unbounded function. !! * iters=-1 - mred reached. !! * iters=-2 - positive directional derivative. !! * iters=-3 - error in interpolation. integer :: kters !! termination selection. !! !! * kters=1 - perfect line search. !! * kters=2 - goldstein stepsize. !! * kters=3 - curry stepsize. !! * kters=4 - extended curry stepsize. !! * kters=5 - armijo stepsize. !! * kters=6 - first stepsize. integer :: mes !! method selection. !! !! * mes=1 - bisection. !! * mes=2 - quadratic interpolation (with one directional derivative). !! * mes=3 - quadratic interpolation (with two directional derivatives). !! * mes=4 - cubic interpolation. !! * mes=5 - conic interpolation. integer :: isys !! control parameter. real ( wp ) :: r !! value of the stepsize parameter. real ( wp ) :: ro !! initial value of the stepsize parameter. real ( wp ) :: rp !! previous value of the stepsize parameter. real ( wp ) :: f !! value of the objective function. real ( wp ) :: fo !! initial value of the objective function. real ( wp ) :: fp !! previous value of the objective function. real ( wp ) :: po !! initial value of the directional derivative. real ( wp ) :: pp !! previous value of the directional derivative. real ( wp ) :: fmin !! lower bound for value of the objective function. real ( wp ) :: fmax !! upper bound for value of the objective function. real ( wp ) :: rmin !! minimum value of the stepsize parameter real ( wp ) :: rmax !! maximum value of the stepsize parameter real ( wp ) :: tols !! termination tolerance for line search !! (in test on the change of the function value). real ( wp ) :: rtemp integer :: merr , init1 logical :: l1 , l2 , l3 , l4 , l6 , l7 real ( wp ), parameter :: tol = 1.0d-4 if ( isys /= 1 ) then ! go to (1,3) isys+1 me % mes1 = 2 me % mes2 = 2 iters = 0 if ( po >= 0.0_wp ) then r = 0.0_wp iters = - 2 isys = 0 return end if if ( rmax <= 0.0_wp ) then iters = 0 isys = 0 return end if ! initial stepsize selection if ( inits > 0 ) then rtemp = fmin - f elseif ( iest == 0 ) then rtemp = f - fp else rtemp = max ( f - fp , 1 0.0_wp * ( fmin - f )) end if init1 = abs ( inits ) rp = 0.0_wp fp = fo pp = po if ( init1 == 0 ) then elseif ( init1 == 1 . or . inits >= 1 . and . iest == 0 ) then r = 1.0_wp elseif ( init1 == 2 ) then r = min ( 1.0_wp , 4.0_wp * rtemp / po ) elseif ( init1 == 3 ) then r = min ( 1.0_wp , 2.0_wp * rtemp / po ) elseif ( init1 == 4 ) then r = 2.0_wp * rtemp / po end if rtemp = r r = max ( r , rmin ) r = min ( r , rmax ) me % mode = 0 me % rl = 0.0_wp me % fl = fo me % ru = 0.0_wp me % fu = fo me % ri = 0.0_wp me % fi = fo elseif ( iters /= 0 ) then isys = 0 return else if ( f <= fmin ) then iters = 7 isys = 0 return else l1 = r <= rmin . and . nit /= kit l2 = r >= rmax l3 = f - fo <= tols * r * po . or . f - fmin <= ( fo - fmin ) / 1 0.0_wp l4 = f - fo >= ( 1.0_wp - tols ) * r * po . or . me % mes2 == 2 . and . me % mode == 2 l6 = me % ru - me % rl <= tol * me % ru . and . me % mode == 2 l7 = me % mes2 <= 2 . or . me % mode /= 0 maxst = 0 if ( l2 ) maxst = 1 end if ! test on termination if ( l1 . and . . not . l3 ) then iters = 0 isys = 0 return elseif ( l2 . and . . not . f >= me % fu ) then iters = 7 isys = 0 return elseif ( l6 ) then iters = 1 isys = 0 return elseif ( l3 . and . l7 . and . kters == 5 ) then iters = 5 isys = 0 return elseif ( l3 . and . l4 . and . l7 . and . & ( kters == 2 . or . kters == 3 . or . kters == 4 )) then iters = 2 isys = 0 return elseif ( kters < 0 . or . kters == 6 . and . l7 ) then iters = 6 isys = 0 return elseif ( abs ( nred ) >= mred ) then iters = - 1 isys = 0 return else rp = r fp = f me % mode = max ( me % mode , 1 ) me % mtyp = abs ( mes ) if ( f >= fmax ) me % mtyp = 1 end if if ( me % mode == 1 ) then ! interval change after extrapolation me % rl = me % ri me % fl = me % fi me % ri = me % ru me % fi = me % fu me % ru = r me % fu = f if ( f >= me % fi ) then nred = 0 me % mode = 2 elseif ( me % mes1 == 1 ) then me % mtyp = 1 end if ! interval change after interpolation elseif ( r <= me % ri ) then if ( f <= me % fi ) then me % ru = me % ri me % fu = me % fi me % ri = r me % fi = f else me % rl = r me % fl = f end if elseif ( f <= me % fi ) then me % rl = me % ri me % fl = me % fi me % ri = r me % fi = f else me % ru = r me % fu = f end if end if ! new stepsize selection (extrapolation or interpolation) call line_search_interpolation ( ro , me % rl , me % ru , me % ri , fo , me % fl , me % fu , & me % fi , po , r , me % mode , me % mtyp , merr ) if ( merr > 0 ) then iters = - merr isys = 0 return elseif ( me % mode == 1 ) then nred = nred - 1 r = min ( r , rmax ) elseif ( me % mode == 2 ) then nred = nred + 1 end if ! computation of the new function value kd = 0 ld = - 1 isys = 1 end subroutine extended_line_search !*********************************************************************** !> date: 92/12/01 ! ! variable metric update of a dense symmetric positive definite matrix ! using the factorization b=l*d*trans(l). ! !### Method ! bfgs variable metric method. ! !@note This routine was formerly called `pudbg1`. subroutine bfgs_variable_metric_update ( n , h , g , s , xo , go , r , po , nit , & kit , iterh , met , met1 , mec ) real ( wp ) :: po !! old value of the directional derivative. real ( wp ) :: r !! value of the stepsize parameter. integer :: iterh !! termination indicator. !! !! * iterh<0-bad decomposition. !! * iterh=0-successful update. !! * iterh>0-nonpositive parameters. integer :: kit !! number of the iteration after last restart. integer :: met !! integer :: met1 !! selection of self scaling. !! !! * met1=1-self scaling suppressed. !! * met1=2 initial self scaling. integer :: mec !! correction if the negative curvature occurs. !! !! * mec=1-correction suppressed. !! * mec=2-powell's correction. integer :: n !! actual number of variables. integer :: nit !! actual number of iterations. real ( wp ) :: g ( * ) !! g(nf)  gradient of the objective function. real ( wp ) :: go ( * ) !! go(nf)  gradients difference. real ( wp ) :: h ( * ) !! h(m)  factorization b=l*d*trans(l) of a positive !! definite approximation of the hessian matrix. real ( wp ) :: s ( * ) !! s(nf)  auxiliary vector. real ( wp ) :: xo ( * ) !! xo(nf)  vectors of variables difference. real ( wp ) :: a , b , c , gam , par , den , dis logical :: l1 , l3 l1 = met1 >= 3 . or . met1 == 2 . and . nit == kit l3 = . not . l1 ! determination of the parameters b, c b = mxvdot ( n , xo , go ) a = 0.0_wp if ( l1 ) then call mxvcop ( n , go , s ) call mxdpgb ( n , h , s , 1 ) a = mxdpgp ( n , h , s , s ) if ( a <= 0.0_wp ) then iterh = 1 return end if end if call mxvdif ( n , go , g , s ) call mxvscl ( n , r , s , s ) c = - r * po if ( c <= 0.0_wp ) then iterh = 3 return end if if ( mec > 1 ) then if ( b <= 1.0e-4_wp * c ) then ! powell's correction dis = ( 1.0_wp - 0.1_wp ) * c / ( c - b ) call mxvdif ( n , go , s , go ) call mxvdir ( n , dis , go , s , go ) b = c + dis * ( b - c ) if ( l1 ) a = c + 2.0_wp * ( 1.0_wp - dis ) * ( b - c ) + dis * dis * ( a - c ) end if elseif ( b <= 1.0e-4_wp * c ) then iterh = 2 return end if if ( l1 ) then ! determination of the parameter gam (self scaling) if ( met == 1 ) then par = c / b elseif ( a <= 0.0_wp ) then par = c / b else par = sqrt ( c / a ) end if gam = par if ( met1 > 1 ) then if ( nit /= kit ) l3 = gam < 0.5_wp . or . gam > 4.0_wp end if end if if ( l3 ) then gam = 1.0_wp par = gam end if if ( met == 1 ) then ! bfgs update call mxdpgu ( n , h , par / b , go , xo ) call mxdpgu ( n , h , - 1.0_wp / c , s , xo ) else ! hoshino update den = par * b + c dis = 0.5_wp * b call mxvdir ( n , par , go , s , s ) call mxdpgu ( n , h , par / dis , go , xo ) call mxdpgu ( n , h , - 1.0_wp / den , s , xo ) end if iterh = 0 if ( gam == 1.0_wp ) return call mxdpgs ( n , h , 1.0_wp / gam ) end subroutine bfgs_variable_metric_update !*********************************************************************** !> date: 91/12/01 ! ! dual range space quadratic programming method for minimax ! approximation. ! !@note This routine was formerly called `pytrnd`. subroutine dual_range_space_qp ( nf , n , x , xo , ica , cg , cz , g , go , r , f , fo , & p , po , cmax , cmaxo , dmax , kd , ld , iters ) integer , intent ( in ) :: nf !! declared number of variables. integer , intent ( inout ) :: n !! actual number of variables. integer , intent ( in ) :: ica ( * ) !! ica(nf)  vector containing indices of active constraints. real ( wp ) :: x ( * ) !! x(nf)  vector of variables. real ( wp ) :: xo ( * ) !! xo(nf)  saved vector of variables. real ( wp ) :: cg ( * ) !! cg(nf*nc)  matrix whose columns are normals of the linear constraints. real ( wp ) :: cz ( * ) !! cz(nf)  vector of lagrange multipliers. real ( wp ) :: g ( * ) !! g(nf)  gradient of the lagrangian function. real ( wp ) :: go ( * ) !! go(nf)  saved gradient of the lagrangian function. real ( wp ) :: r !! value of the stepsize parameter. real ( wp ) :: f !! new value of the objective function. real ( wp ) :: fo !! old value of the objective function. real ( wp ) :: p !! new value of the directional derivative. real ( wp ) :: po !! old value of the directional derivative. real ( wp ) :: cmax !! value of the constraint violation. real ( wp ) :: cmaxo !! saved value of the constraint violation. real ( wp ), intent ( out ) :: dmax !! maximum relative difference of variables. integer :: kd !! integer :: ld !! integer :: iters !! termination indicator for steplength determination. !! iters=0 for zero step. integer :: i , j , l do j = 1 , nf - n l = ica ( j ) if ( l > 0 ) then call mxvdir ( nf , - cz ( j ), cg (( l - 1 ) * nf + 1 ), g , g ) else l = - l g ( l ) = g ( l ) - cz ( j ) end if end do if ( iters > 0 ) then call mxvdif ( nf , x , xo , xo ) call mxvdif ( nf , g , go , go ) po = r * po p = r * p else f = fo p = po cmax = cmaxo call mxvsav ( nf , x , xo ) call mxvsav ( nf , g , go ) ld = kd end if dmax = 0.0_wp do i = 1 , nf dmax = max ( dmax , abs ( xo ( i )) / max ( abs ( x ( i )), 1.0_wp )) end do n = nf end subroutine dual_range_space_qp !*********************************************************************** end module psqp_module !***********************************************************************","tags":"","url":"sourcefile/psqp_module.f90.html"},{"title":"psqp_matrix_module.f90 – psqp","text":"This file depends on sourcefile~~psqp_matrix_module.f90~~EfferentGraph sourcefile~psqp_matrix_module.f90 psqp_matrix_module.f90 sourcefile~psqp_kind_module.f90 psqp_kind_module.F90 sourcefile~psqp_matrix_module.f90->sourcefile~psqp_kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~psqp_matrix_module.f90~~AfferentGraph sourcefile~psqp_matrix_module.f90 psqp_matrix_module.f90 sourcefile~psqp_module.f90 psqp_module.f90 sourcefile~psqp_module.f90->sourcefile~psqp_matrix_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !*********************************************************************** !> !  Matrix routines. ! !### History ! * Original version: LU, 1991 ! !@note Some of these could just be replaced with normal array operations. module psqp_matrix_module use psqp_kind_module , only : wp => psqp_wp implicit none public private :: wp contains !*********************************************************************** !*********************************************************************** !> date: 91/12/01 ! ! solution of a system of linear equations with a dense symmetric ! positive definite matrix a+e using the factorization `a+e=l*d*trans(l)` ! obtained by the subroutine [[mxdpgf]]. ! !### Method ! back substitution pure subroutine mxdpgb ( n , a , x , job ) integer , intent ( in ) :: job !! option !! !! * if `job=0` then `x:=(a+e)**(-1)*x`. !! * if `job>0` then `x:=l**(-1)*x`. !! * if `job<0` then `x:=trans(l)**(-1)*x`. integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: a ( * ) !! `a(n*(n+1)/2)` factorization `a+e=l*d*trans(l)` !! obtained by the subroutine [[mxdpgf]]. real ( wp ), intent ( inout ) :: x ( * ) !! x(n)  on input the right hand side of a !! system of linear equations. on output the !! solution of a system of linear equations. integer :: i , ii , ij , j if ( job >= 0 ) then ! phase 1 : x:=l**(-1)*x ij = 0 do i = 1 , n do j = 1 , i - 1 ij = ij + 1 x ( i ) = x ( i ) - a ( ij ) * x ( j ) end do ij = ij + 1 end do endif if ( job == 0 ) then ! phase 2 : x:=d**(-1)*x ii = 0 do i = 1 , n ii = ii + i x ( i ) = x ( i ) / a ( ii ) end do endif if ( job <= 0 ) then ! phase 3 : x:=trans(l)**(-1)*x ii = n * ( n - 1 ) / 2 do i = n - 1 , 1 , - 1 ij = ii do j = i + 1 , n ij = ij + j - 1 x ( i ) = x ( i ) - a ( ij ) * x ( j ) end do ii = ii - i end do endif end subroutine mxdpgb !*********************************************************************** !> date: 89/12/01 ! ! factorization `a+e=l*d*trans(l)` of a dense symmetric positive definite ! matrix a+e where d and e are diagonal positive definite matrices and ! l is a lower triangular matrix. if a is sufficiently positive ! definite then e=0. ! !### Method !  * p.e.gill, w.murray : newton type methods for unconstrained and !    linearly constrained optimization, math. programming 28 (1974) !    pp. 311-350. pure subroutine mxdpgf ( n , a , inf , alf , tau ) real ( wp ), intent ( inout ) :: alf !! on input a desired tolerance for positive definiteness. on !! output the most negative diagonal element used in the !! factorization process (if inf>0). real ( wp ), intent ( out ) :: tau !! maximum diagonal element of the matrix e. integer , intent ( out ) :: inf !! an information obtained in the factorization process. if: !! !!  * `inf=0` then a is sufficiently positive definite and e=0. if !!  * `inf<0` then a is not sufficiently positive definite and e>0. if !!  * `inf>0` then a is indefinite and inf is an index of the !!    most negative diagonal element used in the factorization !!    process. integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( inout ) :: a ( * ) !! `a(n*(n+1)/2)`  on input a given dense symmetric (usually positive !! definite) matrix a stored in the packed form. on output the !! computed factorization `a+e=l*d*trans(l)`. real ( wp ) :: bet , del , gam , rho , sig , tol integer :: i , ij , ik , j , k , kj , kk , l l = 0 inf = 0 tol = alf ! estimation of the matrix norm alf = 0.0_wp bet = 0.0_wp gam = 0.0_wp tau = 0.0_wp kk = 0 do k = 1 , n kk = kk + k bet = max ( bet , abs ( a ( kk ))) kj = kk do j = k + 1 , n kj = kj + j - 1 gam = max ( gam , abs ( a ( kj ))) end do end do bet = max ( tol , bet , gam / n ) ! del = tol*bet del = tol * max ( bet , 1.0_wp ) kk = 0 do k = 1 , n kk = kk + k ! determination of a diagonal correction sig = a ( kk ) if ( alf > sig ) then alf = sig l = k endif gam = 0.0_wp kj = kk do j = k + 1 , n kj = kj + j - 1 gam = max ( gam , abs ( a ( kj ))) end do gam = gam * gam rho = max ( abs ( sig ), gam / bet , del ) if ( tau < rho - sig ) then tau = rho - sig inf = - 1 endif ! gaussian elimination a ( kk ) = rho kj = kk do j = k + 1 , n kj = kj + j - 1 gam = a ( kj ) a ( kj ) = gam / rho ik = kk ij = kj do i = k + 1 , j ik = ik + i - 1 ij = ij + 1 a ( ij ) = a ( ij ) - a ( ik ) * gam end do end do end do if ( l > 0 . and . abs ( alf ) > del ) inf = l end subroutine mxdpgf !*********************************************************************** !> date: 91/12/01 ! ! computation of the number `mxdpgp=trans(x)*d**(-1)*y` where d is a ! diagonal matrix in the factorization `a+e=l*d*trans(l)` obtained by the ! subroutine [[mxdpgf]]. pure function mxdpgp ( n , a , x , y ) integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: a ( * ) !! `a(n*(n+1)/2)` factorization `a+e=l*d*trans(l)` !! obtained by the subroutine [[mxdpgf]]. real ( wp ), intent ( in ) :: x ( * ) !! input vector. real ( wp ), intent ( in ) :: y ( * ) !! input vector. real ( wp ) :: mxdpgp !! computed number `mxdpgp=trans(x)*d**(-1)*y`. real ( wp ) :: temp integer :: i , j j = 0 temp = 0.0_wp do i = 1 , n j = j + i temp = temp + x ( i ) * y ( i ) / a ( j ) end do mxdpgp = temp end function mxdpgp !*********************************************************************** !> date: 91/12/01 ! ! scaling of a dense symmetric positive definite matrix a+e using the ! factorization `a+e=l*d*trans(l)` obtained by the subroutine [[mxdpgf]]. pure subroutine mxdpgs ( n , a , alf ) real ( wp ), intent ( in ) :: alf !! scaling factor. integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( inout ) :: a ( * ) !! `a(n*(n+1)/2)` factorization `a+e=l*d*trans(l)` !! obtained by the subroutine [[mxdpgf]]. integer :: i , j j = 0 do i = 1 , n j = j + i a ( j ) = a ( j ) * alf end do end subroutine mxdpgs !*********************************************************************** !> date: 89/12/01 ! ! correction of a dense symmetric positive definite matrix `a+e` in the ! factored form `a+e=l*d*trans(l)` obtained by the subroutine [[mxdpgf]]. ! the correction is defined as `a+e:=a+e+alf*x*trans(x)` where `alf` is a ! given scaling factor and `x` is a given vector. ! !### Method !  * p.e.gill, w.murray, m.saunders: methods for computing and modifying !    the ldv factors of a matrix, math. of comp. 29 (1974) pp. 1051-1077. pure subroutine mxdpgu ( n , a , alf , x , y ) integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: alf !! scaling factor in the correction term. real ( wp ), intent ( inout ) :: a ( * ) !! `a(n*(n+1)/2)` factorization `a+e=l*d*trans(l)` !! obtained by the subroutine [[mxdpgf]]. real ( wp ), intent ( in ) :: x ( * ) !! vector in the correction term. real ( wp ), intent ( out ) :: y ( * ) !! auxiliary vector. real ( wp ) :: alfr real ( wp ) :: b , d , p , r , t , to integer :: i , ii , ij , j real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: four = 4.0_wp real ( wp ), parameter :: con = 1.0e-8_wp if ( alf >= zero ) then ! forward correction in case when the scaling factor is nonnegative alfr = sqrt ( alf ) call mxvscl ( n , alfr , x , y ) to = one ii = 0 do i = 1 , n ii = ii + i d = a ( ii ) p = y ( i ) t = to + p * p / d r = to / t a ( ii ) = d / r b = p / ( d * t ) if ( a ( ii ) <= four * d ) then ! an easy formula for limited diagonal element ij = ii do j = i + 1 , n ij = ij + j - 1 d = a ( ij ) y ( j ) = y ( j ) - p * d a ( ij ) = d + b * y ( j ) end do else ! a more complicate but numerically stable formula for unlimited ! diagonal element ij = ii do j = i + 1 , n ij = ij + j - 1 d = a ( ij ) a ( ij ) = r * d + b * y ( j ) y ( j ) = y ( j ) - p * d end do endif to = t end do else ! backward correction in case when the scaling factor is negative alfr = sqrt ( - alf ) call mxvscl ( n , alfr , x , y ) to = one ij = 0 do i = 1 , n d = y ( i ) do j = 1 , i - 1 ij = ij + 1 d = d - a ( ij ) * y ( j ) end do y ( i ) = d ij = ij + 1 to = to - d * d / a ( ij ) end do if ( to <= zero ) to = con ii = n * ( n + 1 ) / 2 do i = n , 1 , - 1 d = a ( ii ) p = y ( i ) t = to + p * p / d a ( ii ) = d * to / t b = - p / ( d * to ) to = t ij = ii do j = i + 1 , n ij = ij + j - 1 d = a ( ij ) a ( ij ) = d + b * y ( j ) y ( j ) = y ( j ) + p * d end do ii = ii - i end do endif end subroutine mxdpgu !*********************************************************************** !> date: 89/12/01 ! ! solution of a system of linear equations with a dense symmetric ! positive definite matrix a using the factorization a=trans(r)*r. ! !### Method ! back substitution pure subroutine mxdprb ( n , a , x , job ) integer , intent ( in ) :: job !! option !! !! * if job=0 then x:=a**(-1)*x. !! * if job>0 then x:=trans(r)**(-1)*x. !! * if job<0 then x:=r**(-1)*x. integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: a ( * ) !! a(n*(n+1)/2) factorization a=trans(r)*r. real ( wp ), intent ( inout ) :: x ( * ) !! x(n)  on input the right hand side of a system of linear !! equations. on output the solution of a system of linear !! equations. integer :: i , ii , ij , j if ( job >= 0 ) then ! phase 1 : x:=trans(r)**(-1)*x ij = 0 do i = 1 , n do j = 1 , i - 1 ij = ij + 1 x ( i ) = x ( i ) - a ( ij ) * x ( j ) end do ij = ij + 1 x ( i ) = x ( i ) / a ( ij ) end do endif if ( job <= 0 ) then ! phase 2 : x:=r**(-1)*x ii = n * ( n + 1 ) / 2 do i = n , 1 , - 1 ij = ii do j = i + 1 , n ij = ij + j - 1 x ( i ) = x ( i ) - a ( ij ) * x ( j ) end do x ( i ) = x ( i ) / a ( ii ) ii = ii - i end do endif end subroutine mxdprb !*********************************************************************** !> date: 88/12/01 ! ! dense symmetric matrix a is set to the unit matrix with the same ! order. pure subroutine mxdsmi ( n , a ) integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( out ) :: a ( * ) !! `a(n*(n+1)/2)`  dense symmetric matrix !! stored in the packed form which is set !! to the unit matrix (i.e. `a:=i`). integer :: i , m m = n * ( n + 1 ) / 2 do i = 1 , m a ( i ) = 0.0_wp end do m = 0 do i = 1 , n m = m + i a ( m ) = 1.0_wp end do end subroutine mxdsmi !*********************************************************************** !> date: 89/12/01 ! ! multiplication of a dense symmetric matrix a by a vector x. pure subroutine mxdsmm ( n , a , x , y ) integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: a ( * ) !! `a(n*(n+1)/2)`  dense symmetric matrix stored in the packed form. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( out ) :: y ( * ) !! y(n)  output vector equal to ` a*x`. real ( wp ) :: temp integer :: i , j , k , l k = 0 do i = 1 , n temp = 0.0_wp l = k do j = 1 , i l = l + 1 temp = temp + a ( l ) * x ( j ) end do do j = i + 1 , n l = l + j - 1 temp = temp + a ( l ) * x ( j ) end do y ( i ) = temp k = k + i end do end subroutine mxdsmm !*********************************************************************** !> date: 91/12/01 ! ! k-th row of a dense symmetric matrix a is copied to the vector x. pure subroutine mxdsmv ( n , a , x , k ) integer , intent ( in ) :: k !! index of copied row. integer , intent ( in ) :: n !! order of the matrix a. real ( wp ), intent ( in ) :: a ( * ) !! `a(n*(n+1)/2)`  dense symmetric matrix !! stored in the packed form. real ( wp ), intent ( out ) :: x ( * ) !! x(n)  output vector. integer :: i , l l = k * ( k - 1 ) / 2 do i = 1 , n if ( i <= k ) then l = l + 1 else l = l + i - 1 endif x ( i ) = a ( l ) end do end subroutine mxdsmv !*********************************************************************** !> date: 88/12/01 ! ! copying of a vector. pure subroutine mxvcop ( n , x , y ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( out ) :: y ( * ) !! y(n)  output vector where `y:= x`. integer :: i do i = 1 , n y ( i ) = x ( i ) end do end subroutine mxvcop !*********************************************************************** !> date: 88/12/01 ! ! vector difference. pure subroutine mxvdif ( n , x , y , z ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( in ) :: y ( * ) !! y(n)  input vector. real ( wp ), intent ( out ) :: z ( * ) !! z(n)  output vector where `z:= x - y`. integer :: i do i = 1 , n z ( i ) = x ( i ) - y ( i ) end do end subroutine mxvdif !*********************************************************************** !> date: 91/12/01 ! ! vector augmented by the scaled vector. pure subroutine mxvdir ( n , a , x , y , z ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: a !! scaling factor. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( in ) :: y ( * ) !! y(n)  input vector. real ( wp ), intent ( out ) :: z ( * ) !! z(n)  output vector where `z:= y + a*x`. integer :: i do i = 1 , n z ( i ) = y ( i ) + a * x ( i ) end do end subroutine mxvdir !*********************************************************************** !> date: 91/12/01 ! ! dot product of two vectors. ! ! JW: rewrote this routine. pure function mxvdot ( n , x , y ) integer , intent ( in ) :: n !!vector dimension. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( in ) :: y ( * ) !! y(n)  input vector. real ( wp ) :: mxvdot !! value of dot product `mxvdot=trans(x)*y`. mxvdot = dot_product ( x ( 1 : n ), y ( 1 : n )) end function mxvdot !*********************************************************************** !> date: 90/12/01 ! ! elements of the integer vector are replaced by their absolute values. ! ! Note that this function also subtracts 10 from `ix` if the absolute value ! is greater than 10. pure subroutine mxvina ( n , ix ) integer , intent ( in ) :: n !! dimension of the integer vector. integer , intent ( inout ) :: ix ( * ) !! vector which is updated so that !! `ix(i):=abs(ix(i))` for all i. integer :: i do i = 1 , n ix ( i ) = abs ( ix ( i )) if ( ix ( i ) > 10 ) ix ( i ) = ix ( i ) - 10 end do end subroutine mxvina !*********************************************************************** !> date: 91/12/01 ! ! change of the integer vector element for the constraint addition. pure subroutine mxvinv ( ix , i , job ) integer , intent ( in ) :: i !! index of the changed element. integer , intent ( in ) :: job !! change specification integer , intent ( inout ) :: ix ( * ) !! ix(n)  integer vector. if ( ( ix ( i ) == 3 . or . ix ( i ) == 5 ) . and . job < 0 ) ix ( i ) = ix ( i ) + 1 if ( ( ix ( i ) == 4 . or . ix ( i ) == 6 ) . and . job > 0 ) ix ( i ) = ix ( i ) - 1 ix ( i ) = - ix ( i ) end subroutine mxvinv !*********************************************************************** !> date: 91/12/01 ! ! l-infinity norm of a vector. pure function mxvmax ( n , x ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ) :: mxvmax !! l-infinity norm of the vector x. integer :: i mxvmax = 0.0_wp do i = 1 , n mxvmax = max ( mxvmax , abs ( x ( i ))) end do end function mxvmax !*********************************************************************** !> date: 88/12/01 ! ! change the signs of vector elements. pure subroutine mxvneg ( n , x , y ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( out ) :: y ( * ) !! y(n)  output vector where `y:= - x`. integer :: i do i = 1 , n y ( i ) = - x ( i ) end do end subroutine mxvneg !*********************************************************************** !> date: 91/12/01 ! ! determination of an elementary orthogonal matrix for plane rotation. pure subroutine mxvort ( xk , xl , ck , cl , ier ) real ( wp ), intent ( inout ) :: xk !! first value for plane rotation !! (xk is transformed to sqrt(xk**2+xl**2)) real ( wp ), intent ( inout ) :: xl !! second value for plane rotation !! (xl is transformed to zero) real ( wp ), intent ( out ) :: ck !! diagonal element of the elementary orthogonal matrix. real ( wp ), intent ( out ) :: cl !! off-diagonal element of the elementary orthogonal matrix. integer , intent ( out ) :: ier !! information on the transformation. !! !! * `ier=0` -- general plane rotation. !! * `ier=1` -- permutation. !! * `ier=2` -- transformation suppressed. real ( wp ) :: den , pom if ( xl == 0.0_wp ) then ier = 2 elseif ( xk == 0.0_wp ) then xk = xl xl = 0.0_wp ier = 1 else if ( abs ( xk ) >= abs ( xl ) ) then pom = xl / xk den = sqrt ( 1.0_wp + pom * pom ) ck = 1.0_wp / den cl = pom / den xk = xk * den else pom = xk / xl den = sqrt ( 1.0_wp + pom * pom ) cl = 1.0_wp / den ck = pom / den xk = xl * den endif xl = 0.0_wp ier = 0 endif end subroutine mxvort !*********************************************************************** !> date: 91/12/01 ! ! plane rotation is applied to two values. pure subroutine mxvrot ( xk , xl , ck , cl , ier ) real ( wp ), intent ( in ) :: ck !! diagonal element of the elementary orthogonal matrix. real ( wp ), intent ( in ) :: cl !! off-diagonal element of the elementary orthogonal matrix. real ( wp ), intent ( inout ) :: xk !! first value for plane rotation. real ( wp ), intent ( inout ) :: xl !! second value for plane rotation. integer , intent ( in ) :: ier !! information on the transformation: !! !! * ier=0-general plane rotation. !! * ier=1-permutation. !! * ier=2-transformation suppressed. real ( wp ) :: yk , yl if ( ier == 0 ) then yk = xk yl = xl xk = ck * yk + cl * yl xl = cl * yk - ck * yl elseif ( ier == 1 ) then yk = xk xk = xl xl = yk endif end subroutine mxvrot !*********************************************************************** !> date: 91/12/01 ! ! difference of two vectors returned in the subtracted one. pure subroutine mxvsav ( n , x , y ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( inout ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( inout ) :: y ( * ) !! y(n)  update vector where `y:= x - y`. real ( wp ) :: temp integer :: i do i = 1 , n temp = y ( i ) y ( i ) = x ( i ) - y ( i ) x ( i ) = temp end do end subroutine mxvsav !*********************************************************************** !> date: 88/12/01 ! ! scaling of a vector. pure subroutine mxvscl ( n , a , x , y ) integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( in ) :: a !! scaling factor. real ( wp ), intent ( in ) :: x ( * ) !! x(n)  input vector. real ( wp ), intent ( out ) :: y ( * ) !! y(n)  output vector where `y:= a*x`. integer :: i do i = 1 , n y ( i ) = a * x ( i ) end do end subroutine mxvscl !*********************************************************************** !> date: 88/12/01 ! ! a scalar is set to all the elements of a vector. pure subroutine mxvset ( n , a , x ) real ( wp ), intent ( in ) :: a !! initial value. integer , intent ( in ) :: n !! vector dimension. real ( wp ), intent ( out ) :: x ( * ) !! x(n)  output vector such that `x(i)=a` for all i. integer :: i do i = 1 , n x ( i ) = a end do end subroutine mxvset end module psqp_matrix_module","tags":"","url":"sourcefile/psqp_matrix_module.f90.html"},{"title":"psqp_kind_module.F90 – psqp","text":"Files dependent on this one sourcefile~~psqp_kind_module.f90~~AfferentGraph sourcefile~psqp_kind_module.f90 psqp_kind_module.F90 sourcefile~psqp_matrix_module.f90 psqp_matrix_module.f90 sourcefile~psqp_matrix_module.f90->sourcefile~psqp_kind_module.f90 sourcefile~psqp_module.f90 psqp_module.f90 sourcefile~psqp_module.f90->sourcefile~psqp_kind_module.f90 sourcefile~psqp_module.f90->sourcefile~psqp_matrix_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 12/22/2015 ! !  Numeric kind definitions. module psqp_kind_module use , intrinsic :: iso_fortran_env implicit none private #ifdef REAL32 integer , parameter :: wp = real32 !! Real working precision [4 bytes] #elif REAL64 integer , parameter :: wp = real64 !! Real working precision [8 bytes] #elif REAL128 integer , parameter :: wp = real128 !! Real working precision [16 bytes] #else integer , parameter :: wp = real64 !! Real working precision if not specified [8 bytes] #endif integer , parameter , public :: psqp_wp = wp !! Working real precision end module psqp_kind_module !*****************************************************************************************","tags":"","url":"sourcefile/psqp_kind_module.f90.html"}]}